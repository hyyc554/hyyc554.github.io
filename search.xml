<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ES基础学习</title>
      <link href="/2018/10/17/ES6/"/>
      <url>/2018/10/17/ES6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是ECMAScript"><a href="#1-什么是ECMAScript" class="headerlink" title="1. 什么是ECMAScript"></a>1. 什么是ECMAScript</h2><blockquote><p>ECMAScript是一种由<a href="https://baike.baidu.com/item/Ecma%E5%9B%BD%E9%99%85" target="_blank" rel="noopener">Ecma国际</a>（前身为<a href="https://baike.baidu.com/item/%E6%AC%A7%E6%B4%B2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B6%E9%80%A0%E5%95%86%E5%8D%8F%E4%BC%9A/2052072" target="_blank" rel="noopener">欧洲计算机制造商协会</a>,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">程序设计语言</a>。这种语言在<a href="https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="noopener">万维网</a>上应用广泛，它往往被称为<a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a>或<a href="https://baike.baidu.com/item/JScript" target="_blank" rel="noopener">JScript</a>，所以它可以理解为是javascript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。</p></blockquote><p><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181017161404854-2106065944.png" alt="img"></p><h3 id="ECMAScript-与-JavaScript"><a href="#ECMAScript-与-JavaScript" class="headerlink" title="ECMAScript 与 JavaScript"></a>ECMAScript 与 JavaScript</h3><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p><p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p><p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p><h2 id="2-什么是ES6"><a href="#2-什么是ES6" class="headerlink" title="2. 什么是ES6"></a>2. 什么是ES6</h2><p><strong>ES6</strong>是继ES5之后的一次主要改进，语言规范由ES5.1时代的245页扩充至600页。</p><p>ES6增添了许多必要的特性，例如：模块和类，以及一些实用特性，例如Maps、Sets、Promises、生成器（Generators）等。</p><p>尽管ES6做了大量的更新，但是它依旧完全向后兼容以前的版本，标准化委员会决定避免由不兼容版本语言导致的“web体验破碎”。结果是，所有老代码都可以正常运行，整个过渡也显得更为平滑，但随之而来的问题是，开发者们抱怨了多年的老问题依然存在。</p><h2 id="3-ES6语法"><a href="#3-ES6语法" class="headerlink" title="3. ES6语法"></a>3. ES6语法</h2><h3 id="3-1-let命令"><a href="#3-1-let命令" class="headerlink" title="3.1 let命令"></a>3.1 let命令</h3><h4 id="3-1-1-基础用法"><a href="#3-1-1-基础用法" class="headerlink" title="3.1.1 基础用法"></a>3.1.1 基础用法</h4><p>es6新增了 let 命令，用来声明变量。它的用法类似于 var ，但是所声明的变量，只在let命令所在的代码块内有效。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&#123;<br>  let a = 10;<br>  var b = 1;<br>&#125;<br><br>a // ReferenceError: a is not defined.<br>b // 1<br></code></pre></td></tr></table></figure><p>上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错， var 声明的变量返回了正确的值。这表明， let 声明的变量只在它所在的代码块有效</p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">for (let i = 0; i &lt; 10; i++) &#123;<br>  // ...<br>&#125;<br><br>console.log(i);<br>// ReferenceError: i is not defined<br></code></pre></td></tr></table></figure><p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用<code>var</code>，最后输出的是<code>10</code>。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var a = [];<br>for (var i = 0; i &lt; 10; i++) &#123;<br>  a[i] = function () &#123;<br>    console.log(i);<br>  &#125;;<br>&#125;<br>a[6](); // 10<br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p><p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var a = [];<br>for (let i = 0; i &lt; 10; i++) &#123;<br>  a[i] = function () &#123;<br>    console.log(i);<br>  &#125;;<br>&#125;<br>a[6](); // 6<br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">for (let i = 0; i &lt; 3; i++) &#123;<br>  let i = &apos;abc&apos;;<br>  console.log(i);<br>&#125;<br>// abc<br>// abc<br>// abc<br></code></pre></td></tr></table></figure><p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h4 id="3-1-2-不存在变量提升"><a href="#3-1-2-不存在变量提升" class="headerlink" title="3.1.2 不存在变量提升"></a>3.1.2 不存在变量提升</h4><p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// var 的情况<br>console.log(foo); // 输出undefined<br>var foo = 2;<br><br>// let 的情况<br>console.log(bar); // 报错ReferenceError<br>let bar = 2;<br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h4 id="3-1-3-为什么需要块级作用域？"><a href="#3-1-3-为什么需要块级作用域？" class="headerlink" title="3.1.3 为什么需要块级作用域？"></a>3.1.3 为什么需要块级作用域？</h4><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p> 第一种场景，内层变量可能会覆盖外层变量。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var tmp = new Date();<br><br>function f() &#123;<br>  console.log(tmp);<br>  if (false) &#123;<br>    var tmp = &apos;hello world&apos;;<br>  &#125;<br>&#125;<br><br>f(); // undefined<br></code></pre></td></tr></table></figure><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var s = &apos;hello&apos;;<br><br>for (var i = 0; i &lt; s.length; i++) &#123;<br>  console.log(s[i]);<br>&#125;<br><br>console.log(i); // 5<br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h4 id="3-1-4-不允许重复声明"><a href="#3-1-4-不允许重复声明" class="headerlink" title="3.1.4 不允许重复声明"></a>3.1.4 不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 报错<br>function func() &#123;<br>  let a = 10;<br>  var a = 1;<br>&#125;<br><br>// 报错<br>function func() &#123;<br>  let a = 10;<br>  let a = 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，不能在函数内部重新声明参数。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function func(arg) &#123;<br>  let arg; // 报错<br>&#125;<br><br>function func(arg) &#123;<br>  &#123;<br>    let arg; // 不报错<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-const命令"><a href="#3-2-const命令" class="headerlink" title="3.2 const命令"></a>3.2 const命令</h3><h4 id="3-2-1-基本用法"><a href="#3-2-1-基本用法" class="headerlink" title="3.2.1 基本用法"></a>3.2.1 基本用法</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const PI = 3.1415;<br>PI // 3.1415<br><br>PI = 3;<br>// TypeError: Assignment to constant variable.<br></code></pre></td></tr></table></figure><p>上面代码表明改变常量的值会报错。</p><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const foo;<br>// SyntaxError: Missing initializer in const declaration<br></code></pre></td></tr></table></figure><p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">if (true) &#123;<br>  const MAX = 5;<br>&#125;<br><br>MAX // Uncaught ReferenceError: MAX is not defined<br></code></pre></td></tr></table></figure><p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">if (true) &#123;<br>  console.log(MAX); // ReferenceError<br>  const MAX = 5;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var message = &quot;Hello!&quot;;<br>let age = 25;<br><br>// 以下两行都会报错<br>const message = &quot;Goodbye!&quot;;<br>const age = 30;<br></code></pre></td></tr></table></figure><h3 id="3-3-模板字符串"><a href="#3-3-模板字符串" class="headerlink" title="3.3 模板字符串"></a>3.3 模板字符串</h3><p>传统的JavaScript语言，输出模板通常是这样的写的。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$(&apos;#result&apos;).append(<br>  &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; +<br>  &apos;items in your basket, &apos; +<br>  &apos;&lt;em&gt;&apos; + basket.onSale +<br>  &apos;&lt;/em&gt; are on sale!&apos;<br>);<br></code></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$(&apos;#result&apos;).append(`<br>  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items<br>   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;<br>  are on sale!<br>`);<br></code></pre></td></tr></table></figure><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 普通字符串<br>`In JavaScript &apos;\n&apos; is a line-feed.`<br><br>// 多行字符串<br>`In JavaScript this is<br> not legal.`<br><br>console.log(`string text line 1<br>string text line 2`);<br><br>// 字符串中嵌入变量<br>let name = &quot;Bob&quot;, time = &quot;today&quot;;<br>`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`<br></code></pre></td></tr></table></figure><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let greeting = `\`Yo\` World!`;<br></code></pre></td></tr></table></figure><p>输入结果：<code>Yo</code> World!</p><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$(&apos;#list&apos;).html(`<br>&lt;ul&gt;<br>  &lt;li&gt;first&lt;/li&gt;<br>  &lt;li&gt;second&lt;/li&gt;<br>&lt;/ul&gt;<br>`);<br></code></pre></td></tr></table></figure><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><p>阮一峰：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a></p><p>维基百科： <a href="https://zh.wikipedia.org/wiki/ECMAScript" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/ECMAScript</a></p><p>百度百科：<a href="https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/17/hello-world/"/>
      <url>/2018/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
