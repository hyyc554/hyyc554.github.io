<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>第4章 数据安全与性能保障</title>
      <link href="/2018/12/30/note1/"/>
      <url>/2018/12/30/note1/</url>
      
        <content type="html"><![CDATA[<p>目的：理解Redis的运作原理</p><h2 id="4-1-持久化选项"><a href="#4-1-持久化选项" class="headerlink" title="4.1 持久化选项"></a>4.1 持久化选项</h2><p>一句话概括持久化概念：将内存中的数据保存到硬盘。</p><p>Redis的<strong>持久化方式</strong>：</p><ol><li><p><strong>快照（snapshotting)</strong></p><p>将某一时刻的所有数据保存到硬盘</p></li><li><p><strong>只追加文件（append-only file,  AOF)</strong></p><p>在执行写命令时，将被执行的写命令复制到硬盘中。</p></li></ol><p>上述两种方法可以灵活的选择、结合使用。</p><p>使用Redis数据<strong>持久化的原因</strong>：</p><ol><li>重用数据</li><li>防止系统故障</li><li>针对复杂计算得出的结果，进行持久化，可以节省时间</li></ol><h3 id="4-1-1-快照的持久化"><a href="#4-1-1-快照的持久化" class="headerlink" title="4.1.1 快照的持久化"></a>4.1.1 快照的持久化</h3><p>创建快照——获得存储在内存里面的数据在某个时间点上的副本</p><p>创建快照的方法</p><ol><li><p>BGSAVE（由于需要调用unix的fork，windows没有）</p></li><li><p>SAVE</p><p>该命令完成前将不会执行其他指令</p></li><li><p>配置了SAVE选项，满足条件调用BGSAVE</p></li><li><p>收到SHUTDOWN或者TERM信号，会调用SAVE</p></li><li><p>链接另一个服务器，并执行SYNC命令</p></li></ol><p><strong>要点：</strong></p><p>​    <strong>如果系统发生崩溃，用户将丢失最近一次生成快照之后更改的数据</strong></p><p>使用场景：</p><ul><li><p>个人开发</p></li><li><p>对日志进行聚合计算</p></li><li><p>大数据</p><p>创建子进程将会消耗大量的时间</p></li></ul><p>如果能接受并处理好数据丢失的情况，快照是一个不错的持久化方案，否则应该考虑AOF</p><h3 id="4-1-2-AOF持久化"><a href="#4-1-2-AOF持久化" class="headerlink" title="4.1.2 AOF持久化"></a>4.1.2 AOF持久化</h3><p>AOF持久化会将被执行的命令写到AOF文件的末尾，以此来记录数据发生的改变。</p><p>只需要从头到尾执行AOF文件所包含的命令，就可以恢复数据集。</p><p>启用：</p><p>​    <code>appendonly yes</code></p><p><code>appendfsync everysec</code> 可以兼顾数据安全与写入性能</p><p>缺陷：</p><p>​    AOF文件的大小</p><h3 id="4-1-3-重写-压缩AOF文件"><a href="#4-1-3-重写-压缩AOF文件" class="headerlink" title="4.1.3 重写/压缩AOF文件"></a>4.1.3 重写/压缩AOF文件</h3><p>问题：</p><p>​    Redis会不断将命令写入AOF文件，随着运行时间的增长，AOF文件的体积会不断变大，如果不做处理，将会占用大量的硬盘资源。</p><p>解决方案：</p><p>​    <code>BGREWRITEAOF</code>命令——通过此命令可以移除AOF中冗余的命令记录，从而达到重写AOF来减小体积。</p><p>​    <code>auto-aof-rewrite-percentage</code>与<code>auto-aof-rewrite-min-size</code>选项来配置自动执行<code>BGREWRITEAOF</code></p><p>随着负载的上升，可以考虑复制特性</p><h2 id="4-2-复制"><a href="#4-2-复制" class="headerlink" title="4.2 复制"></a>4.2 复制</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>流畅的Python读书笔记(1)</title>
      <link href="/2018/12/29/%E6%B5%81%E7%95%85%E7%9A%84python(%E4%B8%80)/"/>
      <url>/2018/12/29/%E6%B5%81%E7%95%85%E7%9A%84python(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>流畅的Python读书笔记</p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><blockquote><p>前言</p><p>Python 官方教程（<a href="https://docs.python.org/3/tutorial/）的开头是这样写的：" target="_blank" rel="noopener">https://docs.python.org/3/tutorial/）的开头是这样写的：</a> “Python 是一门既<br>容易上手又强大的编程语言。 ”这句话本身并无大碍，但需要注意的是，正因为它既好学<br>又好用，所以很多 Python 程序员只用到了其强大功能的一小部分。<br><a id="more"></a><br>工作中人们往往带着一种这很简单的错觉，希望通过这本书我可以学习到进阶的知识，摆脱这样的印象</p></blockquote><h2 id="第一章-Python数据模型"><a href="#第一章-Python数据模型" class="headerlink" title="第一章 Python数据模型"></a>第一章 Python数据模型</h2><p>1.1 python风格的纸牌</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits </span><br><span class="line">                   <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure><p>关于<code>collections</code>的用法</p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431953239820157155d21c494e5786fce303f3018c86000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431953239820157155d21c494e5786fce303f3018c86000</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS下安装Docker</title>
      <link href="/2018/12/19/%E4%BD%BF%E7%94%A8%20yum%20%E5%AE%89%E8%A3%85%EF%BC%88CentOS%207%E4%B8%8B%EF%BC%89/"/>
      <url>/2018/12/19/%E4%BD%BF%E7%94%A8%20yum%20%E5%AE%89%E8%A3%85%EF%BC%88CentOS%207%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-yum-安装（CentOS-7下）"><a href="#使用-yum-安装（CentOS-7下）" class="headerlink" title="使用 yum 安装（CentOS 7下）"></a>使用 yum 安装（CentOS 7下）</h2><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p><a id="more"></a><p>通过 <code>uname -r</code>命令查看你当前的内核版本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -r 3.10.0-327.el7.x86_64</span><br></pre></td></tr></table></figure><p><img src="http://www.runoob.com/wp-content/uploads/2016/05/docker08.png" alt="img"></p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。</p><p>Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。</p><p>本文介绍 Docker CE 的安装使用。</p><p>移除旧的版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p>安装一些必要的系统工具：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>添加软件源信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>更新 yum 缓存：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><p>安装 Docker-ce：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>启动 Docker 后台服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>测试运行 hello-world</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="http://www.runoob.com/wp-content/uploads/2016/05/docker12.png" alt="img"></p><p>由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><p><a href="http://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">http://www.runoob.com/docker/centos-docker-install.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python一行代码处理地理围栏</title>
      <link href="/2018/12/15/Python%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%A4%84%E7%90%86%E5%9C%B0%E7%90%86%E5%9B%B4%E6%A0%8F/"/>
      <url>/2018/12/15/Python%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%A4%84%E7%90%86%E5%9C%B0%E7%90%86%E5%9B%B4%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<p>最近在工作中遇到了这个一个需求，用户设定地理围栏，后台获取到实时位置信息后通过与围栏比较，判断是否越界等。</p><p>这个过程需要用到数据协议为GEOjson，通过查阅资料后，发现python的shapely库可以非常简单的解决这个问题,接下来演示一下我处理这个问题的过程。</p><a id="more"></a><h2 id="测试数据："><a href="#测试数据：" class="headerlink" title="测试数据："></a>测试数据：</h2><p>通过<a href="http://geojson.io/来获得测试数据，如下图，在地图上绘制了一个多边形设为地理围栏，分别取了围栏内外两个点来进行测试。" target="_blank" rel="noopener">http://geojson.io/来获得测试数据，如下图，在地图上绘制了一个多边形设为地理围栏，分别取了围栏内外两个点来进行测试。</a></p><p><img src="https://s1.ax1x.com/2018/12/14/FUwEh4.png" alt="FUwEh4.png"></p><p>得到GEOjson数据如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"FeatureCollection"</span>,</span><br><span class="line">  <span class="attr">"features"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Feature"</span>,</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"geometry"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"Polygon"</span>,</span><br><span class="line">        <span class="attr">"coordinates"</span>: [</span><br><span class="line">          [</span><br><span class="line">            [</span><br><span class="line">              <span class="number">114.3458104133606</span>,</span><br><span class="line">              <span class="number">30.476167529462785</span></span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              <span class="number">114.34512376785278</span>,</span><br><span class="line">              <span class="number">30.475575748963195</span></span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              <span class="number">114.34576749801636</span>,</span><br><span class="line">              <span class="number">30.474540124433936</span></span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              <span class="number">114.3467652797699</span>,</span><br><span class="line">              <span class="number">30.475363076967565</span></span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              <span class="number">114.34693694114685</span>,</span><br><span class="line">              <span class="number">30.476102803645833</span></span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              <span class="number">114.3458104133606</span>,</span><br><span class="line">              <span class="number">30.476167529462785</span></span><br><span class="line">            ]</span><br><span class="line">          ]</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Feature"</span>,</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"geometry"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"Point"</span>,</span><br><span class="line">        <span class="attr">"coordinates"</span>: [</span><br><span class="line">          <span class="number">114.34605717658997</span>,</span><br><span class="line">          <span class="number">30.475584995561178</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Feature"</span>,</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"geometry"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"Point"</span>,</span><br><span class="line">        <span class="attr">"coordinates"</span>: [</span><br><span class="line">          <span class="number">114.346604347229</span>,</span><br><span class="line">          <span class="number">30.476518897432545</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安装shapely"><a href="#安装shapely" class="headerlink" title="安装shapely"></a>安装shapely</h2><p>本测试基于python——python3.6</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install shapely</span><br></pre></td></tr></table></figure><p>windows安装shapely会报错</p><h2 id="shapely解析地理围栏"><a href="#shapely解析地理围栏" class="headerlink" title="shapely解析地理围栏"></a>shapely解析地理围栏</h2><p>话不多说直接上代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Point</span><br><span class="line"><span class="keyword">from</span> shapely.geometry.polygon <span class="keyword">import</span> Polygon</span><br><span class="line"></span><br><span class="line">point = Point(<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">polygon = Polygon([(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)])</span><br><span class="line">print(polygon.contains(point))</span><br></pre></td></tr></table></figure><p>下面是实际的实例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from shapely.geometry import Point</span><br><span class="line">from shapely.geometry.polygon import Polygon</span><br><span class="line"></span><br><span class="line">polygon_data= [</span><br><span class="line">            [</span><br><span class="line">              114.3458104133606,</span><br><span class="line">              30.476167529462785</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              114.34512376785278,</span><br><span class="line">              30.475575748963195</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              114.34576749801636,</span><br><span class="line">              30.474540124433936</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              114.3467652797699,</span><br><span class="line">              30.475363076967565</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              114.34693694114685,</span><br><span class="line">              30.476102803645833</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">              114.3458104133606,</span><br><span class="line">              30.476167529462785</span><br><span class="line">            ]</span><br><span class="line">          ]</span><br><span class="line">          </span><br><span class="line">point1 = Point([114.34605717658997,30.475584995561178])</span><br><span class="line">point2 = Point([114.346604347229,30.476518897432545])</span><br><span class="line">polygon = Polygon(polygon_data)</span><br><span class="line">print(polygon.contains(point1))</span><br><span class="line">print(polygon.contains(point2))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>这样一来我们就快速的实现了，目标点是否在地理围栏内的判断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python还是挺好用的：）</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><p><a href="https://stackoverflow.com/questions/36399381/whats-the-fastest-way-of-checking-if-a-point-is-inside-a-polygon-in-python" target="_blank" rel="noopener">https://stackoverflow.com/questions/36399381/whats-the-fastest-way-of-checking-if-a-point-is-inside-a-polygon-in-python</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django与Celery配合实现定时任务</title>
      <link href="/2018/12/12/Django%E4%B8%8ECelery%E9%85%8D%E5%90%88%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/12/12/Django%E4%B8%8ECelery%E9%85%8D%E5%90%88%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2018/12/12/Ft8aX4.png" alt="Ft8aX4.png"></p><a id="more"></a><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　Celery是一个基于python开发的分布式任务队列，而做python WEB开发最为流行的框架莫属Django，但是Django的请求处理过程都是同步的无法实现异步任务，若要实现异步任务处理需要通过其他方式（前端的一般解决方案是ajax操作），而后台Celery就是不错的选择。倘若一个用户在执行某些操作需要等待很久才返回，这大大降低了网站的吞吐量。</p><p>​    另一方面，当我们需要处理一些定时任务时Celery强大的生态环境也是他的优势。</p><p>​    在刚刚学习如何使用Celery时可能会觉得难以入手，我利用工作之余研究这些文档前前后后也花了快一个周的样子，目前已经可以满足我的需求，所以静下心多写多测试，加油。</p><h2 id="二、配置使用"><a href="#二、配置使用" class="headerlink" title="二、配置使用"></a>二、配置使用</h2><p>　　celery很容易集成到Django框架中，当然如果想要实现定时任务的话还需要安装django-celery-beta插件，后面会说明。需要注意的是Celery4.0只支持Django版本&gt;=1.8的，如果是小于1.8版本需要使用Celery3.1。</p><p>本示例使用主要依赖包如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">celery==4.2.1</span><br><span class="line">Django==1.11.7</span><br><span class="line">django-celery-beat==1.4.0</span><br><span class="line">django-celery-results==1.0.4</span><br><span class="line">PyMySQL==0.9.2</span><br><span class="line">redis==2.10.6</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>　　新建立项目<code>celery_demo</code>,目录结构（每个app下多了个tasks文件，用于定义任务）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">celery_demo</span><br><span class="line">├── app01</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── apps.py</span><br><span class="line">│   ├── migrations</span><br><span class="line">│   │   └── __init__.py</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── tasks.py</span><br><span class="line">│   └── views.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── celery_demo</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">└── templates</span><br></pre></td></tr></table></figure><p>在项目目录<code>celery_demo/celery_demo/</code>目录下新建<code>celery.py</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author:wd</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置django环境</span></span><br><span class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, <span class="string">'celery_demo.settings'</span>)  </span><br><span class="line">app = Celery(<span class="string">'celery_demo'</span>)</span><br><span class="line"><span class="comment">#  使用CELERY_ 作为前缀，在settings中写配置</span></span><br><span class="line">app.config_from_object(<span class="string">'django.conf:settings'</span>, namespace=<span class="string">'CELERY'</span>) </span><br><span class="line"><span class="comment"># 发现任务文件每个app下的task.py</span></span><br><span class="line">app.autodiscover_tasks()</span><br></pre></td></tr></table></figure><p>在<code>celery_demo/celery_demo/__init__.py</code>写入：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br><span class="line">__all__ = [<span class="string">'celery_app'</span>]</span><br></pre></td></tr></table></figure><p>在<code>celery_demo/celery_demo/settings.py</code>写入：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CELERY_BROKER_URL = <span class="string">'redis://10.1.210.69:6379/0'</span> <span class="comment"># Broker配置，使用Redis作为消息中间件</span></span><br><span class="line"></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://10.1.210.69:6379/0'</span> <span class="comment"># BACKEND配置，这里使用redis</span></span><br><span class="line"></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span> <span class="comment"># 结果序列化方案</span></span><br></pre></td></tr></table></figure><p>进入项目的<code>celery_demo</code>目录启动<code>worker</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">celery worker -A taskproj -l debug</span><br></pre></td></tr></table></figure><h3 id="定义与触发任务"><a href="#定义与触发任务" class="headerlink" title="定义与触发任务"></a>定义与触发任务</h3><p>任务定义在每个tasks文件中，<code>app01／tasks.py</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">from celery import shared_task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def mul(x, y):</span><br><span class="line">    return x * y</span><br></pre></td></tr></table></figure><p>视图中触发任务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import JsonResponse</span><br><span class="line">from app01 import tasks</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line"></span><br><span class="line">def index(request,*args,**kwargs):</span><br><span class="line">    res=tasks.add.delay(1,3)</span><br><span class="line">    #任务逻辑</span><br><span class="line">    return JsonResponse(&#123;&apos;status&apos;:&apos;successful&apos;,&apos;task_id&apos;:res.task_id&#125;)</span><br></pre></td></tr></table></figure><p>访问<a href="http://127.0.0.1:8000/index" target="_blank" rel="noopener">http://127.0.0.1:8000/index</a></p><p><img src="https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180823175922694-2037330814.png" alt="img"></p><p> 若想获取任务结果，可以通过task_id使用AsyncResult获取结果,还可以直接通过backend获取：</p><p><img src="https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180824100626480-211214086.png" alt="img"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>　　除了redis、rabbitmq能做结果存储外，还可以使用Django的orm作为结果存储，当然需要安装依赖插件，这样的好处在于我们可以直接通过django的数据查看到任务状态，同时为可以制定更多的操作，下面介绍如何使用orm作为结果存储。</p><ol><li>安装</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django-celery-results</span><br></pre></td></tr></table></figure><ol start="2"><li>配置settings.py，注册app</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...,</span><br><span class="line">    &apos;django_celery_results&apos;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="3"><li>修改backend配置，将Redis改为django-db</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CELERY_RESULT_BACKEND = &apos;redis://10.1.210.69:6379/0&apos; # BACKEND配置，这里使用redis</span><br><span class="line"></span><br><span class="line">CELERY_RESULT_BACKEND = &apos;django-db&apos;  #使用django orm 作为结果存储</span><br></pre></td></tr></table></figure><ol start="4"><li>修改数据库</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 manage.py migrate django_celery_results</span><br></pre></td></tr></table></figure><p>此时会看到数据库会多创建：</p><p><img src="https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180824101945385-924791653.png" alt="img"> 当然你有时候需要对task表进行操作，以下源码的表结构定义：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskResult</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""Task result/status."""</span></span><br><span class="line"></span><br><span class="line">    task_id = models.CharField(_(<span class="string">'task id'</span>), max_length=<span class="number">255</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    task_name = models.CharField(_(<span class="string">'task name'</span>), null=<span class="keyword">True</span>, max_length=<span class="number">255</span>)</span><br><span class="line">    task_args = models.TextField(_(<span class="string">'task arguments'</span>), null=<span class="keyword">True</span>)</span><br><span class="line">    task_kwargs = models.TextField(_(<span class="string">'task kwargs'</span>), null=<span class="keyword">True</span>)</span><br><span class="line">    status = models.CharField(_(<span class="string">'state'</span>), max_length=<span class="number">50</span>,</span><br><span class="line">                              default=states.PENDING,</span><br><span class="line">                              choices=TASK_STATE_CHOICES</span><br><span class="line">                              )</span><br><span class="line">    content_type = models.CharField(_(<span class="string">'content type'</span>), max_length=<span class="number">128</span>)</span><br><span class="line">    content_encoding = models.CharField(_(<span class="string">'content encoding'</span>), max_length=<span class="number">64</span>)</span><br><span class="line">    result = models.TextField(null=<span class="keyword">True</span>, default=<span class="keyword">None</span>, editable=<span class="keyword">False</span>)</span><br><span class="line">    date_done = models.DateTimeField(_(<span class="string">'done at'</span>), auto_now=<span class="keyword">True</span>)</span><br><span class="line">    traceback = models.TextField(_(<span class="string">'traceback'</span>), blank=<span class="keyword">True</span>, null=<span class="keyword">True</span>)</span><br><span class="line">    hidden = models.BooleanField(editable=<span class="keyword">False</span>, default=<span class="keyword">False</span>, db_index=<span class="keyword">True</span>)</span><br><span class="line">    meta = models.TextField(null=<span class="keyword">True</span>, default=<span class="keyword">None</span>, editable=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    objects = managers.TaskResultManager()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="string">"""Table information."""</span></span><br><span class="line"></span><br><span class="line">        ordering = [<span class="string">'-date_done'</span>]</span><br><span class="line"></span><br><span class="line">        verbose_name = _(<span class="string">'task result'</span>)</span><br><span class="line">        verbose_name_plural = _(<span class="string">'task results'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'task_id'</span>: self.task_id,</span><br><span class="line">            <span class="string">'task_name'</span>: self.task_name,</span><br><span class="line">            <span class="string">'task_args'</span>: self.task_args,</span><br><span class="line">            <span class="string">'task_kwargs'</span>: self.task_kwargs,</span><br><span class="line">            <span class="string">'status'</span>: self.status,</span><br><span class="line">            <span class="string">'result'</span>: self.result,</span><br><span class="line">            <span class="string">'date_done'</span>: self.date_done,</span><br><span class="line">            <span class="string">'traceback'</span>: self.traceback,</span><br><span class="line">            <span class="string">'meta'</span>: self.meta,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;Task: &#123;0.task_id&#125; (&#123;0.status&#125;)&gt;'</span>.format(self)</span><br></pre></td></tr></table></figure><h2 id="三、Django中使用定时任务"><a href="#三、Django中使用定时任务" class="headerlink" title="三、Django中使用定时任务"></a>三、Django中使用定时任务</h2><p>　　如果想要在django中使用定时任务功能同样是靠beat完成任务发送功能，当在Django中使用定时任务时，需要安装django-celery-beat插件。以下将介绍使用过程。</p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>1.beat插件安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install django-celery-beat</span><br></pre></td></tr></table></figure><p>2.注册APP</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ....   </span><br><span class="line">    &apos;django_celery_beat&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>3.数据库变更</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 manage.py migrate django_celery_beat</span><br></pre></td></tr></table></figure><p>4.分别启动woker和beta</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">celery -A proj beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler  <span class="comment">#启动beta 调度器使用数据库</span></span><br><span class="line"></span><br><span class="line">celery worker -A taskproj -l info <span class="comment">#启动woker</span></span><br></pre></td></tr></table></figure><p>5.配置admin</p><p>在<code>urls.py</code>写入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># urls.py</span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"> </span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&apos;^admin/&apos;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>6.创建用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 manage.py createsuperuser</span><br></pre></td></tr></table></figure><p>7.登录admin进行管理（地址<a href="http://127.0.0.1:8000/admin）并且还可以看到我们上次使用orm作为结果存储的表。" target="_blank" rel="noopener">http://127.0.0.1:8000/admin）并且还可以看到我们上次使用orm作为结果存储的表。</a></p><p><a href="http://127.0.0.1:8000/admin/login/?next=/admin/" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/login/?next=/admin/</a></p><p><img src="https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180824140802430-1813363210.png" alt="img"></p><p> 使用示例：</p><p><img src="https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180824142214576-1072914422.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180824142306542-76662934.png" alt="img"></p><p> 查看结果：</p><p><img src="https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180824142457980-2047538109.png" alt="img"></p><h3 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h3><p>　　django-celery-beat插件本质上是对数据库表变化检查，一旦有数据库表改变，调度器重新读取任务进行调度，所以如果想自己定制的任务页面，只需要操作beat插件的四张表就可以了。当然你还可以自己定义调度器，django-celery-beat插件已经内置了model，只需要进行导入便可进行orm操作，以下我用django reset api进行示例：</p><p><strong>settings.py</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;django.contrib.admin&apos;,</span><br><span class="line">    &apos;django.contrib.auth&apos;,</span><br><span class="line">    &apos;django.contrib.contenttypes&apos;,</span><br><span class="line">    &apos;django.contrib.sessions&apos;,</span><br><span class="line">    &apos;django.contrib.messages&apos;,</span><br><span class="line">    &apos;django.contrib.staticfiles&apos;,</span><br><span class="line">    &apos;app01.apps.App01Config&apos;,</span><br><span class="line">    &apos;django_celery_results&apos;,</span><br><span class="line">    &apos;django_celery_beat&apos;,</span><br><span class="line">    &apos;rest_framework&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>urls.py</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(r&apos;^admin/&apos;, admin.site.urls),</span><br><span class="line">    url(r&apos;^index$&apos;, views.index),</span><br><span class="line">    url(r&apos;^res$&apos;, views.get_res),</span><br><span class="line">    url(r&apos;^tasks$&apos;, views.TaskView.as_view(&#123;&apos;get&apos;:&apos;list&apos;&#125;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>views.py</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django_celery_beat.models import PeriodicTask  #倒入插件model</span><br><span class="line">from rest_framework import serializers</span><br><span class="line">from rest_framework import pagination</span><br><span class="line">from rest_framework.viewsets import ModelViewSet</span><br><span class="line">class Userserializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model = PeriodicTask</span><br><span class="line">        fields = &apos;__all__&apos;</span><br><span class="line"></span><br><span class="line">class Mypagination(pagination.PageNumberPagination):</span><br><span class="line">    &quot;&quot;&quot;自定义分页&quot;&quot;&quot;</span><br><span class="line">    page_size=2</span><br><span class="line">    page_query_param = &apos;p&apos;</span><br><span class="line">    page_size_query_param=&apos;size&apos;</span><br><span class="line">    max_page_size=4</span><br><span class="line"></span><br><span class="line">class TaskView(ModelViewSet):</span><br><span class="line">    queryset = PeriodicTask.objects.all()</span><br><span class="line">    serializer_class = Userserializer</span><br><span class="line">    permission_classes = []</span><br><span class="line">    pagination_class = Mypagination</span><br></pre></td></tr></table></figure><p>访问<a href="http://127.0.0.1:8000/tasks如下：" target="_blank" rel="noopener">http://127.0.0.1:8000/tasks如下：</a></p><p><img src="https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180824153332274-1150335891.png" alt="img"></p><p>参考资料：</p><blockquote><p>W-D：<a href="https://www.cnblogs.com/wdliu/p/9530219.html" target="_blank" rel="noopener">https://www.cnblogs.com/wdliu/p/9530219.html</a></p><p>还在琢磨：<a href="https://blog.csdn.net/mbl114/article/details/78047175" target="_blank" rel="noopener">https://blog.csdn.net/mbl114/article/details/78047175</a></p><p>Celery文档：<a href="http://docs.celeryproject.org/en/latest/" target="_blank" rel="noopener">http://docs.celeryproject.org/en/latest/</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Celery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django与Celery</title>
      <link href="/2018/12/09/Django%E4%B8%8ECelery/"/>
      <url>/2018/12/09/Django%E4%B8%8ECelery/</url>
      
        <content type="html"><![CDATA[<p>先祭上 <a href="https://github.com/celery/django-celery-beat" target="_blank" rel="noopener">https://github.com/celery/django-celery-beat</a><br><a id="more"></a></p><blockquote><p>注意：</p><p>celery4.0支持django1.8以上版本，如果1.8以下版本请使用celry3.1</p><p>另外celery4.0版本不支持windows，需要启动的时候指定下–pool=solo，下面会说明</p></blockquote><p>本文从零开始，如果已有django环境和celery环境，请忽略以下步骤</p><h1 id="VirtualEnv环境"><a href="#VirtualEnv环境" class="headerlink" title="VirtualEnv环境"></a>VirtualEnv环境</h1><p>请参照我之前的文章-<a href="https://my.oschina.net/u/914655/blog/1192590" target="_blank" rel="noopener">virtualenv环境</a></p><p>这里简单列下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\virtualenv\nowamagic_venv&gt;virtualenv proj_env1 --python=C:\Python36\python.exe</span><br><span class="line">Running virtualenv with interpreter C:\Python36\python.exe</span><br><span class="line">Using base prefix &apos;C:\\Python36&apos;</span><br><span class="line">New python executable in E:\virtualenv\nowamagic_venv\proj_env1\Scripts\python.exe</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br><span class="line"></span><br><span class="line">E:\virtualenv\nowamagic_venv&gt;cd proj_env1</span><br><span class="line"></span><br><span class="line">E:\virtualenv\nowamagic_venv\proj_env1&gt;cd Scripts</span><br><span class="line"></span><br><span class="line">E:\virtualenv\nowamagic_venv\proj_env1\Scripts&gt;activate</span><br><span class="line"></span><br><span class="line">(proj_env1) E:\virtualenv\nowamagic_venv\proj_env1\Scripts&gt;pip list</span><br><span class="line">DEPRECATION: The default format will switch to columns in the future. You can use --format=(legacy|columns) (or define a</span><br><span class="line">ection) to disable this warning.</span><br><span class="line">pip (9.0.1)</span><br><span class="line">setuptools (38.5.1)</span><br><span class="line">wheel (0.30.0)</span><br></pre></td></tr></table></figure><p>有时安装的pip版本太低，用pip安装软件时会报</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip._vendor.distlib.DistlibException: Unable to locate finder for &apos;pip._vendor.distlib&apos;</span><br></pre></td></tr></table></figure><p>这时需要卸载掉pip setuptools，重新安装下</p><ol><li><p>uninstall current pip:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m pip uninstall pip setuptools</span><br></pre></td></tr></table></figure></li><li><p>download <code>get-pip.py</code> from <a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">https://bootstrap.pypa.io/get-pip.py</a></p></li><li><p>execute get-pip script:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure></li></ol><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Django (2.0.2)</span><br><span class="line">celery (4.1.0)</span><br><span class="line">mysqlclient (1.3.12) 连接mysql客户端</span><br><span class="line">redis (2.10.6) 以redis作为后端broker</span><br></pre></td></tr></table></figure><p>安装过程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(proj_env1) E:\virtualenv\nowamagic_venv\proj_env1\Scripts&gt;pip install django</span><br><span class="line">Collecting django</span><br><span class="line">  Using cached Django-2.0.2-py3-none-any.whl</span><br><span class="line">Collecting pytz (from django)</span><br><span class="line">  Using cached pytz-2017.3-py2.py3-none-any.whl</span><br><span class="line">Installing collected packages: pytz, django</span><br><span class="line">Successfully installed django-2.0.2 pytz-2017.3</span><br><span class="line"></span><br><span class="line">(proj_env1) E:\virtualenv\nowamagic_venv\proj_env1\Scripts&gt;pip install celery</span><br><span class="line">Collecting celery</span><br><span class="line">  Using cached celery-4.1.0-py2.py3-none-any.whl</span><br><span class="line">Requirement already satisfied: pytz&gt;dev in e:\virtualenv\nowamagic_venv\proj_env1\lib\site-packages (from celery)</span><br><span class="line">Collecting billiard&lt;3.6.0,&gt;=3.5.0.2 (from celery)</span><br><span class="line">  Using cached billiard-3.5.0.3-py3-none-any.whl</span><br><span class="line">Collecting kombu&lt;5.0,&gt;=4.0.2 (from celery)</span><br><span class="line">  Using cached kombu-4.1.0-py2.py3-none-any.whl</span><br><span class="line">Collecting amqp&lt;3.0,&gt;=2.1.4 (from kombu&lt;5.0,&gt;=4.0.2-&gt;celery)</span><br><span class="line">  Using cached amqp-2.2.2-py2.py3-none-any.whl</span><br><span class="line">Collecting vine&gt;=1.1.3 (from amqp&lt;3.0,&gt;=2.1.4-&gt;kombu&lt;5.0,&gt;=4.0.2-&gt;celery)</span><br><span class="line">  Using cached vine-1.1.4-py2.py3-none-any.whl</span><br><span class="line">Installing collected packages: billiard, vine, amqp, kombu, celery</span><br><span class="line">Successfully installed amqp-2.2.2 billiard-3.5.0.3 celery-4.1.0 kombu-4.1.0 vine-1.1.4</span><br><span class="line"></span><br><span class="line">(proj_env1) E:\virtualenv\nowamagic_venv\proj_env1\Scripts&gt;pip install mysqlclient</span><br><span class="line">Collecting mysqlclient</span><br><span class="line">  Using cached mysqlclient-1.3.12-cp36-cp36m-win_amd64.whl</span><br><span class="line">Installing collected packages: mysqlclient</span><br><span class="line">Successfully installed mysqlclient-1.3.12</span><br><span class="line"></span><br><span class="line">(proj_env1) E:\virtualenv\nowamagic_venv\proj_env1\Scripts&gt;pip install redis</span><br><span class="line">Collecting redis</span><br><span class="line">  Using cached redis-2.10.6-py2.py3-none-any.whl</span><br><span class="line">Installing collected packages: redis</span><br><span class="line">Successfully installed redis-2.10.6</span><br></pre></td></tr></table></figure><h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1><h1 id="启动django项目"><a href="#启动django项目" class="headerlink" title="启动django项目"></a>启动django项目</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(proj_env1) e:\code\git\source\my&gt;django-admin startproject django_celery_beat_test</span><br></pre></td></tr></table></figure><p>现在结构如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- django_celery_beat_test/</span><br><span class="line">  - manage.py</span><br><span class="line">  - django_celery_beat_test/</span><br><span class="line">    - __init__.py</span><br><span class="line">    - settings.py</span><br><span class="line">    - urls.py</span><br><span class="line">    - wsgi.py</span><br></pre></td></tr></table></figure><h1 id="定义-Celery-实例"><a href="#定义-Celery-实例" class="headerlink" title="定义 Celery 实例"></a>定义 Celery 实例</h1><p><strong>file:</strong>  <em>django_celery_beat_test/django_celery_beat_test/celery.py</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line"># set the default Django settings module for the &apos;celery&apos; program.</span><br><span class="line">os.environ.setdefault(&apos;DJANGO_SETTINGS_MODULE&apos;, &apos;django_celery_beat_test.settings&apos;)</span><br><span class="line"></span><br><span class="line">app = Celery(&apos;django_celery_beat_test&apos;)</span><br><span class="line"></span><br><span class="line"># Using a string here means the worker doesn&apos;t have to serialize</span><br><span class="line"># the configuration object to child processes.</span><br><span class="line"># - namespace=&apos;CELERY&apos; means all celery-related configuration keys</span><br><span class="line">#   should have a `CELERY_` prefix.</span><br><span class="line">app.config_from_object(&apos;django.conf:settings&apos;, namespace=&apos;CELERY&apos;)</span><br><span class="line"></span><br><span class="line"># Load task modules from all registered Django app configs.</span><br><span class="line">app.autodiscover_tasks()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.task(bind=True)</span><br><span class="line">def debug_task(self):</span><br><span class="line">    print(&apos;Request: &#123;0!r&#125;&apos;.format(self.request))</span><br></pre></td></tr></table></figure><p>然后你需要在你的django_celery_beat_test/django_celery_beat_test/<strong> init</strong>.py模块中导入这个app。这可以确保在Django启动时加载app，以便@shared_task装饰器（稍后提及）使用它：</p><p><strong>file：</strong>  <em>django_celery_beat_test/django_celery_beat_test/<strong> init</strong>.py</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line"></span><br><span class="line"># This will make sure the app is always imported when</span><br><span class="line"># Django starts so that shared_task will use this app.</span><br><span class="line">from .celery import app as celery_app</span><br><span class="line"></span><br><span class="line">__all__ = [&apos;celery_app&apos;]</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import</span><br></pre></td></tr></table></figure><p>引入绝对导入是防止我们定义的celery.py模块与库模块celery冲突，具体作用可见<a href="http://blog.csdn.net/caiqiiqi/article/details/51050800" target="_blank" rel="noopener">这里</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app = Celery(&apos;django_celery_beat_test&apos;)</span><br></pre></td></tr></table></figure><p>这是我们celery的实例，可以有很多实例，但django里一个可能就够了 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.config_from_object(&apos;django.conf:settings&apos;, namespace=&apos;CELERY&apos;)</span><br></pre></td></tr></table></figure><p>代表celery的配置文件在django的配置文件settings里，并且定义了命名空间CELERY，也即在settings里的celery的配置都得以CELERY开头，比如broker_url需要定义为CELERY_BROKER_URL</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.autodiscover_tasks()</span><br></pre></td></tr></table></figure><p>使用上面的行，Celery会自动发现所有安装的应用程序中的任务，遵循tasks.py约定：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- app1/</span><br><span class="line">    - tasks.py</span><br><span class="line">    - models.py</span><br><span class="line">- app2/</span><br><span class="line">    - tasks.py</span><br><span class="line">    - models.py</span><br></pre></td></tr></table></figure><p>这样您就不必手动将各个模块添加到CELERY_IMPORTS设置中</p><h2 id="celery的配置"><a href="#celery的配置" class="headerlink" title="celery的配置"></a>celery的配置</h2><p>接着在settings.py中定义</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CELERY_BROKER_URL = &apos;redis://:cds-china@172.20.3.3:6379/0&apos;</span><br><span class="line"></span><br><span class="line">#: Only add pickle to this list if your broker is secured</span><br><span class="line">#: from unwanted access (see userguide/security.html)</span><br><span class="line">CELERY_ACCEPT_CONTENT = [&apos;json&apos;]</span><br><span class="line">CELERY_TASK_SERIALIZER = &apos;json&apos;</span><br><span class="line">CELERY_RESULT_SERIALIZER = &apos;json&apos;</span><br><span class="line">CELERY_RESULT_BACKEND = &apos;redis://:cds-china@172.20.3.3:6379/1&apos;</span><br></pre></td></tr></table></figure><h2 id="创建app"><a href="#创建app" class="headerlink" title="创建app"></a>创建app</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp demoapp</span><br></pre></td></tr></table></figure><p>现在结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django_celery_beat_test/</span><br><span class="line">├── demoapp</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── tasks.py</span><br><span class="line">│   ├── tests.py</span><br><span class="line">│   ├── views.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── django_celery_beat_test</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── celery.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   ├── wsgi.py</span><br><span class="line">└── test.db</span><br></pre></td></tr></table></figure><p>tasks.py内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Create your tasks here</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line"></span><br><span class="line">from celery import shared_task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def mul(x, y):</span><br><span class="line">    return x * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def xsum(numbers):</span><br><span class="line">    return sum(numbers)</span><br></pre></td></tr></table></figure><p>这里使用shared_task，其与app.task区别见<a href="https://groups.google.com/forum/#!topic/celery-users/XiSDiNjBR6k" target="_blank" rel="noopener">这里</a></p><p>在函数中调用task</p><p>views.py见下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">from django.http import HttpResponse</span><br><span class="line"># Create your views here.</span><br><span class="line">from .tasks import add</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    print(&apos;1 + 1 = ?&apos;)</span><br><span class="line">    r = add.delay(1, 1)</span><br><span class="line">    print(&apos;r.get() = %s &apos; % r.get())</span><br><span class="line">    resp = &#123;&apos;errorcode&apos;: 100, &apos;detail&apos;: &apos;Get success&apos;&#125;</span><br><span class="line">    return HttpResponse(json.dumps(resp), content_type=&quot;application/json&quot;)</span><br></pre></td></tr></table></figure><p>urls.py</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from demoapp.views import index</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    url(r&apos;^$&apos;, index, name=&apos;index&apos;),</span><br><span class="line">    # url(r&apos;^proj/&apos;, include(&apos;proj.foo.urls&apos;)),</span><br><span class="line">    path(&apos;admin/&apos;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="启动celery-worker"><a href="#启动celery-worker" class="headerlink" title="启动celery worker"></a>启动celery worker</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">celery -A django_celery_beat_test worker --pool=solo -l info</span><br><span class="line"></span><br><span class="line">(django_celery_beat_env) e:\code\git\source\my\django_celery_beat_test&gt;celery -A</span><br><span class="line"> django_celery_beat_test worker --pool=solo -l info</span><br><span class="line"></span><br><span class="line"> -------------- celery@zq-PC v4.1.0 (latentcall)</span><br><span class="line">---- **** -----</span><br><span class="line">--- * ***  * -- Windows-7-6.1.7601-SP1 2018-02-08 13:19:43</span><br><span class="line">-- * - **** ---</span><br><span class="line">- ** ---------- [config]</span><br><span class="line">- ** ---------- .&gt; app:         django_celery_beat_test:0x3974198</span><br><span class="line">- ** ---------- .&gt; transport:   redis://:**@172.20.3.3:6379/0</span><br><span class="line">- ** ---------- .&gt; results:     redis://:**@172.20.3.3:6379/1</span><br><span class="line">- *** --- * --- .&gt; concurrency: 4 (solo)</span><br><span class="line">-- ******* ---- .&gt; task events: OFF (enable -E to monitor tasks in this worker)</span><br><span class="line">--- ***** -----</span><br><span class="line"> -------------- [queues]</span><br><span class="line">                .&gt; celery           exchange=celery(direct) key=celery</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[tasks]</span><br><span class="line">  . demoapp.tasks.add</span><br><span class="line">  . demoapp.tasks.mul</span><br><span class="line">  . demoapp.tasks.xsum</span><br><span class="line">  . django_celery_beat_test.celery.debug_task</span><br></pre></td></tr></table></figure><p><strong>注意这里celery4以上的版本在window上运行时，需要加上–pool=solo，否则在执行任务时会报</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ValueError: not enough values to unpack (expected 3, got 0)</span><br></pre></td></tr></table></figure><h1 id="启动server"><a href="#启动server" class="headerlink" title="启动server"></a>启动server</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python runserver 8000</span><br></pre></td></tr></table></figure><p>浏览器访问<a href="http://127.0.0.1:8000/" target="_blank" rel="noopener">http://127.0.0.1:8000/</a></p><p>看控制台会打印结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 + 1 = ?</span><br><span class="line">[07/Feb/2018 18:37:59] &quot;GET / HTTP/1.1&quot; 200 43</span><br><span class="line">r.get() = 2</span><br></pre></td></tr></table></figure><p>表示成功</p><h1 id="django-celery-beat"><a href="#django-celery-beat" class="headerlink" title="django_celery_beat"></a>django_celery_beat</h1><p>接下来看django_celery_beat模块</p><p>上面没有说celery beat，celery beat就是一个定时模块，并且包含crontab类似功能，后面是celery worker，可以说非常强大。</p><p>默认调度程序是celery.beat.PersistentScheduler，它只是跟踪本地<a href="https://docs.python.org/dev/library/shelve.html#module-shelve" target="_blank" rel="noopener">shelve</a>数据库文件中的最后一次运行时间。</p><p>但还有一哥们写的调度程序django_celery_beat，它以数据库做为载体，定时任务之类的记录在库里，并且有web admin界面控制。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.pip安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django-celery-beat</span><br></pre></td></tr></table></figure><p>2.添加到INSTALLED_APPS</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...,</span><br><span class="line">    &apos;django_celery_beat&apos;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="3"><li>migrate安装必要的库</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(django_celery_beat_env) e:\code\git\source\my\django_celery_beat_test&gt;python ma</span><br><span class="line">nage.py migrate</span><br><span class="line">System check identified some issues:</span><br><span class="line"></span><br><span class="line">WARNINGS:</span><br><span class="line">?: (mysql.W002) MySQL Strict Mode is not set for database connection &apos;default&apos;</span><br><span class="line">        HINT: MySQL&apos;s Strict Mode fixes many data integrity problems in MySQL, s</span><br><span class="line">uch as data truncation upon insertion, by escalating warnings into errors. It is</span><br><span class="line"> strongly recommended you activate it. See: https://docs.djangoproject.com/en/2.</span><br><span class="line">0/ref/databases/#mysql-sql-mode</span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, contenttypes, django_celery_beat, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Applying contenttypes.0001_initial... OK</span><br><span class="line">  Applying auth.0001_initial... OK</span><br><span class="line">  Applying admin.0001_initial... OK</span><br><span class="line">  Applying admin.0002_logentry_remove_auto_add... OK</span><br><span class="line">  Applying contenttypes.0002_remove_content_type_name... OK</span><br><span class="line">  Applying auth.0002_alter_permission_name_max_length... OK</span><br><span class="line">  Applying auth.0003_alter_user_email_max_length... OK</span><br><span class="line">  Applying auth.0004_alter_user_username_opts... OK</span><br><span class="line">  Applying auth.0005_alter_user_last_login_null... OK</span><br><span class="line">  Applying auth.0006_require_contenttypes_0002... OK</span><br><span class="line">  Applying auth.0007_alter_validators_add_error_messages... OK</span><br><span class="line">  Applying auth.0008_alter_user_username_max_length... OK</span><br><span class="line">  Applying auth.0009_alter_user_last_name_max_length... OK</span><br><span class="line">  Applying django_celery_beat.0001_initial... OK</span><br><span class="line">  Applying django_celery_beat.0002_auto_20161118_0346... OK</span><br><span class="line">  Applying django_celery_beat.0003_auto_20161209_0049... OK</span><br><span class="line">  Applying django_celery_beat.0004_auto_20170221_0000... OK</span><br><span class="line">  Applying sessions.0001_initial... OK</span><br></pre></td></tr></table></figure><p>\4. 启动celery beat的时候指定–scheduler</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">celery -A django_celery_beat_test beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler</span><br></pre></td></tr></table></figure><h2 id="django-admin"><a href="#django-admin" class="headerlink" title="django admin"></a>django admin</h2><p>创建superuser</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(django_celery_beat_env) e:\code\git\source\my\django_celery_beat_test&gt;python ma</span><br><span class="line">nage.py createsuperuser</span><br><span class="line">Username (leave blank to use &apos;zq&apos;): admin</span><br><span class="line">Email address: zq@126.com</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure><p>登录admin <a href="http://127.0.0.1:8000/admin/" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/</a></p><p>如下：</p><p><img src="https://static.oschina.net/uploads/space/2018/0208/134004_2dyZ_914655.png" alt="img"></p><p>可添加定时，任务等。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Python开发者的收藏夹</title>
      <link href="/2018/11/25/Python%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
      <url>/2018/11/25/Python%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%94%B6%E8%97%8F%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<p>记录一些有用的网址</p><p>干货：基础python Web ，主要是django框架</p><a id="more"></a><p>（分类：编程社区）：<br><a href="https://link.zhihu.com/?target=https%3A//www.v2ex.com/" target="_blank" rel="noopener">https://www.v2ex.com/</a><br><a href="https://link.zhihu.com/?target=http%3A//www.csdn.net/%3Fref%3Dtoolbar" target="_blank" rel="noopener">CSDN.NET - 全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台</a><br><a href="https://link.zhihu.com/?target=http%3A//www.ituring.com.cn/" target="_blank" rel="noopener">图灵社区</a><br><a href="https://link.zhihu.com/?target=http%3A//segmentfault.com/" target="_blank" rel="noopener">SegmentFault</a><br><a href="https://link.zhihu.com/?target=http%3A//python-china.org/" target="_blank" rel="noopener">Python China</a><br><a href="https://link.zhihu.com/?target=http%3A//coolshell.cn/" target="_blank" rel="noopener">酷壳 – CoolShell.cn</a><br><a href="https://link.zhihu.com/?target=http%3A//ourcoders.com/home/" target="_blank" rel="noopener">OurCoders (我们程序员)</a><br><a href="https://link.zhihu.com/?target=http%3A//www.dewen.io/" target="_blank" rel="noopener">德问:编程社交问答</a><br><a href="https://link.zhihu.com/?target=http%3A//forum.memect.com/" target="_blank" rel="noopener">好东西论坛 | 好东西传送门的论坛</a><br><a href="https://link.zhihu.com/?target=http%3A//www.oschina.net/" target="_blank" rel="noopener">开源中国 - 找到您想要的开源项目，分享和交流</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/" target="_blank" rel="noopener">博客园 - 开发者的网上家园</a><br><a href="https://link.zhihu.com/?target=http%3A//www.django-china.cn/" target="_blank" rel="noopener">Django中国社区</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.jobbole.com/" target="_blank" rel="noopener">博客 - 伯乐在线</a><br><a href="https://link.zhihu.com/?target=http%3A//cocode.cc/" target="_blank" rel="noopener">CoCode</a></p><p>（分类：刷题： 另：个人见解：没有一定时间和基础的小伙伴其实没必要花大量时间刷题）<br><a href="https://link.zhihu.com/?target=https%3A//www.codecademy.com/" target="_blank" rel="noopener">Learn to code</a><br><a href="https://link.zhihu.com/?target=https%3A//leetcode.com/problemset/algorithms/" target="_blank" rel="noopener">Problems | LeetCode OJ</a><br><a href="https://link.zhihu.com/?target=http%3A//www.lintcode.com/zh-cn/problem/" target="_blank" rel="noopener">LintCode - 编程面试题在线训练平台</a><br><a href="https://link.zhihu.com/?target=http%3A//www.checkio.org/profile/login/%3Fnext%3D/station/home/" target="_blank" rel="noopener">Login:CheckiO</a></p><p>(分类：自学教程）：<br><a href="https://link.zhihu.com/?target=https%3A//github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">justjavac/free-programming-books-zh_CN · GitHub</a>   ←←←←←←←←←←看这个！！！！！<br><a href="https://link.zhihu.com/?target=http%3A//www.runoob.com/" target="_blank" rel="noopener">菜鸟教程 - 学的不仅是技术，更是梦想！</a><br><a href="https://link.zhihu.com/?target=http%3A//stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a>      神器stackoverflow，不会的百分之九十都可以在这里找到答案<br><a href="https://link.zhihu.com/?target=http%3A//www.ziqiangxuetang.com/" target="_blank" rel="noopener">自强学堂 - 在线教程</a>自强学堂<br><a href="https://link.zhihu.com/?target=http%3A//www.maiziedu.com/" target="_blank" rel="noopener">麦子学院 - 专业IT职业在线教育平台</a> 麦子学院，可能是现阶段网上最详细的python web 系列教程，里面有的老师讲的特别好，特别适合完全没基础的小伙伴，但是东西虽多，有些内容精度还需努力，还有很多课程也没有录制完毕 ，不过情况正常逐渐改善<br><a href="https://link.zhihu.com/?target=http%3A//www.imooc.com/" target="_blank" rel="noopener">慕课网-国内最大的IT技能学习平台</a> 慕课网  有廖雪峰前辈的python入门和进阶<br><a href="https://link.zhihu.com/?target=https%3A//www.shiyanlou.com/" target="_blank" rel="noopener">实验楼 - 第一家以实验为核心的IT在线教育平台</a>  有独有的虚拟环境，有python工程师的完整学习路线<br><a href="https://link.zhihu.com/?target=http%3A//www.jikexueyuan.com/" target="_blank" rel="noopener">http://www.jikexueyuan.com/</a>  极客学院 有免费的会员自己找<br><a href="https://link.zhihu.com/?target=http%3A//python.usyiyi.cn/" target="_blank" rel="noopener">Python 官方文档中文站</a>      很好的官方文档，库，django1.8.2的资料，很多人自发翻译 ，也希望有更多人能够顺手一翻，利人利己<br><a href="https://link.zhihu.com/?target=http%3A//www.liaoxuefeng.com/" target="_blank" rel="noopener">Home - 廖雪峰的官方网站</a>      廖雪峰前辈的python2和3入门,git入门都很不错，并且还有前端js教学<br><a href="https://link.zhihu.com/?target=http%3A//www.itdiffer.com/" target="_blank" rel="noopener">I am Qiwsir</a>     老齐前辈的python入门，讲的特别详细，web方向使用Tornado框架，在自学路上受到过本人帮助，并且工作也算是靠他帮忙才找到，有幸见过本人并受到了生活上的帮助和建议，不论在生活中还是工作中，真是一个非常谦和的长辈，非常非常感激他<br><a href="https://link.zhihu.com/?target=http%3A//www.nowamagic.net/" target="_blank" rel="noopener">简明现代魔法 —— 专注于互联网主流的各种技术</a> 简明现代魔法</p><p>（分类：英文自学网站）<br><a href="https://link.zhihu.com/?target=https%3A//www.udacity.com/" target="_blank" rel="noopener">https://www.udacity.com/</a><br><a href="https://link.zhihu.com/?target=https%3A//www.edx.org/" target="_blank" rel="noopener">edX | Free online courses from the world’s best universities</a><br><a href="https://link.zhihu.com/?target=http%3A//www.ibm.com/developerworks/" target="_blank" rel="noopener">IBM developerWorks : IBM’s resource for developers and IT professionals</a><br><a href="https://link.zhihu.com/?target=https%3A//www.coursera.org/" target="_blank" rel="noopener">Coursera - Free Online Courses From Top Universities</a><br><a href="https://link.zhihu.com/?target=http%3A//hackerxu.com/Twd/" target="_blank" rel="noopener">Tango with Django 中文文档</a>     tango_with_django_book<br><a href="https://link.zhihu.com/?target=http%3A//c.biancheng.net/cpp/html/1402.html" target="_blank" rel="noopener">如何使用本教程</a> 正则表达式入门，今天无意中翻到的，看起来还可以，还有个csdn的正则表达式网页，等在电脑上找到再发<br><a href="https://link.zhihu.com/?target=http%3A//danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="noopener">git-flow 备忘清单</a>   git flow备忘清单 </p><p>(分类：招聘网站）<br><a href="https://link.zhihu.com/?target=http%3A//www.lagou.com/" target="_blank" rel="noopener">拉勾网-最专业的互联网招聘平台</a><br><a href="https://link.zhihu.com/?target=http%3A//www.jobtong.com/" target="_blank" rel="noopener">周伯通招聘-最靠谱的移动互联网招聘社区</a><br><a href="https://link.zhihu.com/?target=http%3A//www.100offer.com/" target="_blank" rel="noopener">100offer-高端人才招聘网站</a><br><a href="https://link.zhihu.com/?target=http%3A//www.histarter.com/" target="_blank" rel="noopener">http://www.histarter.com/</a></p><p>（分类：文章）：<br><a href="https://link.zhihu.com/?target=https%3A//www.zybuluo.com/UniNova/note/96735" target="_blank" rel="noopener">留彼Python阅读清单</a><br><a href="https://link.zhihu.com/?target=http%3A//coolshell.cn/articles/4990.html" target="_blank" rel="noopener">程序员技术练级攻略</a> 耗子哥写的，推荐看看<br><a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMjM5MjUwNzIyMA%3D%3D%26mid%3D400060668%26idx%3D1%26sn%3D9064cf2be8b99bdfb0fdf9eba157eaf6%26scene%3D23%26srcid%3D1023T4YvC6lwNJPXA5YRCfoA%23rd" target="_blank" rel="noopener">我前妻的故事（一个初中肄业生的奋斗）</a>    推荐大家看看，tinyfool 前辈前妻的职场故事<br><a href="https://link.zhihu.com/?target=http%3A//www.wklken.me/posts/2013/12/21/python-jd.html" target="_blank" rel="noopener">Python招聘需求与技能体系</a> 今天偶然看到的python的技能需求与发展方向，特别详细，并且一直保持更新状态，有兴趣的也可以去看看他归档里的一些心情，工作状态总结，可以看到成长的轨迹<br><a href="https://link.zhihu.com/?target=http%3A//www.acfun.tv/v/ac2300100" target="_blank" rel="noopener">一路走来打工十年（上·中）未完待续</a><br><a href="https://link.zhihu.com/?target=http%3A//www.acfun.tv/a/ac2304009" target="_blank" rel="noopener">一路走来 打工十年·完</a>  A站文章<br><a href="https://link.zhihu.com/?target=http%3A//www.acfun.tv/a/ac2312212" target="_blank" rel="noopener">【工作】如何成为一名程序员</a></p><p>（分类：零碎资料）：<br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/fnng/p/3157639.html" target="_blank" rel="noopener">「UI 测试自动化selenium」汇总</a><br><a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a><br><a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMjM5NjA0NjgyMA%3D%3D%26mid%3D206271329%26idx%3D1%26sn%3Da5c3adf9c534d2cbf08f34e96a856a6e%26scene%3D2%26from%3Dtimeline%26isappinstalled%3D0%23wechat_redirect" target="_blank" rel="noopener">为什么成为一名程序员这么难？</a><br><a href="https://link.zhihu.com/?target=http%3A//python-cn.org/%23/" target="_blank" rel="noopener">Python-cn Guide</a><br><a href="https://link.zhihu.com/?target=http%3A//www.tuicool.com/articles/eaERjyU" target="_blank" rel="noopener">Django 1.6 最佳实践: 如何正确使用 CBVs (Class-based views)</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.jobbole.com/74881/" target="_blank" rel="noopener">实例详解Django的 select_related 和 prefetch_related 函数对 QuerySet 查询的优化（一）</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.jobbole.com/74914/" target="_blank" rel="noopener">实例详解Django的 select_related 和 prefetch_related 函数对 QuerySet 查询的优化（二）</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.jobbole.com/75435/" target="_blank" rel="noopener">实例详解Django的 select_related 和 prefetch_related 函数对 QuerySet 查询的优化（三）</a><br><a href="https://link.zhihu.com/?target=https%3A//ccbv.co.uk/" target="_blank" rel="noopener">https://ccbv.co.uk/</a><br><a href="https://link.zhihu.com/?target=http%3A//www.crifan.com/summary_the_meaning_of_self_and___init___in_python_and_why_need_them/" target="_blank" rel="noopener">【整理】Python中：self和<strong>init</strong>的含义 + 为何要有self和<strong>init</strong></a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/lhj588/archive/2012/05/24/2516040.html" target="_blank" rel="noopener">Django model字段类型清单</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/ponder008/article/details/6880400" target="_blank" rel="noopener">观察者模式（python版）</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/column/details/why-bug.html" target="_blank" rel="noopener">专栏：Python爬虫入门教程</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/smilelance/article/details/6529950" target="_blank" rel="noopener">Python 正则表达式（模式匹配）</a><br><a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/link%3Furl%3D754jn0cN6vzF-wPzl2zhcdyc-LvIb_itiQWVHb53Mr8zW5x114e3eTpUYyNEbmuWalfBoa7yhWbvbFJW5cy9Y0OZZlliaejBGYOsUGyNJbLMnLhhHQypTfTwNCwQu4RAbbwiw-5gqoumRRXB1AaD9q%233" target="_blank" rel="noopener">命令提示符_百度百科</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html" target="_blank" rel="noopener">Mysql命令大全</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.163.com/qj_l12%40126/blog/static/359308262008111624447196/" target="_blank" rel="noopener">http://blog.163.com/qj_l12@126/blog/static/359308262008111624447196/</a><br>mysql 中alter语句中change和modify的区别<br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/forphp/p/3444652.html" target="_blank" rel="noopener">group by - long896130895</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.renren.com/share/221734963/7835750512" target="_blank" rel="noopener">Django 数据库的操作</a><br><a href="https://link.zhihu.com/?target=http%3A//www.nanerbang.com/article/33/" target="_blank" rel="noopener">Django：如何admin管理界面中显示中文model名称<em>django</em>男儿邦</a><br><a href="https://link.zhihu.com/?target=http%3A//www.weiguda.com/blog/8/" target="_blank" rel="noopener">Django 1.6 最佳实践: 如何正确的使用和设置Database和Model</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/ab198604/article/details/12655765" target="_blank" rel="noopener">models数据模型学习笔记</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/zhangxinrun/article/details/8095118" target="_blank" rel="noopener">Django模板系统(非常详细)</a><br><a href="https://link.zhihu.com/?target=http%3A//lishiguang.iteye.com/blog/1328982" target="_blank" rel="noopener">通过django的meta类来修改自动后台显示的模块名称</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/gideal_wang/article/details/4316691" target="_blank" rel="noopener">HTTP POST GET 本质区别详解</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/parrot18/article/details/8617405" target="_blank" rel="noopener">Django中的request.GET和request.POST</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/whoami021/article/details/20876685%3Futm_source%3Dtuicool" target="_blank" rel="noopener">django表单处理（一）–最简单的表单</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/whoami021/article/details/20876965" target="_blank" rel="noopener">django表单处理（二）–数据验证</a><br><a href="https://link.zhihu.com/?target=http%3A//www.douban.com/note/296298497/" target="_blank" rel="noopener">django form关于clean及cleaned_data的说明 以及4种初始化</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/holbrook/archive/2012/02/09/2357348.html" target="_blank" rel="noopener">Django实战（20）：分页（Pagination)</a><br><a href="https://link.zhihu.com/?target=http%3A//www.nowamagic.net/academy/detail/1318909" target="_blank" rel="noopener">request.META里包含了哪些数据？ – 简明现代魔法</a><br><a href="https://link.zhihu.com/?target=http%3A//www.nowamagic.net/academy/detail/13281830" target="_blank" rel="noopener">Django中的request与response对象 – 简明现代魔法</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/fengmk2/archive/2008/04/21/1163766.html" target="_blank" rel="noopener">Python tips: 什么是*args和**kwargs？</a><br><a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/link%3Furl%3DSNdh8mZCqtI4gXpEuggnkT0SNqyJbixJCBsMU_5cV-mAkkxlg90wez79--ktR3vRsz6BoxiIT95u3e6Cx8Vt4q" target="_blank" rel="noopener">类和对象_百度百科</a><br><a href="https://link.zhihu.com/?target=http%3A//www.360doc.com/content/12/1012/21/7662927_241124973.shtml" target="_blank" rel="noopener">总结整理时下流行的浏览器User-Agent大全</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/FeiSan/article/details/1729905" target="_blank" rel="noopener">Python中函数的参数定义和可变参数</a><br><a href="https://link.zhihu.com/?target=http%3A//www.upour.com/2012/02/python-2-items-iteritems-get-set/" target="_blank" rel="noopener">items()和iteritems()区别和使用，字典的get()函数也不错</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/suibianshen2012/article/details/41451287" target="_blank" rel="noopener">Python3字典中items()和python2.x中iteritems()有什么区别</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/huangcong/archive/2011/08/29/2158268.html" target="_blank" rel="noopener">黄聪：Python 字符串操作（string替换、删除、截取、复制、连接、比较、查找、包含、大小写转换、分割等）</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/facevoid/article/details/5338048" target="_blank" rel="noopener">Python 列表(list)操作</a><br><a href="https://link.zhihu.com/?target=http%3A//pnig0s1992.blog.51cto.com/393390/369164/" target="_blank" rel="noopener">python中string的操作函数</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/btchenguang/archive/2012/09/01/2666763.html" target="_blank" rel="noopener">(9)Django框架学习-Templates进阶用法–上</a><br><a href="https://link.zhihu.com/?target=http%3A//www.yihaomen.com/article/python/324.htm" target="_blank" rel="noopener">django 程序ajax提交的方法,避免csrf错误</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/shuifa2008/article/details/8679272" target="_blank" rel="noopener">django CSRF protect （防止出现Forbidden 403）</a><br><a href="https://link.zhihu.com/?target=http%3A//zhidao.baidu.com/link%3Furl%3DN_gh6U_iJ1K6KL_p5EM985BQ925uerpwlX3VpMXicjWffekT1wwybNA-78RZE1dTP_nHiIsVDeVNAn22N5nrKq" target="_blank" rel="noopener">求Django常用语法，接受get和post参数的方法</a><br><a href="https://link.zhihu.com/?target=http%3A//blog.chinaunix.net/uid-21633169-id-4332621.html" target="_blank" rel="noopener">Django中request和response中的属性方法详述</a><br><a href="https://link.zhihu.com/?target=http%3A//www.ttlsa.com/python/how-to-install-and-use-pip-ttlsa/" target="_blank" rel="noopener">pip 安装使用详解</a><br><a href="https://link.zhihu.com/?target=http%3A//python.jobbole.com/81312/" target="_blank" rel="noopener">将Sublime Text 3设置为Python全栈开发环境</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/tk091/p/3700013.html" target="_blank" rel="noopener">virtualenv – python虚拟沙盒</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnsecer.com/7896.html" target="_blank" rel="noopener">再来一发很漂亮的sublime text3主题</a><br><a href="https://link.zhihu.com/?target=http%3A//python.jobbole.com/81312/" target="_blank" rel="noopener">将Sublime Text 3设置为Python全栈开发环境</a><br><a href="https://link.zhihu.com/?target=http%3A//segmentfault.com/a/1190000002596724" target="_blank" rel="noopener">Sublime Text3</a><br>(未完)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django部署手册</title>
      <link href="/2018/11/25/Django%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/"/>
      <url>/2018/11/25/Django%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-安装python环境"><a href="#一、-安装python环境" class="headerlink" title="一、 安装python环境"></a>一、 安装python环境</h2><p>详情参考我的这一篇博文：</p><a id="more"></a><p><a href="https://hyyc554.github.io/2018/10/26/pythonenv/">Python虚拟环境配置</a></p><h2 id="二、Django的配置"><a href="#二、Django的配置" class="headerlink" title="二、Django的配置"></a>二、Django的配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install Django</span><br><span class="line">django-admin.py startproject mysite</span><br><span class="line"><span class="built_in">cd</span> mysite</span><br></pre></td></tr></table></figure><p>我将在mysite目录下完成后续相关操作</p><h2 id="二、uWSGI的安装"><a href="#二、uWSGI的安装" class="headerlink" title="二、uWSGI的安装"></a>二、uWSGI的安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install uwsgi</span><br></pre></td></tr></table></figure><h3 id="1-基础测试："><a href="#1-基础测试：" class="headerlink" title="1. 基础测试："></a>1. 基础测试：</h3><ol><li>创建一个在mysite下创建一个<code>test.py</code>的测试文档</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(dj11.7) [root@localhost ~]<span class="comment"># mkdir myporject</span></span><br><span class="line">(dj11.7) [root@localhost ~]<span class="comment"># cd myporject/</span></span><br><span class="line">(dj11.7) [root@localhost myporject]<span class="comment"># django-admin startproject mysite</span></span><br><span class="line">(dj11.7) [root@localhost myporject]<span class="comment"># cd mysite</span></span><br><span class="line">(dj11.7) [root@localhost mysite]<span class="comment"># ls</span></span><br><span class="line">manage.py  mysite</span><br><span class="line">(dj11.7) [root@localhost mysite]<span class="comment"># touch test.py</span></span><br><span class="line">(dj11.7) [root@localhost mysite]<span class="comment"># ls</span></span><br><span class="line">manage.py  mysite  test.py</span><br></pre></td></tr></table></figure><p>​    以上就完成了测试脚本文件的构建</p><ol><li>在<code>test.py</code>中写入以下测试内容:</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(env, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b"Hello World"</span>] <span class="comment"># python3</span></span><br><span class="line">    <span class="comment">#return ["Hello World"] # python2</span></span><br></pre></td></tr></table></figure><ol><li>uWSGI运行:</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --http :8000 --wsgi-file test.py</span><br></pre></td></tr></table></figure><p>​    选项的意思是:</p><ul><li><code>http :8000</code>:使用协议http端口8000</li><li><code>wsgi-file test.py</code>:test.py加载指定的文件</li></ul><ol><li>浏览器访问你的IP加端口8000。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://yourIP:8000</span><br></pre></td></tr></table></figure><p>​    返回结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><p>如果是这样,这意味着以下工作原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the web client &lt;-&gt; uWSGI &lt;-&gt; Python</span><br></pre></td></tr></table></figure><h3 id="2-测试Django项目"><a href="#2-测试Django项目" class="headerlink" title="2. 测试Django项目"></a>2. 测试Django项目</h3><p>现在我们希望uWSGI做同样的事情,但运行Django网站而不是 <code>test.py</code>模块。</p><p>如果您还没有这样做,确保你的 <code>mysite</code>项目实际工作原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure><p>如果这工作,运行它使用uWSGI:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --http :8000 --module mysite.wsgi</span><br></pre></td></tr></table></figure><ul><li><code>模块 mysite.wsgi</code>:加载指定wsgi模块</li></ul><p>您的浏览器指向服务器; 如果网站出现,这意味着uWSGI能够，大概的页面如下</p><p><img src="https://s1.ax1x.com/2018/11/25/Fk8F61.png" alt="Fk8F61.png"></p><p>这个栈操作 正确:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the web client &lt;-&gt; uWSGI &lt;-&gt; Django</span><br></pre></td></tr></table></figure><p>现在我们通常不会有浏览器直接向uWSGI说话。 这是一份工作 的网络服务器,它将充当中间人。</p><p>nginx。。。待续  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于HTTP协议的总结</title>
      <link href="/2018/11/23/%E5%85%B3%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/23/%E5%85%B3%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h1><ul><li>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</li></ul><a id="more"></a><ul><li>HTTP是一个基于<strong>TCP/IP通信协议</strong>来传递数据（HTML 文件, 图片文件, 查询结果等）。</li><li>HTTP是一个属于<strong>应用层的面向对象的协议</strong>，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</li><li>HTTP协议工作于<strong>客户端-服务端架构</strong>为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</li></ul><p><img src="https://s1.ax1x.com/2018/11/23/FiWzx1.jpg" alt="FiWzx1.jpg"></p><h1 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h1><ol><li><p>简单快速：</p><p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p></li><li><p>灵活：</p><p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p></li><li><p>无连接：</p><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p></li><li><p>无状态：</p><p>HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p></li><li><p>支持B/S及C/S模式。</p></li></ol><h1 id="HTTP之URL"><a href="#HTTP之URL" class="headerlink" title="HTTP之URL"></a>HTTP之URL</h1><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p><p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</span><br></pre></td></tr></table></figure><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ol><li><p><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p></li><li><p><strong>域名部分</strong>：该URL的域名部分为“<a href="http://www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用" target="_blank" rel="noopener">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></p></li><li><p><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p></li><li><p><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p></li><li><p><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p></li><li><p><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p></li><li><p><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p></li></ol><p>（原文：<a href="http://blog.csdn.net/ergouge/article/details/8185219" target="_blank" rel="noopener">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</p><h1 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h1><h5 id="URI，是uniform-resource-identifier，统一资源标识符，用来唯一的标识一个资源。"><a href="#URI，是uniform-resource-identifier，统一资源标识符，用来唯一的标识一个资源。" class="headerlink" title="URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。"></a>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</h5><p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p><h5 id="URL是uniform-resource-locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。"><a href="#URL是uniform-resource-locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。" class="headerlink" title="URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。"></a>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</h5><p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</p><h5 id="URN，uniform-resource-name，统一资源命名，是通过名字来标识资源，比如mailto-java-net-java-sun-com。"><a href="#URN，uniform-resource-name，统一资源命名，是通过名字来标识资源，比如mailto-java-net-java-sun-com。" class="headerlink" title="URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。"></a>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:<a href="mailto:java-net@java.sun.com" target="_blank" rel="noopener">java-net@java.sun.com</a>。</h5><p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p><p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p><h1 id="HTTP之请求消息Request"><a href="#HTTP之请求消息Request" class="headerlink" title="HTTP之请求消息Request"></a>HTTP之请求消息Request</h1><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p><ol><li>请求行（request line）</li><li>请求头部（header）</li><li>空行</li><li>请求数据</li></ol><p><img src="https://s1.ax1x.com/2018/11/23/FiWx2R.png" alt="FiWx2R.png"></p><ul><li>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</li></ul><h5 id="Get请求例子，使用Charles抓取的request："><a href="#Get请求例子，使用Charles抓取的request：" class="headerlink" title="Get请求例子，使用Charles抓取的request："></a>Get请求例子，使用Charles抓取的request：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br></pre></td></tr></table></figure><h5 id="第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本"><a href="#第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本" class="headerlink" title="第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本."></a>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</h5><p>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p><h5 id="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"><a href="#第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息" class="headerlink" title="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"></a>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</h5><p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p><h5 id="第三部分：空行，请求头部后面的空行是必须的"><a href="#第三部分：空行，请求头部后面的空行是必须的" class="headerlink" title="第三部分：空行，请求头部后面的空行是必须的"></a>第三部分：空行，请求头部后面的空行是必须的</h5><p>即使第四部分的请求数据为空，也必须有空行。</p><h5 id="第四部分：请求数据也叫主体，可以添加任意的其他数据。"><a href="#第四部分：请求数据也叫主体，可以添加任意的其他数据。" class="headerlink" title="第四部分：请求数据也叫主体，可以添加任意的其他数据。"></a>第四部分：请求数据也叫主体，可以添加任意的其他数据。</h5><p>这个例子的请求数据为空。</p><h5 id="POST请求例子，使用Charles抓取的request："><a href="#POST请求例子，使用Charles抓取的request：" class="headerlink" title="POST请求例子，使用Charles抓取的request："></a>POST请求例子，使用Charles抓取的request：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure><p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p><h1 id="HTTP之响应消息Response"><a href="#HTTP之响应消息Response" class="headerlink" title="HTTP之响应消息Response"></a>HTTP之响应消息Response</h1><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p><h5 id="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"><a href="#HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。" class="headerlink" title="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"></a>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</h5><p><img src="https://s1.ax1x.com/2018/11/23/FifpKx.jpg" alt="FifpKx.jpg"></p><p>http响应消息格式.jpg</p><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 id="第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。"><a href="#第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。" class="headerlink" title="第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。"></a>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</h5><p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p><h5 id="第二部分：消息报头，用来说明客户端要使用的一些附加信息"><a href="#第二部分：消息报头，用来说明客户端要使用的一些附加信息" class="headerlink" title="第二部分：消息报头，用来说明客户端要使用的一些附加信息"></a>第二部分：消息报头，用来说明客户端要使用的一些附加信息</h5><p>第二行和第三行为消息报头，<br>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p><h5 id="第三部分：空行，消息报头后面的空行是必须的"><a href="#第三部分：空行，消息报头后面的空行是必须的" class="headerlink" title="第三部分：空行，消息报头后面的空行是必须的"></a>第三部分：空行，消息报头后面的空行是必须的</h5><h5 id="第四部分：响应正文，服务器返回给客户端的文本信息。"><a href="#第四部分：响应正文，服务器返回给客户端的文本信息。" class="headerlink" title="第四部分：响应正文，服务器返回给客户端的文本信息。"></a>第四部分：响应正文，服务器返回给客户端的文本信息。</h5><p>空行后面的html部分为响应正文。</p><h1 id="HTTP之状态码"><a href="#HTTP之状态码" class="headerlink" title="HTTP之状态码"></a>HTTP之状态码</h1><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><h6 id="1xx：指示信息–表示请求已接收，继续处理"><a href="#1xx：指示信息–表示请求已接收，继续处理" class="headerlink" title="1xx：指示信息–表示请求已接收，继续处理"></a>1xx：指示信息–表示请求已接收，继续处理</h6><h6 id="2xx：成功–表示请求已被成功接收、理解、接受"><a href="#2xx：成功–表示请求已被成功接收、理解、接受" class="headerlink" title="2xx：成功–表示请求已被成功接收、理解、接受"></a>2xx：成功–表示请求已被成功接收、理解、接受</h6><h6 id="3xx：重定向–要完成请求必须进行更进一步的操作"><a href="#3xx：重定向–要完成请求必须进行更进一步的操作" class="headerlink" title="3xx：重定向–要完成请求必须进行更进一步的操作"></a>3xx：重定向–要完成请求必须进行更进一步的操作</h6><h6 id="4xx：客户端错误–请求有语法错误或请求无法实现"><a href="#4xx：客户端错误–请求有语法错误或请求无法实现" class="headerlink" title="4xx：客户端错误–请求有语法错误或请求无法实现"></a>4xx：客户端错误–请求有语法错误或请求无法实现</h6><h6 id="5xx：服务器端错误–服务器未能实现合法的请求"><a href="#5xx：服务器端错误–服务器未能实现合法的请求" class="headerlink" title="5xx：服务器端错误–服务器未能实现合法的请求"></a>5xx：服务器端错误–服务器未能实现合法的请求</h6><p>常见状态码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200 OK                        //客户端请求成功</span><br><span class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><p>更多状态码<a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-status-codes.html</a></p><h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET     请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</span><br><span class="line">PUT     从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE      请求服务器删除指定的页面。</span><br><span class="line">CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS     允许客户端查看服务器的性能。</span><br><span class="line">TRACE     回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure><h1 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求/响应的步骤：</p><h6 id="1、客户端连接到Web服务器"><a href="#1、客户端连接到Web服务器" class="headerlink" title="1、客户端连接到Web服务器"></a>1、客户端连接到Web服务器</h6><p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn./" target="_blank" rel="noopener">http://www.oakcms.cn。</a></p><h6 id="2、发送HTTP请求"><a href="#2、发送HTTP请求" class="headerlink" title="2、发送HTTP请求"></a>2、发送HTTP请求</h6><p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><h6 id="3、服务器接受请求并返回HTTP响应"><a href="#3、服务器接受请求并返回HTTP响应" class="headerlink" title="3、服务器接受请求并返回HTTP响应"></a>3、服务器接受请求并返回HTTP响应</h6><p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><h6 id="4、释放连接TCP连接"><a href="#4、释放连接TCP连接" class="headerlink" title="4、释放连接TCP连接"></a>4、释放连接<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a></h6><p>若connection 模式为close，则服务器主动关闭<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>，客户端被动关闭连接，释放<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><h6 id="5、客户端浏览器解析HTML内容"><a href="#5、客户端浏览器解析HTML内容" class="headerlink" title="5、客户端浏览器解析HTML内容"></a>5、客户端浏览器解析HTML内容</h6><p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p><p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>;</p><p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 <a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP 三次握手</a>的第三个报文的数据发送给服务器;</p><p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p><p>5、释放 <a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>;</p><p>6、浏览器将该 html 文本并显示内容; 　　</p><h1 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h1><h6 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /books/?sex=man&amp;name=Professional HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>注意最后一行是空行</p><h6 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure><p>1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p><p>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</p><h6 id="因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变"><a href="#因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变" class="headerlink" title="因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变"></a>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</h6><p>2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</p><p>而在实际开发中存在的限制主要有：</p><p><strong>GET</strong>:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</p><p>因此对于GET提交时，传输数据就会受到URL长度的 限制。</p><p><strong>POST</strong>:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p><p>3、安全性</p><p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p><p>4、Http get,post,soap协议都是在http上运行的</p><p>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p><p>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p><p>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p><p>我们看看GET和POST的区别</p><ol><li><ol><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li></ol></li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>原文链接：</p><blockquote><p><a href="https://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">关于HTTP协议，一篇就够了</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>定位服务公司面试复盘</title>
      <link href="/2018/11/23/%E5%AE%9A%E4%BD%8D%E6%9C%8D%E5%8A%A1%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/2018/11/23/%E5%AE%9A%E4%BD%8D%E6%9C%8D%E5%8A%A1%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>记录一下面试的细节，不断提升自己吧</p><p>本次没有笔试</p><a id="more"></a><hr><h3 id="公司背景："><a href="#公司背景：" class="headerlink" title="公司背景："></a>公司背景：</h3><ul><li>一家创业公司规模在100人的样子</li><li>做定位服务</li></ul><h3 id="招聘要求："><a href="#招聘要求：" class="headerlink" title="招聘要求："></a>招聘要求：</h3><ul><li>独立完成Python后台开发，</li><li>人员定位数据的统计，报表，考勤等等</li></ul><h3 id="面试流程："><a href="#面试流程：" class="headerlink" title="面试流程："></a>面试流程：</h3><ul><li>我提前15分钟到了公司</li><li>前台那里稍微等了一会（果然前面还有一个人在面试）</li><li>提问<ul><li>自我介绍——我的回答还是太简短，没有体现出自己的优势</li><li>项目相关的问题<ul><li>生物技术指导是如何实现的</li><li>具体负责什么模块</li><li>前后端都会吗</li></ul></li><li>介绍了一下他们公司目前要开发的项目<ul><li>已经有了一个java平台</li><li>由于当初是找别人做的，前后端没分离，后期维护异常困难</li><li>需要用python重构</li><li>大概3个月项目要上线</li><li>准备找一个前端一个python后端来做这个</li></ul></li><li>交流了很多项目细节，以及我的想法</li><li>也谈了预期薪资，上班的时间，休假情况</li><li>周五面试，周一人事会给结果</li></ul></li></ul><h3 id="面试的不足之处："><a href="#面试的不足之处：" class="headerlink" title="面试的不足之处："></a>面试的不足之处：</h3><ul><li>没有抓住自己有前后端项目经验的优势</li><li>当谈到需要独立开发、三个月内上线业务时表现出了迟疑，显得没有自信</li><li>其实面试官也不懂Python，没有表现出自己的专业性</li><li>没有表现出自己对这个职位的热情</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>学历来说，我应该是所有面试者中具有优势的</p><p>还是自信问题，一定要自信</p><p>面试问来问去还是这些问题，加强HTTP协议、rest的理解</p><p>拓宽知识面，前端也要好好看看</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django面试总结</title>
      <link href="/2018/11/22/Django%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/22/Django%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>自己整理的一些面试题，持续更新中。。。</p><a id="more"></a><h2 id="django、flask、tornado框架的比较？"><a href="#django、flask、tornado框架的比较？" class="headerlink" title="django、flask、tornado框架的比较？"></a>django、flask、tornado框架的比较？</h2><p>django：<br>优点：最全能的web开发框架，各种功能完备，可维护性高，开发速度快<br>缺点：django orm 跟数据库的交互，django同步特性导致吞吐量小的问题可以通过celery解决</p><p>tornado：<br>优点：天生异步，性能强悍<br>缺点：框架提供的功能比较少，需要自己实现，这样导致了开发速度偏慢</p><p>flask：<br>优点：自由、灵活，扩展性强，第三方库的选择面广<br>缺点：但是对程序员要求更高</p><hr><h2 id="什么是wsgi？"><a href="#什么是wsgi？" class="headerlink" title="什么是wsgi？"></a>什么是wsgi？</h2><p><a href="https://www.jianshu.com/p/679dee0a4193" target="_blank" rel="noopener">https://www.jianshu.com/p/679dee0a4193</a></p><p>WSGI，描述web server如何与web application通信的一种规范</p><p>WSGI协议主要包括server和application两部分：</p><p>WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端；<br>WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。</p><p>application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。</p><hr><h2 id="django请求的生命周期？"><a href="#django请求的生命周期？" class="headerlink" title="django请求的生命周期？"></a>django请求的生命周期？</h2><p>Django的请求生命周期是指当用户在浏览器上输入url到用户看到网页的这个时间段内,Django后台所发生的事情</p><p>而Django的生命周期内到底发生了什么呢??</p><ol><li>当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端<br>请求头和请求体中会包含浏览器的动作(action),这个动作通常为get或者post,体现在url之中.</li><li>url经过Django中的wsgi,再经过Django的中间件,最后url到过路由映射表,在路由中一条一条进行匹配,<br>一旦其中一条匹配成功就执行对应的视图函数,后面的路由就不再继续匹配了.</li><li>视图函数根据客户端的请求查询相应的数据.返回给Django,然后Django把客户端想要的数据做为一个字符串返回给客户端.</li><li>客户端浏览器接收到返回的数据,经过渲染后显示给用户.</li></ol><hr><h2 id="列举django的内置组件"><a href="#列举django的内置组件" class="headerlink" title="列举django的内置组件"></a>列举django的内置组件</h2><ul><li>认证组件</li><li>缓存</li><li>日志</li><li>邮件</li><li>分页</li><li>静态文件管理</li><li>资讯聚合</li><li>消息框架</li><li>数据验证</li></ul><hr><h2 id="列举django中间件的5个方法？以及django中间件的应用场景？"><a href="#列举django中间件的5个方法？以及django中间件的应用场景？" class="headerlink" title="列举django中间件的5个方法？以及django中间件的应用场景？"></a>列举django中间件的5个方法？以及django中间件的应用场景？</h2><ol><li><p>在django中，中间件其实就是一个类，在请求到来和结束后，django会根据自己的规则在合适的时机执行中间件中相应的方法</p><p>在django项目的settings模块中，有一个 MIDDLEWARE_CLASSES 变量，其中每一个元素就是一个中间件</p><p>默认的中间件有哪些</p><p>中间件中可以定义五个方法，分别是：</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法在请求到来的时候调用</span></span><br><span class="line">process_request(self,request)</span><br><span class="line"><span class="comment"># 在本次将要执行的View函数被调用前调用本函数</span></span><br><span class="line">process_view(self, request, callback, callback_args, callback_kwargs)</span><br><span class="line"><span class="comment"># 需使用render()方法才会执行process_template_response</span></span><br><span class="line">process_template_response(self,request,response)</span><br><span class="line"><span class="comment"># View函数在抛出异常时该函数被调用，得到的exception参数是实际上抛出的异常实例。通过此方法可以进行很好的错误控制，提供友好的用户界面。</span></span><br><span class="line">process_exception(self, request, exception)</span><br><span class="line"><span class="comment"># 在执行完View函数准备将响应发到客户端前被执行</span></span><br><span class="line">process_response(self, request, response)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>django中间件的使用场景</p><p>如果你想修改请求，例如被传送到view中的HttpRequest对象</p><p>或者你想修改view返回的HttpResponse对象，这些都可以通过中间件来实现</p><p>可能你还想在view执行之前做一些操作，这种情况也可以用 middleware来实现。<br>比如我们写一个判断浏览器来源，是pc还是手机，这里手机我们采用iphone，因为暂时没有其他设备。我们有不想把这个逻辑加到视图函数里，想作为一个通用服务，作为一个可插拔的组件被使用，最好的方法就是实现为中间件</p><p>或者说做一个拦截器，发现一定的时间内某个ip对网页的访问次数过多，则将其加入黑名单</p></li></ol><hr><h2 id="简述什么是FBV和CBV？"><a href="#简述什么是FBV和CBV？" class="headerlink" title="简述什么是FBV和CBV？"></a>简述什么是FBV和CBV？</h2><p><strong>FBV（function base views） 基于函数的视图</strong><br><strong>CBV（class base views） 基于类的视图</strong></p><p>使用fbv的模式,在url匹配成功之后,会直接执行对应的视图函数</p><p>使用cbv模式,在url匹配成功之后,会找到视图函数中对应的类,然后这个类回到请求头中找到对应的Request Method</p><p>用户发送url请求,Django会依次遍历路由映射表中的所有记录,一旦路由映射表其中的一条匹配成功了,就执行视图函数中对应的函数名,这是fbv的执行流程</p><p>当服务端使用cbv模式的时候,用户发给服务端的请求包含url和method,这两个信息都是字符串类型<br>服务端通过路由映射表匹配成功后会自动去找dispatch方法,然后Django会通过dispatch反射的方式找到类中对应的方法并执行<br>类中的方法执行完毕之后,会把客户端想要的数据返回给dispatch方法,由dispatch方法把数据返回经客户端</p><hr><h2 id="django的request对象是在什么时候创建的？"><a href="#django的request对象是在什么时候创建的？" class="headerlink" title="django的request对象是在什么时候创建的？"></a>django的request对象是在什么时候创建的？</h2><p>当请求一个页面时,Django创建一个 HttpRequest 对象.该对象包含 request 的元数据. 然后 Django 调用相应的 view 函数(HttpRequest 对象自动传递给该view函数&lt;作为第一个参数&gt;), 每一个 view 负责返回一个 HttpResponse 对象.</p><p>requests的元数据包括path，get，put等方法，cookies，user等等</p><hr><h2 id="如何给CBV的程序添加装饰器？"><a href="#如何给CBV的程序添加装饰器？" class="headerlink" title="如何给CBV的程序添加装饰器？"></a>如何给CBV的程序添加装饰器？</h2><p>CBV添加装饰器有两种方法</p><ol><li>在指定方法上添加装饰器</li><li>在类上添加，但是要用name来指定方法</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## CBV中添加装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 1. 指定方法上添加装饰器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(View)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @method_decorator(wrapper)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 在类上添加</span><br><span class="line"></span><br><span class="line"><span class="meta">@method_decorator(wrapper,name='dispatch')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>总结</p><ol><li>添加装饰器前必须导入from django.utils.decorators import method_decorator</li><li>添加装饰器的格式必须为@method_decorator()，括号里面为装饰器的函数名</li><li>给类添加是必须声明name</li><li>注意csrf-token装饰器的特殊性，它只能加在dispatch上面</li></ol><hr><h2 id="列举django-orm-中所有的方法（QuerySet对象的所有方法）"><a href="#列举django-orm-中所有的方法（QuerySet对象的所有方法）" class="headerlink" title="列举django orm 中所有的方法（QuerySet对象的所有方法）"></a>列举django orm 中所有的方法（QuerySet对象的所有方法）</h2><p>从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet</p><ul><li>filter 过滤</li><li>exclude 排除</li><li>annotate 聚合</li><li>order_by 排序</li><li>reverse 反向排序</li><li>distinct 去除查询结果中重复的行</li><li>values 迭代时返回字典而不是模型实例对象</li><li>values_list 迭代时返回元组而不是字典</li><li>dates 表示特定种类的所有可用日期</li><li>datetimes 表示特定种类的所有可用日期</li><li>none 不返回任何对象</li><li>all 返回所有结果</li><li>select_related 外键查询</li><li>prefetch_related 在单个批处理中自动检索每个指定查找的相关对象</li><li>defer 告诉django不要查询某些字段</li><li>using 多个数据库时控制QuerySet在哪个数据库上求值</li></ul><hr><h2 id="only和defer的区别？"><a href="#only和defer的区别？" class="headerlink" title="only和defer的区别？"></a>only和defer的区别？</h2><p>在复杂的情况下，表中可能有些字段内容非常多，取出来转化成 Python 对象会占用大量的资源。<br>这时候可以用 defer 来排除这些字段，比如我们在文章列表页，只需要文章的标题和作者，没有必要把文章的内容也获取出来（因为会转换成python对象，浪费内存）</p><p>和 defer 相反，only 用于取出需要的字段，假如我们只需要查出 作者的名称</p><hr><h2 id="select-related和prefetch-related的区别？"><a href="#select-related和prefetch-related的区别？" class="headerlink" title="select_related和prefetch_related的区别？"></a><code>select_related</code>和<code>prefetch_related</code>的区别？</h2><p><a href="https://hk.saowen.com/a/bb124ab70580b722d7840c7c0377a326ac4ce022dc653f4cbc7e0ae7fc245232" target="_blank" rel="noopener">https://hk.saowen.com/a/bb124ab70580b722d7840c7c0377a326ac4ce022dc653f4cbc7e0ae7fc245232</a></p><hr><h2 id="filter和exclude的区别？"><a href="#filter和exclude的区别？" class="headerlink" title="filter和exclude的区别？"></a>filter和exclude的区别？</h2><p>filter 设置要查询的字段<br>exclude 设置不要查询的字段</p><hr><h2 id="列举django-orm中三种能写sql语句的方法"><a href="#列举django-orm中三种能写sql语句的方法" class="headerlink" title="列举django orm中三种能写sql语句的方法"></a>列举django orm中三种能写sql语句的方法</h2><ol><li>使用extra：查询人民邮电出版社出版并且价格大于50元的书籍</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Book.objects.filter(publisher__name=&apos;人民邮电出版社&apos;).extra(where=[&apos;price&gt;50&apos;])</span><br></pre></td></tr></table></figure><ol><li>使用raw</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">books=Book.objects.raw(&apos;select * from hello_book&apos;)  </span><br><span class="line">for book in books:  </span><br><span class="line">   print book</span><br></pre></td></tr></table></figure><ol><li>自定义sql</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import connection  </span><br><span class="line">  </span><br><span class="line">cursor = connection.cursor()  </span><br><span class="line">cursor.execute(&quot;insert into hello_author(name) VALUES (&apos;郭敬明&apos;)&quot;)  </span><br><span class="line">cursor.execute(&quot;update hello_author set name=&apos;韩寒&apos; WHERE name=&apos;郭敬明&apos;&quot;)  </span><br><span class="line">cursor.execute(&quot;delete from hello_author where name=&apos;韩寒&apos;&quot;)  </span><br><span class="line">cursor.execute(&quot;select * from hello_author&quot;)  </span><br><span class="line">cursor.fetchone()  </span><br><span class="line">cursor.fetchall()</span><br></pre></td></tr></table></figure><hr><h2 id="django-orm-中如何设置读写分离？"><a href="#django-orm-中如何设置读写分离？" class="headerlink" title="django orm 中如何设置读写分离？"></a>django orm 中如何设置读写分离？</h2><p><a href="https://blog.csdn.net/Ayhan_huang/article/details/78784486" target="_blank" rel="noopener">https://blog.csdn.net/Ayhan_huang/article/details/78784486</a></p><p><a href="https://my.oschina.net/candiesyangyang/blog/203425" target="_blank" rel="noopener">https://my.oschina.net/candiesyangyang/blog/203425</a></p><hr><h2 id="F和Q的作用"><a href="#F和Q的作用" class="headerlink" title="F和Q的作用?"></a>F和Q的作用?</h2><p>F作用：操作数据表中的某列值，F()允许Django在未实际链接数据的情况下具有对数据库字段的值的引用，不用获取对象放在内存中再对字段进行操作，直接执行原生产sql语句操作</p><p>使用场景：对数据库中的所有的商品，在原价格的基础上涨价10元</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db.models import F</span><br><span class="line">from app01.models import Book</span><br><span class="line">Book.objects.update(price=F(&quot;price&quot;)+20)  # 对于book表中每本书的价格都在原价格的基础上增加20元</span><br></pre></td></tr></table></figure><p>Q作用：对对象进行复杂查询，并支持&amp;（and）,|（or），~（not）操作符</p><p>使用场景：filter查询条件只有一个，而使用Q可以设置多个查询条件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db.models import Q</span><br><span class="line">search_obj=Asset.objects.filter(Q(hostname__icontains=keyword)|Q(ip=keyword))</span><br></pre></td></tr></table></figure><p>当同时使用filter的关键字查询和Q查询时，一定要把Q对象放在前面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Asset.objects.get(</span><br><span class="line">Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),question__startswith=&apos;Who&apos;)</span><br></pre></td></tr></table></figure><h2 id="values和values-list的区别"><a href="#values和values-list的区别" class="headerlink" title="values和values_list的区别"></a>values和values_list的区别</h2><p>values 返回字典而不是模型查询对象</p><p>values-list 跟values一样，但是返回的是元组</p><p><a href="https://blog.csdn.net/weixin_40475396/article/details/79529256" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40475396/article/details/79529256</a></p><h2 id="如何使用django-orm批量创建数据？"><a href="#如何使用django-orm批量创建数据？" class="headerlink" title="如何使用django orm批量创建数据？"></a>如何使用django orm批量创建数据？</h2><p>如果使用django save()创建数据，则每次save的时候都会访问一次数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in resultlist:</span><br><span class="line">    p = Account(name=i)</span><br><span class="line">    p.save()</span><br></pre></td></tr></table></figure><p>django1.4之后加入新特性可以批量创建对象，减少SQL查询次数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">querysetlist=[]</span><br><span class="line">for i in resultlist:</span><br><span class="line">    querysetlist.append(Account(name=i))</span><br><span class="line">Account.objects.bulk_create(querysetlist)</span><br></pre></td></tr></table></figure><h2 id="django的Form和ModeForm的作用？"><a href="#django的Form和ModeForm的作用？" class="headerlink" title="django的Form和ModeForm的作用？"></a>django的Form和ModeForm的作用？</h2><p><a href="http://www.cnblogs.com/caochao-/articles/8412830.html" target="_blank" rel="noopener">http://www.cnblogs.com/caochao-/articles/8412830.html</a></p><p>表单的作用是收集元素中的内容</p><p>Form 需要自己定义表单的字段</p><p>ModelForm 根据model来生成表单的字段</p><h2 id="django的Form组件中，如果字段中包含choices参数，请使用两种方式实现数据源实时更新"><a href="#django的Form组件中，如果字段中包含choices参数，请使用两种方式实现数据源实时更新" class="headerlink" title="django的Form组件中，如果字段中包含choices参数，请使用两种方式实现数据源实时更新"></a>django的Form组件中，如果字段中包含choices参数，请使用两种方式实现数据源实时更新</h2><p>此问题只适用于From组件，ModelFrom组件不用考虑(自身已经解决)</p><p>示例：例如choice类型字段，添加了新的数据，而在页面中不能显示出来，只有再次刷新页面才能获取最新的数据，因为程序运行时静态字段只加载一次, choice的数据如果从数据库获取可能会造成数据无法实时更新</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserType</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">　　　</span><br><span class="line">　　<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">　　　　<span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    email = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    ut = models.ForeignKey(to=<span class="string">'UserType'</span>)</span><br></pre></td></tr></table></figure><p>方法一：重写构造方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py      </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> Form</span><br><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> fields</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserForm</span><span class="params">(Form)</span>:</span></span><br><span class="line">    name = fields.CharField(label=<span class="string">'用户名'</span>,max_length=<span class="number">32</span>)</span><br><span class="line">    email = fields.EmailField(label=<span class="string">'邮箱'</span>)</span><br><span class="line">    ut_id = fields.ChoiceField(</span><br><span class="line">        <span class="comment"># choices=[(1,'二笔用户'),(2,'闷骚')]</span></span><br><span class="line">        choices=[]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,*args,**kwargs)</span>:</span></span><br><span class="line">        super(UserForm,self).__init__(*args,**kwargs)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每次实例化，重新去数据库获取数据并更新</span></span><br><span class="line">        self.fields[<span class="string">'ut_id'</span>].choices = models.UserType.objects.all().values_list(<span class="string">'id'</span>,<span class="string">'title'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">        form = UserForm()</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'user.html'</span>,&#123;<span class="string">'form'</span>:form&#125;)</span><br></pre></td></tr></table></figure><p>方法二：使用ModelChoiceField字段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> Form</span><br><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> fields</span><br><span class="line"><span class="keyword">from</span> django.forms.models <span class="keyword">import</span> ModelChoiceField</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserForm</span><span class="params">(Form)</span>:</span></span><br><span class="line">    name = fields.CharField(label=<span class="string">'用户名'</span>,max_length=<span class="number">32</span>)</span><br><span class="line">    email = fields.EmailField(label=<span class="string">'邮箱'</span>)</span><br><span class="line">    ut_id = ModelChoiceField(queryset=models.UserType.objects.all())</span><br></pre></td></tr></table></figure><h3 id="django的Model中的ForeignKey字段中的on-delete参数有什么作用？"><a href="#django的Model中的ForeignKey字段中的on-delete参数有什么作用？" class="headerlink" title="django的Model中的ForeignKey字段中的on_delete参数有什么作用？"></a>django的Model中的ForeignKey字段中的on_delete参数有什么作用？</h3><p>当一个被ForeignKey引用的对象删除后，django将会通过指定on_delete参数来仿真sql约束的行为</p><p>例如，如果你有一个可以为空的ForeignKey，在其引用的对象被删除的时你想把这个ForeignKey 设置为空：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user = models.ForeignKey(User, blank=True, null=True, on_delete=models.SET_NULL)</span><br></pre></td></tr></table></figure><p><code>on_delete</code>有<code>CASCADE</code>、<code>PROTECT</code>、<code>SET_NULL</code>、<code>SET_DEFAULT</code>、<code>SET()</code>五个可选择的值</p><ol><li>CASCADE: 级联删除；默认值</li><li>PROTECT: 抛出ProtectedError 以阻止被引用对象的删除，它是django.db.IntegrityError 的一个子类</li><li>SET_NULL: 把ForeignKey 设置为null； null 参数为True 时才可以这样做</li><li>SET_DEFAULT: ForeignKey 值设置成它的默认值；此时必须设置ForeignKey 的default 参数</li><li>SET: 设置ForeignKey 为传递给SET() 的值，如果传递的是一个可调用对象，则为调用后的结果。在大部分情形下，<a href="http://xn--models-9m7igl44aw5bf6lb5io91a1s4fba7274gzkb249ap2b.py/" target="_blank" rel="noopener">传递一个可调用对象用于避免models.py</a> 在导入时执行查询</li></ol><h2 id="django中csrf的实现机制？"><a href="#django中csrf的实现机制？" class="headerlink" title="django中csrf的实现机制？"></a>django中csrf的实现机制？</h2><p><a href="https://blog.csdn.net/u011715678/article/details/48752873" target="_blank" rel="noopener">https://blog.csdn.net/u011715678/article/details/48752873</a></p><p><a href="https://www.jianshu.com/p/991df812e2a5?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/991df812e2a5?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p><h2 id="django如何实现websocket？"><a href="#django如何实现websocket？" class="headerlink" title="django如何实现websocket？"></a>django如何实现websocket？</h2><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p><p>HTTP 协议有一个缺陷：通信只能由客户端发起</p><p>WebSocket 协议它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p><p>django实现websocket有多种方式：</p><ol><li>使用Channels实现websocket</li></ol><p><a href="https://www.jianshu.com/p/3de90e457bb4" target="_blank" rel="noopener">https://www.jianshu.com/p/3de90e457bb4</a></p><ol><li>使用dwebsocket实现Websocket</li></ol><p><a href="https://www.cnblogs.com/huguodong/p/6611602.html" target="_blank" rel="noopener">https://www.cnblogs.com/huguodong/p/6611602.html</a></p><p><a href="http://gtcsq.readthedocs.io/en/latest/others/websocket.html" target="_blank" rel="noopener">http://gtcsq.readthedocs.io/en/latest/others/websocket.html</a></p><h2 id="基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf-token？"><a href="#基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf-token？" class="headerlink" title="基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf token？"></a>基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf token？</h2><p>1、写在Ajax beforeSend</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax（｛</span><br><span class="line">　　xxx:xxx,</span><br><span class="line">　　beforeSend:function(xhr, settings)&#123;</span><br><span class="line">　　　　xhr.setRequestHeader(&quot;x-CSRFToken&quot;, &quot;&#123;&#123; csrf_token &#125;&#125;&quot;);</span><br><span class="line">　　&#125;,</span><br><span class="line">｝）</span><br></pre></td></tr></table></figure><p>2、写到Ajax Data</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax（｛</span><br><span class="line">　　xxx:xxx,</span><br><span class="line">　　data: $(&quot;#form&quot;).serialize(),</span><br><span class="line">｝）</span><br></pre></td></tr></table></figure><p>3、写到ajaxSetup</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#add-business-form&quot;).submit(function () &#123;</span><br><span class="line">            $.ajaxSetup(&#123;</span><br><span class="line">            data: &#123;csrfmiddlewaretoken: &apos;&#123;&#123; csrf_token &#125;&#125;&apos;&#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">               xxx:xxxx,</span><br><span class="line">            &#125;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>4、KindEditor携带CSRF</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var csrfitems = document.getElementsByName(&quot;csrfmiddlewaretoken&quot;);</span><br><span class="line">    var csrftoken = &quot;&quot;;</span><br><span class="line">    if(csrfitems.length &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        csrftoken = csrfitems[0].value;</span><br><span class="line">    &#125;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">            initKindEditor();</span><br><span class="line">        &#125;);</span><br><span class="line">    function initKindEditor() &#123;</span><br><span class="line">        $.ajaxSetup(&#123;</span><br><span class="line">        data: &#123;csrfmiddlewaretoken: &apos;&#123;&#123; csrf_token &#125;&#125;&apos;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        var kind = KindEditor.create(&apos;#content&apos;, &#123;</span><br><span class="line">            width: &apos;100%&apos;,       // 文本框宽度(可以百分比或像素)</span><br><span class="line">            height: &apos;300px&apos;,     // 文本框高度(只能像素)</span><br><span class="line">            minWidth: 200,       // 最小宽度（数字）</span><br><span class="line">            minHeight: 400,      // 最小高度（数字）</span><br><span class="line">            uploadJson: &apos;&#123;% url &quot;upload_image&quot; %&#125;&apos;,</span><br><span class="line">            extraFileUploadParams : &#123;</span><br><span class="line">                csrfmiddlewaretoken:csrftoken</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="django中如何实现orm表中添加数据时创建一条日志记录"><a href="#django中如何实现orm表中添加数据时创建一条日志记录" class="headerlink" title="django中如何实现orm表中添加数据时创建一条日志记录"></a>django中如何实现orm表中添加数据时创建一条日志记录</h2><ol><li>使用信号记录</li><li>使用logger</li></ol><p><a href="https://blog.csdn.net/apple9005/article/details/73608994" target="_blank" rel="noopener">https://blog.csdn.net/apple9005/article/details/73608994</a></p><h2 id="django缓存如何设置？"><a href="#django缓存如何设置？" class="headerlink" title="django缓存如何设置？"></a>django缓存如何设置？</h2><p><a href="https://www.cnblogs.com/linxiyue/p/7494540.html" target="_blank" rel="noopener">https://www.cnblogs.com/linxiyue/p/7494540.html</a></p><h2 id="django的缓存能使用redis吗？如果可以的话，如何配置？"><a href="#django的缓存能使用redis吗？如果可以的话，如何配置？" class="headerlink" title="django的缓存能使用redis吗？如果可以的话，如何配置？"></a>django的缓存能使用redis吗？如果可以的话，如何配置？</h2><p><a href="https://www.jianshu.com/p/04ef84c3fe3b" target="_blank" rel="noopener">https://www.jianshu.com/p/04ef84c3fe3b</a></p><h2 id="django路由系统中name的作用？"><a href="#django路由系统中name的作用？" class="headerlink" title="django路由系统中name的作用？"></a>django路由系统中name的作用？</h2><p><a href="https://www.cnblogs.com/no13bus/p/3767521.html" target="_blank" rel="noopener">https://www.cnblogs.com/no13bus/p/3767521.html</a></p><p><a href="https://code.ziqiangxuetang.com/django/django-url-name.html" target="_blank" rel="noopener">https://code.ziqiangxuetang.com/django/django-url-name.html</a></p><h2 id="django的模板中filter和simple-tag的区别？"><a href="#django的模板中filter和simple-tag的区别？" class="headerlink" title="django的模板中filter和simple_tag的区别？"></a>django的模板中filter和simple_tag的区别？</h2><p><a href="https://blog.csdn.net/huanhuanq1209/article/details/77756446" target="_blank" rel="noopener">https://blog.csdn.net/huanhuanq1209/article/details/77756446</a></p><h2 id="django-debug-toolbar的作用？"><a href="#django-debug-toolbar的作用？" class="headerlink" title="django-debug-toolbar的作用？"></a>django-debug-toolbar的作用？</h2><p><a href="https://www.cnblogs.com/Lands-ljk/p/5506766.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lands-ljk/p/5506766.html</a></p><h2 id="django中如何实现单元测试？"><a href="#django中如何实现单元测试？" class="headerlink" title="django中如何实现单元测试？"></a>django中如何实现单元测试？</h2><p><a href="https://www.jianshu.com/p/15af33d2c2c4" target="_blank" rel="noopener">https://www.jianshu.com/p/15af33d2c2c4</a></p><h2 id="解释orm中-db-first-和-code-first的含义"><a href="#解释orm中-db-first-和-code-first的含义" class="headerlink" title="解释orm中 db first 和 code first的含义"></a>解释orm中 db first 和 code first的含义</h2><p>db first：现有数据库，<a href="http://xn--models-ht8i645axqa6a510yi0i5neuviwr3c2cn.py/" target="_blank" rel="noopener">然后从数据库反向生成models.py</a></p><p>code first: <a href="http://xn--models-283m094f.py/" target="_blank" rel="noopener">现有models.py</a> 再进行数据库操作</p><h2 id="django中如何根据数据库表生成model中的类"><a href="#django中如何根据数据库表生成model中的类" class="headerlink" title="django中如何根据数据库表生成model中的类"></a>django中如何根据数据库表生成model中的类</h2><p><a href="https://www.jianshu.com/p/037bd7e20a7a" target="_blank" rel="noopener">https://www.jianshu.com/p/037bd7e20a7a</a></p><h2 id="使用orm和原生sql的优缺点？"><a href="#使用orm和原生sql的优缺点？" class="headerlink" title="使用orm和原生sql的优缺点？"></a>使用orm和原生sql的优缺点？</h2><p>使用 ORM 最大的优点就是快速开发，让我们将更多的精力放在业务上而不是数据库上，下面是 ORM 的几个优点</p><ol><li>隐藏了数据访问细节，使通用数据库交互变得简单易行。同时 ORM 避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为的 bug，方便编码风格的统一和后期维护。</li><li>将数据库表和对象模型关联，我们只需针对相关的对象模型进行编码，无须考虑对象模型和数据库表之间的转化，大大提高了程序的开发效率。</li><li>方便数据库的迁移。当需要迁移到新的数据库时，不需要修改对象模型，只需要修改数据库的配置。</li></ol><p>ORM 的最令人诟病的地方就是性能问题，不过现在已经提高了很多，下面是 ORM 的几个缺点</p><ol><li>性能问题<ol><li>自动化进行数据库关系的映射需要消耗系统资源</li><li>程序员编码</li><li>在处理多表联查、where 条件复杂的查询时，ORM 可能会生成的效率低下的 SQL</li><li>通过 Lazy load 和 Cache 很大程度上改善了性能问题</li></ol></li><li>SQL 调优，SQL 语句是由 ORM 框架自动生成，虽然减少了 SQL 语句错误的发生，但是也给 SQL 调优带来了困难。</li><li>越是功能强大的 ORM 越消耗内存，因为一个 ORM Object 会带有很多成员变量和成员函数。</li><li>对象和关系之间并不是完美映射<br>一般来说 ORM 足以满足我们的需求，如果对性能要求特别高或者查询十分复杂，可以考虑使用原生 SQL 和 ORM 共用的方式</li></ol><p>使用原生sql优点：</p><ol><li>进行复杂的查询时更加灵活</li><li>可以根据需要编写特殊的sql语句</li></ol><p>使用原生sql缺点：</p><ol><li>需要对输入进行严格的检测</li><li>自己写的sql语句，很多时候使用的是字符串拼接，可能会有sql注入的漏洞</li><li>不能使用django orm相关的一些特性</li></ol><h2 id="简述MVC和MTV"><a href="#简述MVC和MTV" class="headerlink" title="简述MVC和MTV"></a>简述MVC和MTV</h2><p><a href="http://www.dongwm.com/archives/%E6%B5%85%E8%B0%88MVC%E3%80%81MTV%E5%92%8CMVVM/" target="_blank" rel="noopener">http://www.dongwm.com/archives/浅谈MVC、MTV和MVVM/</a></p><h2 id="django的contenttype组件的作用？"><a href="#django的contenttype组件的作用？" class="headerlink" title="django的contenttype组件的作用？"></a>django的contenttype组件的作用？</h2><p><a href="https://blog.csdn.net/Ayhan_huang/article/details/78626957" target="_blank" rel="noopener">https://blog.csdn.net/Ayhan_huang/article/details/78626957</a></p><p><a href="https://juejin.im/entry/581da04f128fe1005afdf618" target="_blank" rel="noopener">https://juejin.im/entry/581da04f128fe1005afdf618</a></p><h2 id="谈谈你对restfull-规范的认识？"><a href="#谈谈你对restfull-规范的认识？" class="headerlink" title="谈谈你对restfull 规范的认识？"></a>谈谈你对restfull 规范的认识？</h2><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></p><h2 id="接口的幂等性是什么意思？"><a href="#接口的幂等性是什么意思？" class="headerlink" title="接口的幂等性是什么意思？"></a>接口的幂等性是什么意思？</h2><p><a href="https://www.jianshu.com/p/b09a2e9bcd29" target="_blank" rel="noopener">https://www.jianshu.com/p/b09a2e9bcd29</a></p><h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><p><a href="https://www.jianshu.com/p/2accc2840a1b" target="_blank" rel="noopener">https://www.jianshu.com/p/2accc2840a1b</a></p><h2 id="Http和Https的区别？"><a href="#Http和Https的区别？" class="headerlink" title="Http和Https的区别？"></a>Http和Https的区别？</h2><p><a href="https://juejin.im/entry/58d7635e5c497d0057fae036" target="_blank" rel="noopener">https://juejin.im/entry/58d7635e5c497d0057fae036</a></p><h2 id="为什么要使用django-rest-framework框架？"><a href="#为什么要使用django-rest-framework框架？" class="headerlink" title="为什么要使用django rest framework框架？"></a>为什么要使用django rest framework框架？</h2><p>为什么要使用REST framework？</p><ul><li>在线可视的API，对于赢得你的开发者们十分有用</li></ul><p>验证策略涵盖了OAuth1a和OAuth2</p><p>同时支持ORM和非ORM数据源的序列化</p><p>可以配置各个环节，若无需更多强大的特性，使用一般基于方法（function-based）的视图（views）即可</p><p>大量的文档，强力的社区支持</p><p>大公司如同Mozilla和Eventbrite，也是忠实的使用者</p><h2 id="django-rest-framework框架中都有那些组件？"><a href="#django-rest-framework框架中都有那些组件？" class="headerlink" title="django rest framework框架中都有那些组件？"></a>django rest framework框架中都有那些组件？</h2><p><strong>1. 路由</strong></p><ul><li>可以通过as_view传参数，根据请求方式不同执行相应的方法</li><li>可以在url中设置一个结尾，类似于： .json</li></ul><p><strong>2. 视图</strong></p><ul><li>帮助开发者提供了一些类，并在类中提供了多个方法以供我们使用</li></ul><p><strong>3. 版本</strong></p><ul><li>在url中设置version参数，用户请求时候传入参数。在request.version中获取版本，根据版本不同做不同处理</li></ul><p><strong>4. 认证</strong><br>写一个类并注册到认证类，在类的的authticate方法中编写认证逻辑。</p><ul><li>认证成功（user,auth）</li><li>raise AuthticateFaild(….)</li><li>None</li></ul><p><strong>5. 权限</strong><br>写一个类并注册到权限类，在类的的has_permission方法中编写认证逻辑。</p><ul><li>True</li><li>False</li></ul><p><strong>6. 频率限制</strong><br>写一个类并注册到频率类，在类的的 allow_request/wait 方法中编写认证逻辑。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow_request</span><br><span class="line"> True </span><br><span class="line"> False  如果返回False，那么就要执行wait</span><br></pre></td></tr></table></figure><p><strong>7. 解析器</strong></p><ul><li>根据ContentType请求头，选择不同解析器对 请求体中的数据进行解析。</li><li>POST /index/ http1.1.\r\nhost:11.11.11.11\r\nContent-Type:url-formendo…. \r\n\r\nuser=alex&amp;age=123</li><li>POST /index/ http1.1.\r\nhost:11.11.11.11\r\nContent-Type:application/json\r\n\r\n{….}</li></ul><p><strong>8. 分页</strong></p><ul><li>对从数据库中获取到的数据进行分页处理: SQL -&gt; limit offset<ul><li>根据页码：<a href="http://www.luffycity.com/api/v1/student/?page=1&amp;size=10" target="_blank" rel="noopener">http://www.luffycity.com/api/v1/student/?page=1&amp;size=10</a></li><li>根据索引：<a href="http://www.luffycity.com/api/v1/student/?offset=60&amp;limit=10" target="_blank" rel="noopener">http://www.luffycity.com/api/v1/student/?offset=60&amp;limit=10</a></li><li>根据加密：&lt;<a href="http://www.luffycity.com/api/v1/student/?page=erd8" target="_blank" rel="noopener">http://www.luffycity.com/api/v1/student/?page=erd8</a></li></ul></li></ul><h2 id="django-models中null和blank得区别"><a href="#django-models中null和blank得区别" class="headerlink" title="django models中null和blank得区别"></a>django models中null和blank得区别</h2><p><code>null</code> 是针对数据库而言，如果 <code>null=True</code>, 表示数据库的该字段可以为空</p><p><code>blank</code> 是针对表单的，如果 <code>blank=True</code>，表示你的表单填写该字段的时候可以不填，比如 <code>admin</code> 界面下增加 <code>model</code> 一条记录的时候。直观的看到就是该字段不是粗体</p><h3 id="django-rest-framework框架中的视图都可以继承哪些类？"><a href="#django-rest-framework框架中的视图都可以继承哪些类？" class="headerlink" title="django rest framework框架中的视图都可以继承哪些类？"></a>django rest framework框架中的视图都可以继承哪些类？</h3><p>APIview、ViewSets、Generic views</p><h3 id="简述-django-rest-framework框架的认证流程。"><a href="#简述-django-rest-framework框架的认证流程。" class="headerlink" title="简述 django rest framework框架的认证流程。"></a>简述 django rest framework框架的认证流程。</h3><p><a href="https://www.cnblogs.com/renpingsheng/p/9534984.html" target="_blank" rel="noopener">https://www.cnblogs.com/renpingsheng/p/9534984.html</a></p><h3 id="django-rest-framework如何实现的用户访问频率控制？"><a href="#django-rest-framework如何实现的用户访问频率控制？" class="headerlink" title="django rest framework如何实现的用户访问频率控制？"></a>django rest framework如何实现的用户访问频率控制？</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django思维导图</title>
      <link href="/2018/11/21/Django%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2018/11/21/Django%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>Django基础</p><a id="more"></a><p><img src="https://s1.ax1x.com/2018/11/21/FCcB6S.png" alt="FCcB6S.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搞懂RESTful</title>
      <link href="/2018/11/20/%E4%B8%80%E3%80%81REST%E7%AE%80%E8%BF%B0/"/>
      <url>/2018/11/20/%E4%B8%80%E3%80%81REST%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、REST简述"><a href="#一、REST简述" class="headerlink" title="一、REST简述"></a>一、REST简述</h2><p>来自维基百科的解释：</p><a id="more"></a><blockquote><p><strong>表现层状态转换</strong>（REST，英文：<strong>Representational State Transfer</strong>）是<a href="https://zh.wikipedia.org/w/index.php?title=Roy_Thomas_Fielding&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Roy Thomas Fielding</a>博士于2000年在他的博士论文<a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2#cite_note-Fielding-Ch5-1" target="_blank" rel="noopener">[1]</a> 中提出来的一种<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="noopener">万维网</a><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">软件架构</a>风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本传输协议(HTTP)</a>之上而确定的一组约束和属性，是一种设计提供万维网络服务的<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">软件构建风格</a>。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6" target="_blank" rel="noopener">统一资源标识符</a>访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质(interoperability)。相对于其它种类的网络服务，例如 SOAP服务则是以本身所定义的操作集，来访问网络上的资源。</p><p>Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">云计算</a>之类的环境。客户端可以缓存数据以改进性能。</p><p>在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、<a href="https://baike.baidu.com/item/POST" target="_blank" rel="noopener">POST</a> 和 <a href="https://baike.baidu.com/item/DELETE" target="_blank" rel="noopener">DELETE</a>。<a href="https://baike.baidu.com/item/Hypermedia" target="_blank" rel="noopener">Hypermedia</a> 是应用程序状态的<a href="https://baike.baidu.com/item/%E5%BC%95%E6%93%8E/2874935" target="_blank" rel="noopener">引擎</a>，资源表示通过<a href="https://baike.baidu.com/item/%E8%B6%85%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">超链接</a>互联。</p></blockquote><p><img src="https://s1.ax1x.com/2018/11/20/F9ZCrt.png" alt="F9ZCrt.png"></p><h2 id="二、REST的解析"><a href="#二、REST的解析" class="headerlink" title="二、REST的解析"></a>二、REST的解析</h2><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。</p><p>如果一个架构符合REST原则，就称它为RESTful架构。</p><p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p><ul><li>REST从资源的角度类审视整个网络，它将分布在网络中某个节点的资源通过URL进行标识，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态</li><li>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”</li><li>所有的数据，不过是通过网络获取的还是操作（增删改查）的数据，都是资源，将一切数据视为资源是REST区别与其他架构风格的最本质属性</li><li>对于REST这种面向资源的架构风格，有人提出一种全新的结构理念，即：面向资源架构（ROA：Resource Oriented Architecture）</li></ul><h2 id="三、资源（Resources）"><a href="#三、资源（Resources）" class="headerlink" title="三、资源（Resources）"></a>三、资源（Resources）</h2><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h2 id="四、表现层（Representation）"><a href="#四、表现层（Representation）" class="headerlink" title="四、表现层（Representation）"></a>四、表现层（Representation）</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h2 id="五、状态转化（State-Transfer）"><a href="#五、状态转化（State-Transfer）" class="headerlink" title="五、状态转化（State Transfer）"></a>五、状态转化（State Transfer）</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p><h2 id="六、综述"><a href="#六、综述" class="headerlink" title="六、综述"></a>六、综述</h2><p>综合上面的解释，我们总结一下什么是RESTful架构：</p><p>　　（1）每一个URI代表一种资源；</p><p>　　（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><h2 id="七、误区"><a href="#七、误区" class="headerlink" title="七、误区"></a>七、误区</h2><p>RESTful架构有一些典型的设计误区。</p><p>最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p><p>举例来说，某个URI是 /posts/show/1 ，其中 show 是动词，这个URI就设计错了，正确的写法应该是 /posts/1 ，然后用 GET 方法表示 show 。</p><p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /accounts/1/transfer/500/to/2</span><br></pre></td></tr></table></figure><p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /transaction HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">　　</span><br><span class="line">from=1&amp;to=2&amp;amount=500.00</span><br></pre></td></tr></table></figure><p>另一个设计误区，就是在URI中加入版本号：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.example.com/app/1.0/foo</span><br><span class="line"></span><br><span class="line">http://www.example.com/app/1.1/foo</span><br><span class="line"></span><br><span class="line">http://www.example.com/app/2.0/foo</span><br></pre></td></tr></table></figure><p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460" target="_blank" rel="noopener">Versioning REST Services</a>）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: vnd.example-com.foo+json; version=1.0</span><br><span class="line"></span><br><span class="line">Accept: vnd.example-com.foo+json; version=1.1</span><br><span class="line"></span><br><span class="line">Accept: vnd.example-com.foo+json; version=2.0</span><br></pre></td></tr></table></figure><h2 id="八、RESTful-API设计"><a href="#八、RESTful-API设计" class="headerlink" title="八、RESTful API设计"></a>八、RESTful API设计</h2><h3 id="8-1-协议"><a href="#8-1-协议" class="headerlink" title="8.1 协议"></a>8.1 协议</h3><p>API与用户的通信协议，总是使用<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">HTTPs协议</a>。</p><h3 id="8-2-域名"><a href="#8-2-域名" class="headerlink" title="8.2 域名"></a>8.2 域名</h3><p>应该尽量将API部署在专用域名之下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//api.example.com</span></span><br></pre></td></tr></table></figure><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//example.org/api/</span></span><br></pre></td></tr></table></figure><h3 id="8-3-版本（Versioning）"><a href="#8-3-版本（Versioning）" class="headerlink" title="8.3 版本（Versioning）"></a>8.3 版本（Versioning）</h3><p>应该将API的版本号放入URL。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//api.example.com/v1/</span></span><br></pre></td></tr></table></figure><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<a href="https://developer.github.com/v3/media/#request-specific-version" target="_blank" rel="noopener">Github</a>采用这种做法。</p><h3 id="8-4-路径（Endpoint）"><a href="#8-4-路径（Endpoint）" class="headerlink" title="8.4 路径（Endpoint）"></a>8.4 路径（Endpoint）</h3><p>路径又称”终点”（endpoint），表示API的具体网址。</p><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><blockquote><ul><li><a href="https://api.example.com/v1/zoos" target="_blank" rel="noopener">https://api.example.com/v1/zoos</a></li><li><a href="https://api.example.com/v1/animals" target="_blank" rel="noopener">https://api.example.com/v1/animals</a></li><li><a href="https://api.example.com/v1/employees" target="_blank" rel="noopener">https://api.example.com/v1/employees</a></li></ul></blockquote><h3 id="8-5-HTTP动词"><a href="#8-5-HTTP动词" class="headerlink" title="8.5 HTTP动词"></a>8.5 HTTP动词</h3><p>对于资源的具体操作类型，由HTTP动词表示。</p><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>还有两个不常用的HTTP动词。</p><ul><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li></ul><p>下面是一些例子。</p><ul><li>GET /zoos：列出所有动物园</li><li>POST /zoos：新建一个动物园</li><li>GET /zoos/ID：获取某个指定动物园的信息</li><li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li><li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li><li>DELETE /zoos/ID：删除某个动物园</li><li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li><li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li></ul><h3 id="8-6-过滤信息（Filtering）"><a href="#8-6-过滤信息（Filtering）" class="headerlink" title="8.6 过滤信息（Filtering）"></a>8.6 过滤信息（Filtering）</h3><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><p>下面是一些常见的参数。</p><ul><li>?limit=10：指定返回记录的数量</li><li>?offset=10：指定返回记录的开始位置。</li><li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li><li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li><li>?animal_type_id=1：指定筛选条件</li></ul><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><h3 id="8-7-状态码（Status-Codes）"><a href="#8-7-状态码（Status-Codes）" class="headerlink" title="8.7 状态码（Status Codes）"></a>8.7 状态码（Status Codes）</h3><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><ul><li><strong>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</strong></li><li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li><li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li><li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li><li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li><li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li><li><strong>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</strong></li><li><strong>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</strong></li><li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li><li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li><li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li><li><strong>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</strong></li></ul><p>状态码的完全列表参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a>。</p><h3 id="8-8-错误处理（Error-handling）"><a href="#8-8-错误处理（Error-handling）" class="headerlink" title="8.8 错误处理（Error handling）"></a>8.8 错误处理（Error handling）</h3><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-9-返回结果"><a href="#8-9-返回结果" class="headerlink" title="8.9 返回结果"></a>8.9 返回结果</h3><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><ul><li>GET /collection：返回资源对象的列表（数组）</li><li>GET /collection/resource：返回单个资源对象</li><li>POST /collection：返回新生成的资源对象</li><li>PUT /collection/resource：返回完整的资源对象</li><li>PATCH /collection/resource：返回完整的资源对象</li><li>DELETE /collection/resource：返回一个空文档</li></ul><h3 id="8-10-Hypermedia-API"><a href="#8-10-Hypermedia-API" class="headerlink" title="8.10 Hypermedia API"></a>8.10 Hypermedia API</h3><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p><p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"link"</span>: &#123;</span><br><span class="line">  <span class="string">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="string">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="string">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p><p>Hypermedia API的设计被称为<a href="http://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener">HATEOAS</a>。Github的API就是这种设计，访问<a href="https://api.github.com/" target="_blank" rel="noopener">api.github.com</a>会得到一个所有可用API的网址列表。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,</span><br><span class="line">  <span class="string">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href="https://api.github.com/user" target="_blank" rel="noopener">api.github.com/user</a>，然后就得到了下面结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"Requires authentication"</span>,</span><br><span class="line">  <span class="string">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><h3 id="8-11-其他"><a href="#8-11-其他" class="headerlink" title="8.11 其他"></a>8.11 其他</h3><p>（1）API的身份认证应该使用<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">OAuth 2.0</a>框架。</p><p>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><p>阮一峰：<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p><p>YUAN先生： <a href="https://www.cnblogs.com/yuanchenqi/articles/8742684.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanchenqi/articles/8742684.html</a></p><p>维基百科: <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Representational_state_transfer</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 软件风格 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux相关思维导图</title>
      <link href="/2018/11/19/Linux%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2018/11/19/Linux%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>这里主要收集一些我认为不错的思维导图，请联系我删除<br><a id="more"></a></p><h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><img src="https://s1.ax1x.com/2018/11/19/FSzKOJ.png" alt="FSzKOJ.png"></p><h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><p><img src="https://s1.ax1x.com/2018/11/19/FSzb1U.png" alt="FSzb1U.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维导图,Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>源码剖析Django REST framework的认证方式</title>
      <link href="/2018/11/19/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Django%20REST%20framework%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/11/19/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Django%20REST%20framework%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>由Django的CBV模式流程，可以知道在<code>url匹配完成后，会执行自定义的类中的as_view方法</code>。</p><p>如果自定义的类中没有定义<code>as_view方法</code>，根据面向对象中类的继承可以知道，则<code>会执行其父类View中的as_view方法</code></p><p><code>在Django的View的as_view方法中，又会调用dispatch方法</code>。</p><p>现在来看看Django rest framework的认证流程</p><a id="more"></a><blockquote><p>Django restframework是基于Django的框架，所以基于CBV的模式也会执行自定义的类中的as_view方法</p></blockquote><p>先新建一个项目，配置url</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&apos;^user/&apos;, views.UserView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>views.py文件内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render,HttpResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line"></span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        print(request.__dict__)</span><br><span class="line">        print(request.user)</span><br><span class="line">        return HttpResponse(&quot;UserView GET&quot;)</span><br><span class="line"></span><br><span class="line">    def post(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&quot;UserView POST&quot;)</span><br></pre></td></tr></table></figure><p>启动项目，用浏览器向<code>http://127.0.0.1:8000/user/</code>发送get请求</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180825183747075-1935268768.png" alt="img"></p><p>可以知道请求发送成功。现在来看看源码流程，由于UserView继承APIView，查看APIView中的as_view方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class APIView(View):</span><br><span class="line">    ...</span><br><span class="line">    @classmethod</span><br><span class="line">    def as_view(cls, **initkwargs):</span><br><span class="line">        if isinstance(getattr(cls, &apos;queryset&apos;, None), models.query.QuerySet):</span><br><span class="line">            def force_evaluation():</span><br><span class="line">                raise RuntimeError(</span><br><span class="line">                    &apos;Do not evaluate the `.queryset` attribute directly, &apos;</span><br><span class="line">                    &apos;as the result will be cached and reused between requests. &apos;</span><br><span class="line">                    &apos;Use `.all()` or call `.get_queryset()` instead.&apos;</span><br><span class="line">                )</span><br><span class="line">            cls.queryset._fetch_all = force_evaluation</span><br><span class="line"></span><br><span class="line">        view = super(APIView, cls).as_view(**initkwargs)</span><br><span class="line">        view.cls = cls</span><br><span class="line">        view.initkwargs = initkwargs</span><br><span class="line">        return csrf_exempt(view)</span><br></pre></td></tr></table></figure><p><code>通过super来执行APIView的父类Django的View中的as_view方法</code>。上一篇文章<a href="https://www.cnblogs.com/renpingsheng/p/9531649.html" target="_blank" rel="noopener">源码解析Django CBV的本质</a>中已经知道，View类的as_view方法会调用dispatch方法。</p><p>View类的as_view方法源码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class View(object):</span><br><span class="line">    ...</span><br><span class="line">    @classonlymethod</span><br><span class="line">    def as_view(cls, **initkwargs):</span><br><span class="line">        ...</span><br><span class="line">        def view(request, *args, **kwargs):</span><br><span class="line">            self = cls(**initkwargs)</span><br><span class="line">            if hasattr(self, &apos;get&apos;) and not hasattr(self, &apos;head&apos;):</span><br><span class="line">                self.head = self.get</span><br><span class="line">            self.request = request</span><br><span class="line">            self.args = args</span><br><span class="line">            self.kwargs = kwargs</span><br><span class="line">            return self.dispatch(request, *args, **kwargs)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>as_view方法中的self实际上指的是自定义的UserView这个类</code>，上面的代码会执行UserView类中dispatch方法。</p><p>由于UserView类中并没有定义dispatch方法，而UserView类继承自Django restframework的APIView类，所以会执行APIView类中的dispatch方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dispatch(self, request, *args, **kwargs):</span><br><span class="line">    self.args = args</span><br><span class="line">    self.kwargs = kwargs</span><br><span class="line">    request = self.initialize_request(request, *args, **kwargs)</span><br><span class="line">    self.request = request</span><br><span class="line">    self.headers = self.default_response_headers  # deprecate?</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        self.initial(request, *args, **kwargs)</span><br><span class="line">        if request.method.lower() in self.http_method_names:</span><br><span class="line">            handler = getattr(self, request.method.lower(),</span><br><span class="line">                              self.http_method_not_allowed)</span><br><span class="line">        else:</span><br><span class="line">            handler = self.http_method_not_allowed</span><br><span class="line"></span><br><span class="line">        response = handler(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    except Exception as exc:</span><br><span class="line">        response = self.handle_exception(exc)</span><br><span class="line"></span><br><span class="line">    self.response = self.finalize_response(request, response, *args, **kwargs)</span><br><span class="line">    return self.response</span><br></pre></td></tr></table></figure><p>可以看到，<code>先执行initialize_request方法处理浏览器发送的request请求</code>。</p><p>来看看initialize_request方法的源码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def initialize_request(self, request, *args, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Returns the initial request object.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    parser_context = self.get_parser_context(request)</span><br><span class="line"></span><br><span class="line">    return Request(</span><br><span class="line">        request,</span><br><span class="line">        parsers=self.get_parsers(),</span><br><span class="line">        authenticators=self.get_authenticators(),</span><br><span class="line">        negotiator=self.get_content_negotiator(),</span><br><span class="line">        parser_context=parser_context</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>在initialize_request方法里，把浏览器发送的request和restframework的处理器，认证，选择器等对象列表作为参数实例化Request类中得到新的request对象并返回，其中跟认证相关的对象就是authenticators。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_authenticators(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Instantiates and returns the list of authenticators that this view can use.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return [auth() for auth in self.authentication_classes]</span><br><span class="line">get_authenticators方法通过列表生成式得到一个列表，列表中包含认证类实例化后的对象</span><br></pre></td></tr></table></figure><p>在这里，<code>authentication_classes来自于api_settings的配置</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES</span><br></pre></td></tr></table></figure><p>通过查看api_settings的源码可以知道，可以在项目的settings.py文件中进行认证相关的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)</span><br><span class="line"></span><br><span class="line">def reload_api_settings(*args, **kwargs):</span><br><span class="line">    setting = kwargs[&apos;setting&apos;]</span><br><span class="line">    if setting == &apos;REST_FRAMEWORK&apos;:</span><br><span class="line">        api_settings.reload()</span><br></pre></td></tr></table></figure><p>Django restframework通过initialize_request方法对原始的request进行一些封装后实例化得到新的request对象</p><p>然后执行initial方法来处理新得到的request对象，再来看看initial方法中又执行了哪些操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def initial(self, request, *args, **kwargs):</span><br><span class="line">    self.format_kwarg = self.get_format_suffix(**kwargs)</span><br><span class="line">    neg = self.perform_content_negotiation(request)</span><br><span class="line">    request.accepted_renderer, request.accepted_media_type = neg</span><br><span class="line"></span><br><span class="line">    version, scheme = self.determine_version(request, *args, **kwargs)</span><br><span class="line">    request.version, request.versioning_scheme = version, scheme</span><br><span class="line"></span><br><span class="line">    self.perform_authentication(request)</span><br><span class="line">    self.check_permissions(request)</span><br><span class="line">    self.check_throttles(request)</span><br></pre></td></tr></table></figure><p>由上面的源码可以知道，在initial方法中，<code>执行perform_authentication来对request对象进行认证操作</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def perform_authentication(self, request):</span><br><span class="line">    request.user</span><br><span class="line">perform_authentication方法中调用执行request中的user方法`，`这里的request是封装了原始request,认证对象列表，处理器列表等之后的request对象</span><br><span class="line">class Request(object):</span><br><span class="line">    ...</span><br><span class="line">    @property</span><br><span class="line">    def user(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the user associated with the current request, as authenticated</span><br><span class="line">        by the authentication classes provided to the request.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not hasattr(self, &apos;_user&apos;):</span><br><span class="line">            with wrap_attributeerrors():</span><br><span class="line">                self._authenticate()</span><br><span class="line">        return self._user</span><br></pre></td></tr></table></figure><p>从request中获取<code>_user</code>的值，如果获取到则执行<code>_authenticate方法</code>，否则返回<code>_user</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _authenticate(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Attempt to authenticate the request using each authentication instance</span><br><span class="line">    in turn.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    for authenticator in self.authenticators:</span><br><span class="line">        try:</span><br><span class="line">            user_auth_tuple = authenticator.authenticate(self)</span><br><span class="line">        except exceptions.APIException:</span><br><span class="line">            self._not_authenticated()</span><br><span class="line">            raise</span><br><span class="line"></span><br><span class="line">        if user_auth_tuple is not None:</span><br><span class="line">            self._authenticator = authenticator</span><br><span class="line">            self.user, self.auth = user_auth_tuple</span><br><span class="line">            return</span><br></pre></td></tr></table></figure><p>在这里<code>self.authenticators</code>实际上是<code>get_authenticators</code>方法执行完成后返回的对象列表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Request(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, request, parsers=None, authenticators=None,</span><br><span class="line">                 negotiator=None, parser_context=None):</span><br><span class="line">        assert isinstance(request, HttpRequest), (</span><br><span class="line">            &apos;The `request` argument must be an instance of &apos;</span><br><span class="line">            &apos;`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.&apos;</span><br><span class="line">            .format(request.__class__.__module__, request.__class__.__name__)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self._request = request</span><br><span class="line">        self.parsers = parsers or ()</span><br><span class="line">        self.authenticators = authenticators or ()</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>循环认证的对象列表,<code>执行每一个认证方法的类中的authenticate方法</code>，得到通过认证的用户及用户的口令的元组，并返回元组完成认证的流程</p><p>在<code>_authenticate</code>方法中使用了try/except方法来捕获authenticate方法可能出现的异常</p><p>如果出现异常,就调用<code>_not_authenticated</code>方法来设置返回元组中的用户及口令并终止程序继续运行</p><p>总结，Django restframework的认证流程如下图</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180825184058007-932847314.jpg" alt="img"></p><h2 id="Django-restframework内置的认证类"><a href="#Django-restframework内置的认证类" class="headerlink" title="Django restframework内置的认证类"></a>Django restframework内置的认证类</h2><p>在上面的项目例子中，在UsersView的get方法中，打印<code>authentication_classes</code>和<code>request._user</code>的值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserView(APIView):</span><br><span class="line">    # authentication_classes = [MyAuthentication,]</span><br><span class="line"></span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        print(&apos;authentication_classes:&apos;, self.authentication_classes)</span><br><span class="line">        print(request._user)</span><br><span class="line">        return HttpResponse(&quot;UserView GET&quot;)</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authentication_classes: [&lt;class &apos;rest_framework.authentication.SessionAuthentication&apos;&gt;, &lt;class &apos;rest_framework.authentication.BasicAuthentication&apos;&gt;]</span><br><span class="line">AnonymousUser</span><br></pre></td></tr></table></figure><p>由此可以知道,<code>authentication_classes</code>默认是Django restframework内置的认证类，而request._user为AnonymousUser,因为发送GET请求，用户没有进行登录认证，所以为匿名用户</p><p>在视图函数中导入这两个类,再查看这两个类的源码,可以知道</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BasicAuthentication(BaseAuthentication):</span><br><span class="line"></span><br><span class="line">    www_authenticate_realm = &apos;api&apos; </span><br><span class="line"></span><br><span class="line">    def authenticate(self, request):</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_credentials(self, userid, password):</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">class SessionAuthentication(BaseAuthentication):</span><br><span class="line"></span><br><span class="line">    def authenticate(self, request):</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def enforce_csrf(self, request):</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">class TokenAuthentication(BaseAuthentication):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>从上面的源码可以发现,这个文件中不仅定义了<code>SessionAuthentication</code>和<code>BasicAuthentication</code>这两个类,</p><p>相关的类还有<code>TokenAuthentication</code>,而且这三个认证相关的类都是继承自<code>BaseAuthentication</code>类</p><p>从上面的源码可以大概知道,这三个继承自<code>BaseAuthentication</code>的类是Django restframework内置的认证方式.</p><h2 id="自定义认证功能"><a href="#自定义认证功能" class="headerlink" title="自定义认证功能"></a>自定义认证功能</h2><p>在上面我们知道,Request会调用认证相关的类及方法,<code>APIView</code>会设置认证相关的类及方法</p><p>所以如果想自定义认证功能,只需要重写<code>authenticate</code>方法及<code>authentication_classes</code>的对象列表即可</p><p>修改上面的例子的views.py文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework import exceptions</span><br><span class="line"></span><br><span class="line">TOKEN_LIST = [  # 定义token_list</span><br><span class="line">    &apos;aabbcc&apos;,</span><br><span class="line">    &apos;ddeeff&apos;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">class UserAuthView(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        tk = request._request.GET.get(&quot;tk&quot;)  # request._request为原生的request</span><br><span class="line"></span><br><span class="line">        if tk in TOKEN_LIST:</span><br><span class="line">            return (tk, None)  # 返回一个元组</span><br><span class="line">        raise exceptions.AuthenticationFailed(&quot;用户认证失败&quot;)</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        # 如果不定义authenticate_header方法会抛出异常</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    authentication_classes = [UserAuthView, ]</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        print(request.user)</span><br><span class="line"></span><br><span class="line">        return HttpResponse(&quot;UserView GET&quot;)</span><br></pre></td></tr></table></figure><p>启动项目,在浏览器中输入<code>http://127.0.0.1:8000/users/?tk=aabbcc</code>,然后回车,在服务端后台会打印</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aabbcc</span><br></pre></td></tr></table></figure><p>把浏览器中的url换为<code>http://127.0.0.1:8000/users/?tk=ddeeff</code>,后台打印信息则变为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ddeeff</span><br></pre></td></tr></table></figure><p>这样就实现REST framework的自定义认证功能</p><h2 id="Django-restframework认证的扩展"><a href="#Django-restframework认证的扩展" class="headerlink" title="Django restframework认证的扩展"></a>Django restframework认证的扩展</h2><h3 id="基于Token进行用户认证"><a href="#基于Token进行用户认证" class="headerlink" title="基于Token进行用户认证"></a>基于Token进行用户认证</h3><p>修改上面的项目，在urls.py文件中添加一条路由记录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&apos;^admin/&apos;, admin.site.urls),</span><br><span class="line">    url(r&apos;^users/&apos;,views.UsersView.as_view()),</span><br><span class="line">    url(r&apos;^auth/&apos;,views.AuthView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>修改视图函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render,HttpResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line"></span><br><span class="line">def gen_token(username):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    利用时间和用户名生成用户token</span><br><span class="line">    :param username: </span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import time</span><br><span class="line">    import hashlib</span><br><span class="line">    ctime=str(time.time())</span><br><span class="line">    hash=hashlib.md5(username.encode(&quot;utf-8&quot;))</span><br><span class="line">    hash.update(ctime.encode(&quot;utf-8&quot;))</span><br><span class="line">    return hash.hexdigest()</span><br><span class="line"></span><br><span class="line">class AuthView(APIView):</span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        获取用户提交的用户名和密码，如果用户名和密码正确，则生成token，并返回给用户</span><br><span class="line">        :param request:</span><br><span class="line">        :param args:</span><br><span class="line">        :param kwargs:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = &#123;&apos;code&apos;: 1000, &apos;msg&apos;: None&#125;</span><br><span class="line">        user = request.data.get(&quot;user&quot;)</span><br><span class="line">        pwd = request.data.get(&quot;pwd&quot;)</span><br><span class="line"></span><br><span class="line">        from app01 import models</span><br><span class="line">        user_obj = models.UserInfo.objects.filter(user=user, pwd=pwd).first()</span><br><span class="line"></span><br><span class="line">        if user_obj:</span><br><span class="line">            token = gen_token(user) # 生成用户口令</span><br><span class="line"></span><br><span class="line">            # 如果数据库中存在口令则更新,如果数据库中不存在口令则创建用户口令</span><br><span class="line">            models.Token.objects.update_or_create(user=user_obj, defaults=&#123;&apos;token&apos;: token&#125;)</span><br><span class="line">            print(&quot;user_token:&quot;, token)</span><br><span class="line">            res[&apos;code&apos;] = 1001</span><br><span class="line">            res[&apos;token&apos;] = token</span><br><span class="line">        else:</span><br><span class="line">            res[&apos;msg&apos;] = &quot;用户名或密码错误&quot;</span><br><span class="line"></span><br><span class="line">        return JsonResponse(res)</span><br><span class="line">    </span><br><span class="line">class UserAuthView(BaseAuthentication):</span><br><span class="line">    def authenticate(self,request):</span><br><span class="line">        tk=request.query_params.GET.get(&quot;tk&quot;)   # 获取请求头中的用户token</span><br><span class="line"></span><br><span class="line">        from app01 import models</span><br><span class="line"></span><br><span class="line">        token_obj=models.Token.objects.filter(token=tk).first()</span><br><span class="line"></span><br><span class="line">        if token_obj:   # 用户数据库中已经存在用户口令返回认证元组</span><br><span class="line">            return (token_obj.user,token_obj)</span><br><span class="line"></span><br><span class="line">        raise exceptions.AuthenticationFailed(&quot;认证失败&quot;)</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self,request):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class UsersView(APIView):</span><br><span class="line">    authentication_classes = [UserAuthView,]</span><br><span class="line"></span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line"></span><br><span class="line">        return HttpResponse(&quot;.....&quot;)</span><br></pre></td></tr></table></figure><p>创建用户数据库的类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class UserInfo(models.Model):</span><br><span class="line">    user=models.CharField(max_length=32)</span><br><span class="line">    pwd=models.CharField(max_length=64)</span><br><span class="line">    email=models.CharField(max_length=64)</span><br><span class="line"></span><br><span class="line">class Token(models.Model):</span><br><span class="line">    user=models.OneToOneField(UserInfo)</span><br><span class="line">    token=models.CharField(max_length=64)</span><br></pre></td></tr></table></figure><p>创建数据库,并添加两条用户记录</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201711/1133627-20171126000140781-1551141195.png" alt="img"></p><p>再创建一个test_client.py文件,来发送post请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">response=requests.post(</span><br><span class="line">    url=&quot;http://127.0.0.1:8000/auth/&quot;,</span><br><span class="line">    data=&#123;&apos;user&apos;:&apos;user1&apos;,&apos;pwd&apos;:&apos;user123&apos;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(&quot;response_text:&quot;,response.text)</span><br></pre></td></tr></table></figure><p>启动Django项目,运行test_client.py文件,则项目的响应信息为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response_text: &#123;&quot;code&quot;: 1001, &quot;msg&quot;: null, &quot;token&quot;: &quot;eccd2d256f44cb25b58ba602fe7eb42d&quot;&#125;</span><br></pre></td></tr></table></figure><p>由此,就完成了自定义的基于token的用户认证</p><p>如果想在项目中使用自定义的认证方式时,可以在<code>authentication_classes</code>继承刚才的认证的类即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authentication_classes = [UserAuthView,]</span><br></pre></td></tr></table></figure><h2 id="全局自定义认证"><a href="#全局自定义认证" class="headerlink" title="全局自定义认证"></a>全局自定义认证</h2><p>在正常的项目中，一个用户登录成功之后，进入自己的主页，可以看到很多内容，比如用户的订单，用户的收藏，用户的主页等</p><p>此时，难倒要在每个视图类中都定义authentication_classes，然后在authentication_classes中追加自定义的认证类吗？</p><p>通过对Django restframework认证的源码分析知道，可以直接在项目的settings.py配置文件中引入自定义的认证类，即可以对所有的url进行用户认证流程</p><p>在应用app01目录下创建utils包，在utils包下创建auth.py文件，内容为自定义的认证类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework import exceptions</span><br><span class="line">from api import models</span><br><span class="line"></span><br><span class="line">class Authtication(object):</span><br><span class="line">    def authenticate(self,request):</span><br><span class="line">        token = request._request.GET.get(&quot;token&quot;)       # 获取浏览器传递的token</span><br><span class="line">        token_obj = models.UserToken.objects.filter(token=token).first()    # 到数据库中进行token查询，判断用户是否通过认证</span><br><span class="line">        if not token_obj:</span><br><span class="line">            raise exceptions.AuthenticationFailed(&quot;用户认证失败&quot;)</span><br><span class="line"></span><br><span class="line">        # restframework会将元组赋值给request,以供后面使用</span><br><span class="line">        return (token_obj.user,token_obj)</span><br><span class="line">    </span><br><span class="line">    # 必须创建authenticate_header方法，否则会抛出异常</span><br><span class="line">    def authenticate_header(self,request):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>在settings.py文件中添加内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    &apos;DEFAULT_AUTHENTICATION_CLASSES&apos;:[&apos;app01.utils.auth.Authtication&apos;,]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改views.py文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line"></span><br><span class="line">def gen_token(username):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    利用时间和用户名生成用户token</span><br><span class="line">    :param username:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import time</span><br><span class="line">    import hashlib</span><br><span class="line">    ctime = str(time.time())</span><br><span class="line">    hash = hashlib.md5(username.encode(&quot;utf-8&quot;))</span><br><span class="line">    hash.update(ctime.encode(&quot;utf-8&quot;))</span><br><span class="line">    return hash.hexdigest()</span><br><span class="line"></span><br><span class="line">class AuthView(APIView):</span><br><span class="line">    authentication_classes = []     # 在这里定义authentication_classes后，用户访问auth页面不需要进行认证</span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        获取用户提交的用户名和密码，如果用户名和密码正确，则生成token，并返回给用户</span><br><span class="line">        :param request:</span><br><span class="line">        :param args:</span><br><span class="line">        :param kwargs:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = &#123;&apos;code&apos;: 1000, &apos;msg&apos;: None&#125;</span><br><span class="line">        user = request.data.get(&quot;user&quot;)</span><br><span class="line">        pwd = request.data.get(&quot;pwd&quot;)</span><br><span class="line"></span><br><span class="line">        from app01 import models</span><br><span class="line">        user_obj = models.UserInfo.objects.filter(user=user, pwd=pwd).first()</span><br><span class="line"></span><br><span class="line">        if user_obj:</span><br><span class="line">            token = gen_token(user)  # 生成用户口令</span><br><span class="line"></span><br><span class="line">            # 如果数据库中存在口令则更新,如果数据库中不存在口令则创建用户口令</span><br><span class="line">            models.Token.objects.update_or_create(user=user_obj, defaults=&#123;&apos;token&apos;: token&#125;)</span><br><span class="line">            print(&quot;user_token:&quot;, token)</span><br><span class="line">            res[&apos;code&apos;] = 1001</span><br><span class="line">            res[&apos;token&apos;] = token</span><br><span class="line">        else:</span><br><span class="line">            res[&apos;msg&apos;] = &quot;用户名或密码错误&quot;</span><br><span class="line"></span><br><span class="line">        return JsonResponse(res)</span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        return HttpResponse(&quot;UserView GET&quot;)</span><br><span class="line"></span><br><span class="line">class OrderView(APIView):</span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&quot;OrderView GET&quot;)</span><br></pre></td></tr></table></figure><p>启动项目，使用POSTMAN向<code>http://127.0.0.1:8000/order/?token=eccd2d256f44cb25b58ba602fe7eb42d</code>和<code>http://127.0.0.1:8000/user/?token=eccd2d256f44cb25b58ba602fe7eb42d</code>发送GET请求，响应结果如下</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225750139-1198840701.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225755562-137171019.png" alt="img"></p><p>在url中不带token,使用POSTMAN向<code>http://127.0.0.1:8000/order/</code>和<code>http://127.0.0.1:8000/user/</code>发送GET请求，则会出现<code>&quot;认证失败&quot;</code>的提示</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225715170-517425689.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225720650-323643037.png" alt="img"></p><p>由此可以知道，在settings.py配置文件中配置自定义的认证类也可以实现用户认证功能</p><h2 id="配置匿名用户"><a href="#配置匿名用户" class="headerlink" title="配置匿名用户"></a>配置匿名用户</h2><p>修改settings.py文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    &apos;DEFAULT_AUTHENTICATION_CLASSES&apos;: [&apos;app01.utils.auth.Authtication&apos;, ],</span><br><span class="line">    &apos;UNAUTHENTICATED_USER&apos;: lambda :&quot;匿名用户&quot;,     # 用户未登录时显示的名称</span><br><span class="line">    &apos;UNAUTHENTICATED_TOKEN&apos;: lambda :&quot;无效token&quot;, # 用户未登录时打印的token名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改views.py文件中的OrderView类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OrderView(APIView):</span><br><span class="line">    authentication_classes = []         # authentication_classes为空列表表示视图类不进行认证</span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return HttpResponse(&quot;OrderView GET&quot;)</span><br></pre></td></tr></table></figure><p>使用浏览器向<code>http://127.0.0.1:8000/order/</code>发送GET请求，后台打印</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225705126-1550086890.png" alt="img"></p><p>这说明在settings.py文件中配置的匿名用户和匿名用户的token起到作用</p><blockquote><p>建议把匿名用户及匿名用户的token都设置为:None</p></blockquote><h2 id="Django-restframework内置的认证类-1"><a href="#Django-restframework内置的认证类-1" class="headerlink" title="Django restframework内置的认证类"></a>Django restframework内置的认证类</h2><p>从rest_framework中导入authentication</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework import authentication</span><br></pre></td></tr></table></figure><p>可以看到Django restframework内置的认证类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BaseAuthentication(object):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BasicAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_credentials(self, userid, password, request=None):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SessionAuthentication(BaseAuthentication):</span><br><span class="line"></span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def enforce_csrf(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TokenAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_credentials(self, key):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RemoteUserAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>可以看到，Django restframework内置的认证包含下面的四种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BasicAuthentication</span><br><span class="line">SessionAuthentication</span><br><span class="line">TokenAuthentication</span><br><span class="line">RemoteUserAuthentication</span><br></pre></td></tr></table></figure><p>而这四种认证类都继承自<code>BaseAuthentication</code>，<code>在BaseAuthentication中定义了两个方法：authenticate和authenticate_header</code></p><p>总结：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了让认证更规范，自定义的认证类要继承 BaseAuthentication类</span><br><span class="line">自定义认证类必须要实现authenticate和authenticate_header方法</span><br><span class="line">authenticate_header方法的作用：在认证失败的时候，给浏览器返回的响应头，可以直接pass，不实现authenticate_header程序会抛出异常</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL分页limit速度太慢的优化方法</title>
      <link href="/2018/11/19/MySQL%E5%88%86%E9%A1%B5limit%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/19/MySQL%E5%88%86%E9%A1%B5limit%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="limit用法"><a href="#limit用法" class="headerlink" title="limit用法"></a>limit用法</h2><p>在我们使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？不用担心，mysql已经为我们提供了这样一个功能。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的<code>偏移量</code>，第二个参数指定返回记录行的最大数目。<code>初始记录行的偏移量是 0(而不是 1)</code>： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</span><br></pre></td></tr></table></figure><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</span><br></pre></td></tr></table></figure><p>如果只给定一个参数，它表示返回最大的记录行数目： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行</span><br></pre></td></tr></table></figure><p>换句话说，<code>LIMIT n</code> 等价于<code>LIMIT 0,n</code>。</p><h2 id="Mysql的分页查询语句的性能分析"><a href="#Mysql的分页查询语句的性能分析" class="headerlink" title="Mysql的分页查询语句的性能分析"></a><strong>Mysql的分页查询语句的性能分析</strong></h2><p>MySql分页sql语句，如果和MSSQL的TOP语法相比，那么MySQL的LIMIT语法要显得优雅了许多。使用它来分页是再自然不过的事情了。</p><h3 id="最基本的分页方式："><a href="#最基本的分页方式：" class="headerlink" title="最基本的分页方式："></a><strong>最基本的分页方式：</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ...</span><br></pre></td></tr></table></figure><p>在中小数据量的情况下，这样的SQL足够用了，唯一需要注意的问题就是确保使用了索引：举例来说，如果实际SQL类似下面语句，那么在category_id, id两列上建立复合索引比较好：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10</span><br></pre></td></tr></table></figure><h3 id="子查询的分页方式："><a href="#子查询的分页方式：" class="headerlink" title="子查询的分页方式："></a><strong>子查询的分页方式：</strong></h3><p>随着数据量的增加，页数会越来越多，查看后几页的SQL就可能类似：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 10</span><br></pre></td></tr></table></figure><p>一言以蔽之，就是越往后分页，<code>LIMIT语句的偏移量就会越大，速度也会明显变慢</code>。</p><p>此时，我们可以通过子查询的方式来提高分页效率，大致如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM articles WHERE id &gt;= </span><br><span class="line">(SELECT id FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 1) LIMIT 10</span><br></pre></td></tr></table></figure><h3 id="JOIN分页方式"><a href="#JOIN分页方式" class="headerlink" title="JOIN分页方式"></a>JOIN分页方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `content` AS t1 </span><br><span class="line">JOIN (SELECT id FROM `content` ORDER BY id desc LIMIT &quot;.($page-1)*$pagesize.&quot;, 1) AS t2 </span><br><span class="line">WHERE t1.id &lt;= t2.id ORDER BY t1.id desc LIMIT $pagesize;</span><br></pre></td></tr></table></figure><p>经过我的测试，join分页和子查询分页的效率基本在一个等级上，消耗的时间也基本一致。 explain SQL语句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id select_type table type possible_keys key key_len ref rows Extra</span><br><span class="line">1 PRIMARY &lt;derived2&gt; system NULL NULL NULL NULL 1 </span><br><span class="line">1 PRIMARY t1 range PRIMARY PRIMARY 4 NULL 6264 Using where</span><br><span class="line">2 DERIVED content index NULL PRIMARY 4 NULL 27085 Using index</span><br></pre></td></tr></table></figure><p>为什么会这样呢？因为子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。</p><p>实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python——回顾常用的库</title>
      <link href="/2018/11/16/Python%E2%80%94%E2%80%94%E5%9B%9E%E9%A1%BE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%93/"/>
      <url>/2018/11/16/Python%E2%80%94%E2%80%94%E5%9B%9E%E9%A1%BE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>这些最基础的面试想不起来会很尴尬</p><a id="more"></a><h2 id="Python-map-函数"><a href="#Python-map-函数" class="headerlink" title="Python map() 函数"></a>Python map() 函数</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p><p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><p>语法</p><h3 id="map-函数语法："><a href="#map-函数语法：" class="headerlink" title="map() 函数语法："></a>map() 函数语法：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>function – 函数</li><li>iterable – 一个或多个序列</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Python 2.x 返回列表。</p><p>Python 3.x 返回迭代器。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例展示了 map() 的使用方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span> :</span>            <span class="comment"># 计算平方数</span></span><br><span class="line"><span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;map(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 计算列表各个元素的平方</span></span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">&gt;&gt;&gt;map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])  <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><h3 id="提供了两个列表，对相同位置的列表数据进行相加"><a href="#提供了两个列表，对相同位置的列表数据进行相加" class="headerlink" title="提供了两个列表，对相同位置的列表数据进行相加"></a>提供了两个列表，对相同位置的列表数据进行相加</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line">&gt;&gt;&gt;[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><h2 id="Python-filter-函数"><a href="#Python-filter-函数" class="headerlink" title="Python filter() 函数"></a>Python filter() 函数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><blockquote><p><strong>注意:</strong> Pyhton2.7 返回列表，Python3.x 返回迭代器对象，具体内容可以查看：<a href="http://www.runoob.com/python3/python3-func-filter.html" target="_blank" rel="noopener">Python3 filter() 函数</a></p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>以下是 filter() 方法的语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter(function, iterable)</span><br></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li>function – 判断函数。</li><li>iterable – 可迭代对象。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>返回列表。</p><hr><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>以下展示了使用 filter 函数的实例：</p><h3 id="过滤出列表中的所有奇数："><a href="#过滤出列表中的所有奇数：" class="headerlink" title="过滤出列表中的所有奇数："></a>过滤出列表中的所有奇数：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">newlist = filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]) </span><br><span class="line">print(newlist)</span><br></pre></td></tr></table></figure><p>输出结果 ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="过滤出1-100中平方根是整数的数："><a href="#过滤出1-100中平方根是整数的数：" class="headerlink" title="过滤出1~100中平方根是整数的数："></a>过滤出1~100中平方根是整数的数：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-   </span></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_sqr</span><span class="params">(x)</span>:</span>     </span><br><span class="line"><span class="keyword">return</span> math.sqrt(x) % <span class="number">1</span> == <span class="number">0</span></span><br><span class="line">newlist = filter(is_sqr, range(<span class="number">1</span>, <span class="number">101</span>)) </span><br><span class="line">print(newlist)</span><br></pre></td></tr></table></figure><p>输出结果 ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><h2 id="Python-reduce-函数"><a href="#Python-reduce-函数" class="headerlink" title="Python reduce() 函数"></a>Python reduce() 函数</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><strong>reduce()</strong> 函数会对参数序列中元素进行累积。</p><p>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>reduce() 函数语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul><li>function – 函数，有两个参数</li><li>iterable – 可迭代对象</li><li>initializer – 可选，初始参数</li></ul><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>返回函数计算结果。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>以下实例展示了 reduce() 的使用方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span> :</span>            <span class="comment"># 两数相加 ...     </span></span><br><span class="line"><span class="keyword">return</span> x + y ...  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 计算列表和：1+2+3+4+5 15 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  <span class="comment"># 使用 lambda 匿名函数 15</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7环境 Mongodb 的安装及远程连接</title>
      <link href="/2018/11/13/Centos7%E7%8E%AF%E5%A2%83-Mongodb-%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
      <url>/2018/11/13/Centos7%E7%8E%AF%E5%A2%83-Mongodb-%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>此流程仅本人测试，没有报错。折腾了一会，出了解决不了的BUG还是卸载重装比较方便。</p><a id="more"></a><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>① 把Mongo的安装配置添加的yum中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/yum.repos.d/mongodb-org-4.0.repo</span><br></pre></td></tr></table></figure><p>把下面配置复制到文件中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure><p>② 运行安装命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure><p>③ 设置数据储存路径<br>默认下mongo的储存路径是 /data/db ，如果此时系统中没有这个文件，是不会启动成功的。所以要手动穿件这个文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/db</span><br></pre></td></tr></table></figure><p>④ 启动Mongo</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mongod start</span><br></pre></td></tr></table></figure><p>⑤ 连接本地的Mongo</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><p>此时Mongo的安装已经完成，上面日志中有警告啥的可以通过配置解决，但不影响使用。</p><p>参考资料：<a href="https://docs.mongodb.com/master/mongo/" target="_blank" rel="noopener">https://docs.mongodb.com/master/mongo/</a></p><h2 id="二、Mongo的远程连接"><a href="#二、Mongo的远程连接" class="headerlink" title="二、Mongo的远程连接"></a>二、Mongo的远程连接</h2><p>注意：Mongo的远程连接需要打开权限控制<br>本教程是不过多涉及权限问题，权限详情可参考：<br><a href="http://www.cnblogs.com/hanyinglong/archive/2016/07/25/5704320.html" target="_blank" rel="noopener">http://www.cnblogs.com/hanyinglong/archive/2016/07/25/5704320.html</a></p><p>① 添加新的用户<br>首先添加个管理员账号（root权限）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">   user:<span class="string">"root"</span>,</span><br><span class="line">   pwd:<span class="string">"password"</span>,</span><br><span class="line">   roles:[&#123;<span class="attr">role</span>:<span class="string">"root"</span>,<span class="attr">db</span>:<span class="string">"admin"</span>&#125;]</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>添加个普通账号（读写权限）： (需要先用root登陆)<br>（命令中的db 代表用户所分配的数据库）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">                　　user:<span class="string">"hyc"</span>,                                   </span><br><span class="line">                　　pwd:<span class="string">"123456"</span>,</span><br><span class="line">                　　roles:[&#123;<span class="attr">role</span>:<span class="string">"readWrite"</span>,<span class="attr">db</span>:<span class="string">"test"</span>&#125;]</span><br><span class="line">           　　&#125;);</span><br></pre></td></tr></table></figure><p>② 修改配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/mongod.conf</span><br></pre></td></tr></table></figure><p>注释掉：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bindIp: 127.0.0.1  # Listen to local interface only, comment to listen on all interfaces.</span></span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">    authorization: enabled</span><br></pre></td></tr></table></figure><p>③ 重启Mongo 远程连接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mongod restart</span><br></pre></td></tr></table></figure><p>④ 开启端口访问</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --permanent --add-port=27017/tcp; firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>打开ROBO（mongo 可视化工具）：</p><p><a href="https://imgchr.com/i/iXEZcD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/13/iXEZcD.png" alt="iXEZcD.png"></a></p><p><img src="https://s1.ax1x.com/2018/11/13/iXArOH.png" alt="iXArOH.png"></p><h2 id="最后点击Save就可以愉快的使用啦"><a href="#最后点击Save就可以愉快的使用啦" class="headerlink" title="最后点击Save就可以愉快的使用啦"></a>最后点击Save就可以愉快的使用啦</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>无题1</title>
      <link href="/2018/11/09/%E6%97%A0%E9%A2%981/"/>
      <url>/2018/11/09/%E6%97%A0%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2018/11/09/ibtcXq.jpg" alt="ibtcXq.jpg"></p><p>今天投了十几家简历，还没有回音</p><a id="more"></a><p>晚上把做的几个项目的流程再熟悉一下</p><p>感觉简历还是有问题，明天找老师还有同学请教</p><p>感觉压力越来越大了</p><p>本来还有很多东西要学，但是状态有点差</p><p>负面情绪有点多了，需要及时调节过来，毕竟也没人可以依靠了</p><hr><p>入职第三天</p><p>后面还要继续努力</p><p>明天把数据库结构给理好</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django——微信消息推送</title>
      <link href="/2018/11/08/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
      <url>/2018/11/08/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微信公众号的分类</p><a id="more"></a><ul><li><p>微信消息推送</p><ul><li><p>公众号</p><ul><li><p>已认证公众号</p></li><li><p>服务号</p></li><li><p>已认证服务号</p></li><li><p>企业号</p></li></ul></li></ul></li></ul><p>基于：微信认证服务号 主动推送微信消息。<br>前提：关注服务号<br>环境：沙箱环境</p><p>沙箱环境地址： <a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a></p><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><ol><li><p>注册开发者账号</p><p>获得：appID、appsecret</p><p>网页授权获取用户基本信息：47.98.134.86 或 域名 </p></li><li><p>关注公众号（已认证的服务号）</p><p><img src="https://s1.ax1x.com/2018/11/08/iHwTKA.png" alt="iHwTKA.png"></p></li><li><p>生成二维码，用户扫描；<br> 将用户信息发送给微信，微信再将数据发送给设置redirect_uri地址(md5值)</p><p><a href="https://imgchr.com/i/iH09rn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/iH09rn.png" alt="iH09rn.png"></a></p></li><li><p>回调地址：47.98.134.86/callback/</p><p><img src="https://s1.ax1x.com/2018/11/08/iHfnQP.png" alt="iHfnQP.png"></p><ul><li>授权 </li><li>用户md5</li><li>获取wx_id<br>在数据库中更新设置：wx_id </li></ul></li><li><p>发送消息（模板消息）</p><ul><li><p>wx_id </p></li><li><p>access_token（2小时有效期）</p><p><img src="https://s1.ax1x.com/2018/11/08/iHfZRI.png" alt="iHfZRI.png"></p></li></ul></li></ol><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>models.py </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    username = models.CharField(<span class="string">"用户名"</span>, max_length=<span class="number">64</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    password = models.CharField(<span class="string">"密码"</span>, max_length=<span class="number">64</span>)</span><br><span class="line">    uid = models.CharField(verbose_name=<span class="string">'个人唯一ID'</span>,max_length=<span class="number">64</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    wx_id = models.CharField(verbose_name=<span class="string">"微信ID"</span>, max_length=<span class="number">128</span>, blank=<span class="keyword">True</span>, null=<span class="keyword">True</span>, db_index=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 创建用户时，为用户自动生成个人唯一ID</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.pk:</span><br><span class="line">            m = hashlib.md5()</span><br><span class="line">            m.update(self.username.encode(encoding=<span class="string">"utf-8"</span>))</span><br><span class="line">            self.uid = m.hexdigest()</span><br><span class="line">        super(UserInfo, self).save(*args, **kwargs)</span><br></pre></td></tr></table></figure><p>settings.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WECHAT_CONFIG = &#123;</span><br><span class="line">    <span class="string">'app_id'</span>: <span class="string">'wx3d0d44e8d59b5b8c'</span>,</span><br><span class="line">    <span class="string">'appsecret'</span>: <span class="string">'a4ede68946e9a2e7e36480d23865a64d'</span>,</span><br><span class="line">    <span class="string">'redirect_uri'</span>: <span class="string">'http://47.106.237.76/callback/'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>views.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, redirect, HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="comment"># 沙箱环境地质：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    obj = models.UserInfo.objects.get(id=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,&#123;<span class="string">'obj'</span>:obj&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">        user_info = request.session.get(<span class="string">'user_info'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> user_info:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">'/login/'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户登录</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># models.UserInfo.objects.create(username='luffy',password=123)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        user = request.POST.get(<span class="string">'user'</span>)</span><br><span class="line">        pwd = request.POST.get(<span class="string">'pwd'</span>)</span><br><span class="line">        obj = models.UserInfo.objects.filter(username=user, password=pwd).first()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> obj:</span><br><span class="line">            request.session[<span class="string">'user_info'</span>] = &#123;<span class="string">'id'</span>: obj.id, <span class="string">'name'</span>: obj.username, <span class="string">'uid'</span>: obj.uid&#125;</span><br><span class="line">            <span class="keyword">return</span> redirect(to=<span class="string">'/bind/'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'login.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户登录后，关注公众号，并绑定个人微信（用于以后消息推送）</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'bind.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind_qcode</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成二维码</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ret = &#123;<span class="string">'code'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        access_url = <span class="string">"https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#123;appid&#125;&amp;redirect_uri=&#123;redirect_uri&#125;&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=&#123;state&#125;#wechat_redirect"</span></span><br><span class="line">        access_url = access_url.format(</span><br><span class="line">            appid=settings.WECHAT_CONFIG[<span class="string">"app_id"</span>], <span class="comment"># 'wx89085e915d351cae',</span></span><br><span class="line">            redirect_uri=settings.WECHAT_CONFIG[<span class="string">"redirect_uri"</span>], <span class="comment"># 'http://47.93.4.198/test/',</span></span><br><span class="line">            state=request.session[<span class="string">'user_info'</span>][<span class="string">'uid'</span>] <span class="comment"># 为当前用户生成MD5值</span></span><br><span class="line">        )</span><br><span class="line">        ret[<span class="string">'data'</span>] = access_url</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        ret[<span class="string">'code'</span>] = <span class="number">1001</span></span><br><span class="line">        ret[<span class="string">'msg'</span>] = str(e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户在手机微信上扫码后，微信自动调用该方法。</span></span><br><span class="line"><span class="string">    用于获取扫码用户的唯一ID，以后用于给他推送消息。</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    code = request.GET.get(<span class="string">"code"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用户md5值</span></span><br><span class="line">    state = request.GET.get(<span class="string">"state"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取该用户openId(用户唯一，用于给用户发送消息)</span></span><br><span class="line">    res = requests.get(</span><br><span class="line">        url=<span class="string">"https://api.weixin.qq.com/sns/oauth2/access_token"</span>,</span><br><span class="line">        params=&#123;</span><br><span class="line">            <span class="string">"appid"</span>: settings.WECHAT_CONFIG[<span class="string">'app_id'</span>],</span><br><span class="line">            <span class="string">"secret"</span>: settings.WECHAT_CONFIG[<span class="string">'appsecret'</span>],</span><br><span class="line">            <span class="string">"code"</span>: code,</span><br><span class="line">            <span class="string">"grant_type"</span>: <span class="string">'authorization_code'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ).json()</span><br><span class="line">    <span class="comment"># 获取的到openid表示用户授权成功</span></span><br><span class="line">    openid = res.get(<span class="string">"openid"</span>)</span><br><span class="line">    print(openid)</span><br><span class="line">    <span class="keyword">if</span> openid:</span><br><span class="line">        models.UserInfo.objects.filter(uid=state).update(wx_id=openid)</span><br><span class="line">        response = <span class="string">"&lt;h1&gt;授权成功 %s &lt;/h1&gt;"</span> % openid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        response = <span class="string">"&lt;h1&gt;用户扫码之后，手机上的提示&lt;/h1&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendmsg</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_access_token</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取微信全局接口的凭证(默认有效期俩个小时)</span></span><br><span class="line"><span class="string">        如果不每天请求次数过多, 通过设置缓存即可</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = requests.get(</span><br><span class="line">            url=<span class="string">"https://api.weixin.qq.com/cgi-bin/token"</span>,</span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="string">"grant_type"</span>: <span class="string">"client_credential"</span>,</span><br><span class="line">                <span class="string">"appid"</span>: settings.WECHAT_CONFIG[<span class="string">'app_id'</span>],</span><br><span class="line">                <span class="string">"secret"</span>: settings.WECHAT_CONFIG[<span class="string">'appsecret'</span>],</span><br><span class="line">            &#125;</span><br><span class="line">        ).json()</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">"access_token"</span>):</span><br><span class="line">            access_token = result.get(<span class="string">'access_token'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            access_token = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> access_token</span><br><span class="line"></span><br><span class="line">    access_token = get_access_token()</span><br><span class="line"></span><br><span class="line">    openid = models.UserInfo.objects.get(id=<span class="number">1</span>).wx_id</span><br><span class="line">    print(openid)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_custom_msg</span><span class="params">()</span>:</span></span><br><span class="line">        body = &#123;</span><br><span class="line">            <span class="string">"touser"</span>: openid,</span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="string">"text"</span>: &#123;</span><br><span class="line">                <span class="string">"content"</span>: <span class="string">'云姐好美呀'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.post(</span><br><span class="line">            url=<span class="string">"https://api.weixin.qq.com/cgi-bin/message/custom/send"</span>,</span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="string">'access_token'</span>: access_token</span><br><span class="line">            &#125;,</span><br><span class="line">            data=bytes(json.dumps(body, ensure_ascii=<span class="keyword">False</span>), encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 这里可根据回执code进行判定是否发送成功(也可以根据code根据错误信息)</span></span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_template_msg</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        发送模版消息</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = requests.post(</span><br><span class="line">            url=<span class="string">"https://api.weixin.qq.com/cgi-bin/message/template/send"</span>,</span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="string">'access_token'</span>: access_token</span><br><span class="line">            &#125;,</span><br><span class="line">            json=&#123;</span><br><span class="line">                <span class="string">"touser"</span>: openid,</span><br><span class="line">                <span class="string">"template_id"</span>: <span class="string">'NcN_W_aEIwu-FHyJx8djU99Z70AvwwGcEufXiTzj-NM'</span>,</span><br><span class="line">                <span class="string">"data"</span>: &#123;</span><br><span class="line">                    <span class="string">"first"</span>: &#123;</span><br><span class="line">                        <span class="string">"value"</span>: <span class="string">"冰姐"</span>,</span><br><span class="line">                        <span class="string">"color"</span>: <span class="string">"#173177"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"keyword1"</span>: &#123;</span><br><span class="line">                        <span class="string">"value"</span>: <span class="string">"美女"</span>,</span><br><span class="line">                        <span class="string">"color"</span>: <span class="string">"#173177"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        result = res.json()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment"># 在这里编辑要发送的函数中的内容</span></span><br><span class="line">    result = send_template_msg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.get(<span class="string">'errcode'</span>) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'发送成功'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'发送失败'</span>)</span><br></pre></td></tr></table></figure><h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><p>1登陆：</p><p><a href="https://imgchr.com/i/iHwYBq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/iHwYBq.png" alt="iHwYBq.png"></a></p><p>2客户扫码关注我们的公众号</p><p><a href="https://imgchr.com/i/iHwTKA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/iHwTKA.png" alt="iHwTKA.png"></a></p><p>为了获得用户的微信ID，我们需要客户再次扫码，向微信授权把ID给我们</p><p><a href="https://imgchr.com/i/iH09rn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/iH09rn.png" alt="iH09rn.png"></a></p><h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><p><a href="https://github.com/hyyc554/wxbox" target="_blank" rel="noopener">https://github.com/hyyc554/wxbox</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django——支付宝支付功能</title>
      <link href="/2018/11/08/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"/>
      <url>/2018/11/08/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>首先我们需要获得支付宝提供的权限与接口，在蚂蚁开放平台进行相关申请：<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a></p><p>申请支付宝账户权限<br><a id="more"></a></p><p><img src="https://s1.ax1x.com/2018/11/08/iHMqr4.png" alt="iHMqr4.png"></p><p>创建应用</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMIP0.png" alt="iHMIP0.png"></p><p>沙箱测试环境</p><p><img src="https://s1.ax1x.com/2018/11/08/iHM45q.png" alt="iHM45q.png"></p><p>appID：我的身份</p><p>支付宝网关：测试环境</p><p>获得相关的测试账号</p><p><img src="https://s1.ax1x.com/2018/11/08/iHQise.png" alt="iHQise.png"></p><p>商户账号、客户账号后面可以通过这两个账号来进行测试</p><p>沙箱钱包（也可以不下载，直接在网页上登陆测试账号进行支付测试）</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMoGV.png" alt="iHMoGV.png"></p><p>在安卓手机上进行安装</p><h2 id="获得SDK（pay-py）"><a href="#获得SDK（pay-py）" class="headerlink" title="获得SDK（pay.py）"></a>获得SDK（pay.py）</h2><p>就是加密算法</p><p>SDK（加密算法，阿里没有提供python版本，从github山获得）</p><p>官方</p><p>GIHUB（请注意浏览源码）——pay.py(依赖:pip install pycryptodome)</p><p>公钥私钥</p><p><img src="https://s1.ax1x.com/2018/11/08/iHM7xU.png" alt="iHM7xU.png"></p><p>在这里下载<br><img src="https://s1.ax1x.com/2018/11/08/iHMXZ9.png" alt="iHMXZ9.png"></p><p>运行<br><img src="https://s1.ax1x.com/2018/11/08/iHMbMF.png" alt="iHMbMF.png"></p><p><img src="https://s1.ax1x.com/2018/11/08/iHMLqJ.png" alt="iHMLqJ.png"></p><p>生成公钥私钥<br><img src="https://s1.ax1x.com/2018/11/08/iHMjaR.png" alt="iHMjaR.png"></p><p>完成上传</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMzPx.png" alt="iHMzPx.png"></p><p>应用公钥上传后自动生成支付宝公钥</p><p>在django文件中进行替换成自己的key</p><p><img src="C:\Users\Administrator.000\AppData\Roaming\Typora\typora-user-images\1541664121222.png" alt="1541664121222"></p><p>django程序</p><p>演示</p><p>1.运行</p><p>2.访问去支付</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMhan.png" alt="iHMhan.png"></p><p>3.支付页面</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMT2T.png" alt="iHMT2T.png"></p><p>4.登陆测试用户，完成支付</p><p><img src="https://s1.ax1x.com/2018/11/08/iHQpRK.png" alt="iHQpRK.png"></p><p><img src="https://s1.ax1x.com/2018/11/08/iHMvI1.png" alt="iHMvI1.png"></p><p>最终跳转到</p><p><img src="https://s1.ax1x.com/2018/11/08/iHQSG6.png" alt="iHQSG6.png"></p><p>说明功能正常</p><h2 id="Django实现"><a href="#Django实现" class="headerlink" title="Django实现"></a>Django实现</h2><p>代码结构</p><p><img src="https://s1.ax1x.com/2018/11/08/iHQ9xO.png" alt="iHQ9xO.png"></p><p>views.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,redirect,HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> utils.pay <span class="keyword">import</span> AliPay</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aliPay</span><span class="params">()</span>:</span></span><br><span class="line">    obj = AliPay(</span><br><span class="line">        appid=settings.APPID,</span><br><span class="line">        app_notify_url=settings.NOTIFY_URL,  <span class="comment"># 如果支付成功，支付宝会向这个地址发送POST请求（校验是否支付已经完成）</span></span><br><span class="line">        return_url=settings.RETURN_URL,  <span class="comment"># 如果支付成功，重定向回到你的网站的地址。</span></span><br><span class="line">        alipay_public_key_path=settings.PUB_KEY_PATH,  <span class="comment"># 支付宝公钥</span></span><br><span class="line">        app_private_key_path=settings.PRI_KEY_PATH,  <span class="comment"># 应用私钥</span></span><br><span class="line">        debug=<span class="keyword">True</span>,  <span class="comment"># 默认False,</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    alipay = aliPay()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对购买的数据进行加密</span></span><br><span class="line">    money = float(request.POST.get(<span class="string">'price'</span>))</span><br><span class="line">    out_trade_no = <span class="string">"x2"</span> + str(time.time())</span><br><span class="line">    <span class="comment"># 1. 在数据库创建一条数据：状态（待支付）</span></span><br><span class="line"></span><br><span class="line">    query_params = alipay.direct_pay(</span><br><span class="line">        subject=<span class="string">"充气式韩红"</span>,  <span class="comment"># 商品简单描述</span></span><br><span class="line">        out_trade_no= out_trade_no,  <span class="comment"># 商户订单号</span></span><br><span class="line">        total_amount=money,  <span class="comment"># 交易金额(单位: 元 保留俩位小数)</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    pay_url = <span class="string">"https://openapi.alipaydev.com/gateway.do?&#123;&#125;"</span>.format(query_params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirect(pay_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pay_result</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    支付完成后，跳转回的地址</span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    params = request.GET.dict()</span><br><span class="line">    sign = params.pop(<span class="string">'sign'</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    alipay = aliPay()</span><br><span class="line"></span><br><span class="line">    status = alipay.verify(params, sign)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> status:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'支付成功'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'支付失败'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_order</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    支付成功后，支付宝向该地址发送的POST请求（用于修改订单状态）</span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line">        body_str = request.body.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        post_data = parse_qs(body_str)</span><br><span class="line"></span><br><span class="line">        post_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> post_data.items():</span><br><span class="line">            post_dict[k] = v[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        alipay = aliPay()</span><br><span class="line"></span><br><span class="line">        sign = post_dict.pop(<span class="string">'sign'</span>, <span class="keyword">None</span>)</span><br><span class="line">        status = alipay.verify(post_dict, sign)</span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="comment"># 修改订单状态</span></span><br><span class="line">            out_trade_no = post_dict.get(<span class="string">'out_trade_no'</span>)</span><br><span class="line">            print(out_trade_no)</span><br><span class="line">            <span class="comment"># 2. 根据订单号将数据库中的数据进行更新</span></span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">'支付成功'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">'支付失败'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>settings.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支付相关配置</span></span><br><span class="line">APPID = <span class="string">"2016082500309412"</span></span><br><span class="line">NOTIFY_URL = <span class="string">"http://47.106.237.76:80/update_order/"</span></span><br><span class="line">RETURN_URL = <span class="string">"http://47.106.237.76:80/pay_result/"</span></span><br><span class="line">PRI_KEY_PATH = <span class="string">"keys/app_private_2048.txt"</span></span><br><span class="line">PUB_KEY_PATH = <span class="string">"keys/alipay_public_2048.txt"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在线教育平台——购物车功能实现</title>
      <link href="/2018/11/07/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/07/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>依赖软件：Django\redis</p><p>测试工具：postman<br><a id="more"></a></p><h2 id="redis中购物车数据存储结构"><a href="#redis中购物车数据存储结构" class="headerlink" title="redis中购物车数据存储结构"></a>redis中购物车数据存储结构</h2><ul><li>redis最外层的key的实际意义是”luffy_shopping_car_userid_courseid”，也就是最后的两个数字分别代表的用户ID与需要加入购物车的课程ID</li><li>每个单独的课程中，包含课程名称，课程图片，课程价格策略，当前选中策略。</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">redis: &#123;</span><br><span class="line">    "luffy_shopping_car_1_1":</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"title"</span>: <span class="string">"Linux基础"</span>,</span><br><span class="line">        <span class="attr">"img"</span>: <span class="string">"2.png"</span>,</span><br><span class="line">        <span class="attr">"policy"</span>: &#123;</span><br><span class="line">            <span class="attr">"2"</span>: &#123;</span><br><span class="line">                <span class="attr">"period"</span>: <span class="number">60</span>,</span><br><span class="line">                <span class="attr">"period_display"</span>: <span class="string">"2个月"</span>,</span><br><span class="line">                <span class="attr">"price"</span>: <span class="number">1500</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"default_policy"</span>: <span class="string">"2"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    "luffy_shopping_car_1_3": &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p><img src="E:\chromedown\条件结构流程图.png" alt="条件结构流程图"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在setting中设置redis配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,</span><br><span class="line">        &quot;LOCATION&quot;: &quot;redis://yourip:6379&quot;,</span><br><span class="line">        &quot;OPTIONS&quot;: &#123;</span><br><span class="line">            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,</span><br><span class="line">            &quot;CONNECTION_POOL_KWARGS&quot;: &#123;&quot;max_connections&quot;: 100&#125;,</span><br><span class="line">            &quot;PASSWORD&quot;: &quot;yourpassword&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由设置urls.py:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r'^shopping_cart/$'</span>, shopping_cart.ShoppingCart.as_view()),</span><br></pre></td></tr></table></figure><p>基于restframework的视图：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@Author    : Young</span></span><br><span class="line"><span class="string">@Email     : hyc554@outlook.com</span></span><br><span class="line"><span class="string">@site      : http://www.cnblogs.com/huang-yc/</span></span><br><span class="line"><span class="string">@File      : shopping_cart.py</span></span><br><span class="line"><span class="string">@version   : 1.0</span></span><br><span class="line"><span class="string">@Time      : 2018/11/4 20:51</span></span><br><span class="line"><span class="string">Description about this file: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> GenericViewSet, ViewSetMixin</span><br><span class="line"><span class="keyword">from</span> django_redis <span class="keyword">import</span> get_redis_connection</span><br><span class="line"><span class="keyword">from</span> utils.response_dict <span class="keyword">import</span> BaseResponse</span><br><span class="line"><span class="keyword">from</span> api.views.auth <span class="keyword">import</span> YcAuth</span><br><span class="line"><span class="keyword">from</span> api <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> utils.error <span class="keyword">import</span> PricePolicyInvalid</span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ObjectDoesNotExist</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    authentication_classes = [YcAuth]</span><br><span class="line">    conn = get_redis_connection(<span class="string">'default'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        向购物车中添加商品</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :param args:</span></span><br><span class="line"><span class="string">        :param kwargs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = BaseResponse()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 在这里获得用户的课程ID与价格策略ID</span></span><br><span class="line">            course_id = int(request.data.get(<span class="string">'course_id'</span>))</span><br><span class="line">            policy_id = int(request.data.get(<span class="string">'policy_id'</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2. 获取专题课信息</span></span><br><span class="line">            course = models.Course.objects.get(id=course_id)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 3.获取课程相关的所有价格策略</span></span><br><span class="line">            price_policy_list = course.price_policy.all()</span><br><span class="line">            price_policy_dict = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> price_policy_list:</span><br><span class="line">                price_policy_dict[item.id] = &#123;</span><br><span class="line">                    <span class="string">"period"</span>: item.valid_period,</span><br><span class="line">                    <span class="string">"period_display"</span>: item.get_valid_period_display(),</span><br><span class="line">                    <span class="string">"price"</span>: item.price</span><br><span class="line">                &#125;</span><br><span class="line">            print(price_policy_dict)</span><br><span class="line">            <span class="keyword">if</span> policy_id <span class="keyword">not</span> <span class="keyword">in</span> price_policy_dict:</span><br><span class="line">                <span class="keyword">raise</span> PricePolicyInvalid(<span class="string">'价格策略不合法'</span>)</span><br><span class="line">            <span class="comment"># 5. 将购物信息添加到redis中</span></span><br><span class="line">            <span class="comment"># self.conn</span></span><br><span class="line">            <span class="comment"># car_key = "luffy_shopping_car_%s_%s"</span></span><br><span class="line">            car_key = settings.SHOPPING_CART_KEY % (request.auth.user_id, course_id,)</span><br><span class="line">            car_dict = &#123;</span><br><span class="line">                <span class="string">'title'</span>: course.name,</span><br><span class="line">                <span class="string">'img'</span>: course.course_img,</span><br><span class="line">                <span class="string">'default_policy'</span>: policy_id,</span><br><span class="line">                <span class="string">'policy'</span>: json.dumps(price_policy_dict)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment"># conn = get_redis_connection("default")</span></span><br><span class="line">            self.conn.hmset(car_key, car_dict)</span><br><span class="line">            ret.data = <span class="string">'添加成功'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> PricePolicyInvalid <span class="keyword">as</span> e:</span><br><span class="line">            ret.data = <span class="number">2001</span></span><br><span class="line">            ret.error = e.msg</span><br><span class="line">        <span class="keyword">except</span> ObjectDoesNotExist <span class="keyword">as</span> e:</span><br><span class="line">            ret.data = <span class="number">2002</span></span><br><span class="line">            ret.error = <span class="string">'课程不存在'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ret.code = <span class="number">1001</span></span><br><span class="line">            ret.data = <span class="string">'获取购物车数据失败'</span></span><br><span class="line">        <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        ret = BaseResponse()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            course_id_list = request.data.get(<span class="string">'courseids'</span>)</span><br><span class="line">            key_list = [settings.SHOPPING_CART_KEY % (request.auth.user_id, course_id,) <span class="keyword">for</span> course_id <span class="keyword">in</span> course_id_list]</span><br><span class="line">            self.conn.delete(*key_list)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ret.code = <span class="number">1002</span></span><br><span class="line">            ret.error = <span class="string">"删除失败"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">patch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        ret = BaseResponse()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            course_id = int(request.data.get(<span class="string">'course_id'</span>))</span><br><span class="line">            policy_id = str(request.data.get(<span class="string">'policy_id'</span>))</span><br><span class="line"></span><br><span class="line">            key = settings.SHOPPING_CART_KEY % (request.auth.user_id, course_id)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.conn.exists(key):</span><br><span class="line">                ret.code = <span class="number">1002</span></span><br><span class="line">                ret.error = <span class="string">"购物车中不存在此课程"</span></span><br><span class="line">                <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line">            <span class="comment"># 3. redis中获取所有的价格策略</span></span><br><span class="line">            <span class="comment"># 请注意这里对redis里的数据进行读取的操作</span></span><br><span class="line">            policy_dict = json.loads(str(self.conn.hget(key, <span class="string">'policy'</span>), encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="keyword">if</span> policy_id <span class="keyword">not</span> <span class="keyword">in</span> policy_dict:</span><br><span class="line">                ret.code = <span class="number">1003</span></span><br><span class="line">                ret.error = <span class="string">"价格策略不合法"</span></span><br><span class="line">                <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line"></span><br><span class="line">            self.conn.hset(key, <span class="string">'default_policy'</span>, policy_id)</span><br><span class="line">            ret.data = <span class="string">"修改成功"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ret.code = <span class="number">2003</span></span><br><span class="line">            ret.error = <span class="string">'修改数据失败'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查看购物车中所有的商品</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :param args:</span></span><br><span class="line"><span class="string">        :param kwargs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = BaseResponse()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            key_match = settings.SHOPPING_CART_KEY % (request.auth.user_id, <span class="string">"*"</span>)</span><br><span class="line"></span><br><span class="line">            course_list = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> self.conn.scan_iter(key_match, count=<span class="number">10</span>):</span><br><span class="line">                info = &#123;</span><br><span class="line">                    <span class="string">"title"</span>: self.conn.hget(key, <span class="string">'title'</span>).decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                    <span class="string">"img"</span>: self.conn.hget(key, <span class="string">'img'</span>).decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                    <span class="string">"policy"</span>: json.loads(self.conn.hget(key, <span class="string">'policy'</span>).decode(<span class="string">'utf-8'</span>)),</span><br><span class="line">                    <span class="string">"default_policy"</span>: self.conn.hget(key, <span class="string">'default_policy'</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                course_list.append(info)</span><br><span class="line">            ret.data = course_list</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ret.code = <span class="number">1002</span></span><br><span class="line">            ret.error = <span class="string">"获取失败"</span></span><br><span class="line">        <span class="keyword">return</span> Response(ret.dict)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在线教育——结算中心的实现</title>
      <link href="/2018/11/07/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E2%80%94%E2%80%94%E7%BB%93%E7%AE%97%E4%B8%AD%E5%BF%83%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/07/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E2%80%94%E2%80%94%E7%BB%93%E7%AE%97%E4%B8%AD%E5%BF%83%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>依赖软件：Django、redis</p><a id="more"></a><p>redis数据库中的数据结构：</p><ul><li>以字典形式进行存储</li><li>“shopping_car_用户ID_课程ID”作为标识key</li><li>“payment_global_coupon_用户ID”用来保存用户所持有的全场券</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">redis = &#123;</span><br><span class="line">payment_1_2:&#123;</span><br><span class="line">course_id:2,</span><br><span class="line">'title': 'CRM客户关系管理系统实战开发-专题', </span><br><span class="line">'img': 'CRM.jpg', 'policy_id': '4', </span><br><span class="line">'coupon': &#123;&#125;, </span><br><span class="line">'default_coupon': 0, </span><br><span class="line">'period': 210, 'period_display': '12个月', 'price': 122.0&#125;, </span><br><span class="line">&#125;,</span><br><span class="line">payment_1_1:&#123;</span><br><span class="line">course_id:1,</span><br><span class="line">'title': '爬虫开发-专题', </span><br><span class="line">'img': '爬虫开发-专题.jpg', </span><br><span class="line">'policy_id': '2', </span><br><span class="line">'coupon': &#123;</span><br><span class="line">4: &#123;'coupon_type': 0, 'coupon_display': '立减券', 'money_equivalent_value': 40&#125;, </span><br><span class="line">6: &#123;'coupon_type': 1, 'coupon_display': '满减券', 'money_equivalent_value': 60, 'minimum_consume': 100&#125;</span><br><span class="line">&#125;, </span><br><span class="line">'default_coupon': 0, </span><br><span class="line">'period': 60, </span><br><span class="line">'period_display': '2个月', </span><br><span class="line">'price': 599.0&#125;</span><br><span class="line">&#125;,</span><br><span class="line">payment_global_coupon_1:&#123;</span><br><span class="line">'coupon': &#123;</span><br><span class="line">2: &#123;'coupon_type': 1, 'coupon_display': '满减券', 'money_equivalent_value': 200, 'minimum_consume': 500&#125;</span><br><span class="line">&#125;, </span><br><span class="line">'default_coupon': 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的面试笔记</title>
      <link href="/2018/11/02/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/02/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>每天写一点，直到找到工作</p><a id="more"></a><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><ol><li>为什么学习Python？</li></ol><h1 id="一、WEB框架"><a href="#一、WEB框架" class="headerlink" title="一、WEB框架"></a>一、WEB框架</h1><h2 id="1-请简述django请求生命周期"><a href="#1-请简述django请求生命周期" class="headerlink" title="1. 请简述django请求生命周期"></a>1. 请简述django请求生命周期</h2><ul><li>当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端</li><li>服务端的wsgiref模块接收用户请求并将请求进行初次封装</li><li>将请求交给Django的中间件</li><li>通过中间件之后将请求交给url,根据浏览器发送的不同url去匹配不同的视图函数</li><li>视图函数根据业务逻辑调用数据库获取相应的数据，然或根据模板渲染页面</li><li>视图函数将响应的页面依次通过中间件</li><li>到达wsgi，封装数据后反馈给客户端<br><img src="https://i.loli.net/2018/11/03/5bdc849e1d6d5.png" alt="wsgi.png"></li></ul><h2 id="2-什么wsgi"><a href="#2-什么wsgi" class="headerlink" title="2. 什么wsgi"></a>2. 什么wsgi</h2><p><strong>Web服务器网关接口</strong>（<strong>Python Web Server Gateway Interface</strong>，缩写为WSGI）是为<a href="https://zh.wikipedia.org/wiki/Python" target="_blank" rel="noopener">Python</a>语言定义的<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">Web服务器</a>和<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">Web应用程序</a>或<a href="https://zh.wikipedia.org/wiki/Web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">框架</a>之间的一种简单而通用的<a href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E9%9D%A2_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" target="_blank" rel="noopener">接口</a>)。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。</p><p>WSGI区分为两个部分：一为“<a href="https://zh.wikipedia.org/wiki/%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">服务器</a>”或“网关”，另一为“应用程序”或“应用框架”。在处理一个WSGI请求时，服务器会为应用程序提供环境信息及一个回调函数（Callback Function）。当应用程序完成处理请求后，透过前述的回调函数，将结果回传给服务器。</p><p>所谓的 <em>WSGI 中间件</em>同时实现了API的两方，因此可以在WSGI服务器和WSGI应用之间起调解作用：从Web服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。“中间件”组件可以执行以下功能：</p><ul><li>重写<a href="https://zh.wikipedia.org/wiki/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">环境变量</a>后，根据目标<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="noopener">URL</a>，将请求消息路由到不同的应用对象。</li><li>允许在一个<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="noopener">进程</a>中同时运行多个应用程序或应用框架。</li><li><a href="https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" target="_blank" rel="noopener">负载均衡</a>和远程处理，通过在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">网络</a>上转发请求和响应消息。</li><li>进行内容后处理，例如应用<a href="https://zh.wikipedia.org/wiki/XSLT" target="_blank" rel="noopener">XSLT</a>样式表。</li></ul><p><strong>实现该协议的模块：</strong></p><ul><li>wsgiref</li><li>werkzurg</li><li>uwsig</li></ul><h2 id="3-视图的玩法"><a href="#3-视图的玩法" class="headerlink" title="3.视图的玩法"></a>3.视图的玩法</h2><p>FBV——url —— 函数</p><p>CBV——url —— view</p><h2 id="4-RESTful规范"><a href="#4-RESTful规范" class="headerlink" title="4.RESTful规范"></a>4.RESTful规范</h2><blockquote><p>什么是RESTful架构：</p><p>　　（1）每一个URI代表一种资源；</p><p>　　（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p></blockquote><h2 id="5-django-rest-framework框架"><a href="#5-django-rest-framework框架" class="headerlink" title="5.django rest framework框架"></a>5.django rest framework框架</h2><p><strong>1. 路由</strong></p><ul><li>可以通过as_view传参数，根据请求方式不同执行相应的方法</li><li>可以在url中设置一个结尾，类似于： .json </li></ul><p><strong>2. 视图</strong></p><ul><li>帮助开发者提供了一些类，并在类中提供了多个方法以供我们使用</li></ul><p><strong>3. 版本</strong></p><ul><li>在url中设置version参数，用户请求时候传入参数。在request.version中获取版本，根据版本不同做不同处理</li></ul><p><strong>4. 认证</strong><br>写一个类并注册到认证类，在类的的authticate方法中编写认证逻辑。</p><ul><li>认证成功（user,auth）</li><li>raise AuthticateFaild(….)</li><li>None </li></ul><p><strong>5. 权限</strong><br>写一个类并注册到权限类，在类的的has_permission方法中编写认证逻辑。</p><ul><li>True </li><li>False </li></ul><p><strong>6. 频率限制</strong><br>写一个类并注册到频率类，在类的的 allow_request/wait 方法中编写认证逻辑。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allow_request</span><br><span class="line"> <span class="keyword">True</span> </span><br><span class="line"> <span class="keyword">False</span>  如果返回<span class="keyword">False</span>，那么就要执行wait</span><br></pre></td></tr></table></figure></p><p><strong>7. 解析器</strong></p><ul><li><p>根据ContentType请求头，选择不同解析器对 请求体中的数据进行解析。</p></li><li><p>POST /index/ http1.1.\r\nhost:11.11.11.11\r\nContent-Type:url-formendo…. \r\n\r\nuser=alex&amp;age=123</p></li><li>POST /index/ http1.1.\r\nhost:11.11.11.11\r\nContent-Type:application/json\r\n\r\n{….}</li></ul><p><strong>8. 分页</strong> </p><ul><li>对从数据库中获取到的数据进行分页处理: SQL -&gt; limit offset <ul><li>根据页码：<a href="http://www.luffycity.com/api/v1/student/?page=1&amp;size=10" target="_blank" rel="noopener">http://www.luffycity.com/api/v1/student/?page=1&amp;size=10</a></li><li>根据索引：<a href="http://www.luffycity.com/api/v1/student/?offset=60&amp;limit=10" target="_blank" rel="noopener">http://www.luffycity.com/api/v1/student/?offset=60&amp;limit=10</a></li><li>根据加密：<a href="http://www.luffycity.com/api/v1/student/?page=erd8" target="_blank" rel="noopener">http://www.luffycity.com/api/v1/student/?page=erd8</a></li></ul></li></ul><hr><h2 id="6-页码越大速度越慢，为什么以及如何解决？"><a href="#6-页码越大速度越慢，为什么以及如何解决？" class="headerlink" title="6. 页码越大速度越慢，为什么以及如何解决？"></a>6. 页码越大速度越慢，为什么以及如何解决？</h2><p>原因：页码越大向后需要扫描的行数越多，因为每次都是从0开始扫描。<br>解决：</p><pre><code>- 限制显示的页数- 记录当前页数据ID最大值和最小值，再次分页时，根据ID现行筛选，然后再分页。</code></pre><h2 id="7-三次握手与四次挥手"><a href="#7-三次握手与四次挥手" class="headerlink" title="7. 三次握手与四次挥手"></a>7. 三次握手与四次挥手</h2><p>答案详解：<a href="https://www.cnblogs.com/huang-yc/p/9859216.html" target="_blank" rel="noopener">TCP握手与挥手</a></p><h2 id="8-简述什么是FBV和CBV"><a href="#8-简述什么是FBV和CBV" class="headerlink" title="8.简述什么是FBV和CBV"></a>8.简述什么是FBV和CBV</h2><p>FBV（function base views） ——在视图里使用函数处理请求。<br>CBV（class base views） ——在视图里使用类处理请求。</p><p>其实没有本质的区别</p><p>Python是一个面向对象的编程语言，如果只用函数来开发，有很多面向对象的优点就错失了（继承、封装、多态）。所以Django在后来加入了Class-Based-View。可以让我们用类写View。这样做的优点主要下面两种：</p><p>提高了代码的复用性，可以使用面向对象的技术，比如Mixin（多继承）<br>可以用不同的函数针对不同的HTTP方法处理，而不是通过很多if判断，提高代码可读性</p><h2 id="9-谈一谈你对ORM的理解"><a href="#9-谈一谈你对ORM的理解" class="headerlink" title="9.谈一谈你对ORM的理解"></a>9.谈一谈你对ORM的理解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ORM是“对象-关系-映射”的简称。</span><br><span class="line">MVC或者MVC框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库，这极大的减轻了开发人员的工作量，不需要面对因数据库变更而导致的无效劳动</span><br></pre></td></tr></table></figure><h1 id="二、-项目相关："><a href="#二、-项目相关：" class="headerlink" title="二、 项目相关："></a>二、 项目相关：</h1><h2 id="1-请讲一下你做的在线商城的表结构"><a href="#1-请讲一下你做的在线商城的表结构" class="headerlink" title="1. 请讲一下你做的在线商城的表结构"></a>1. 请讲一下你做的在线商城的表结构</h2><ul><li>课程（13表）<ul><li>课程大类</li><li>课程子类</li><li>学位课<ul><li>讲师</li><li>奖学金</li></ul></li><li>专题课（学位课模块表）</li><li>价格策略(contenttype)</li><li>课程详细(o2o -&gt; 水平分表)</li><li>常见问题</li><li>课程大纲</li><li>章节</li><li>课时</li><li>作业 </li></ul></li><li>深科技（4+2）<ul><li>用户表</li><li>用户token</li><li>文章来源</li><li>文章表</li><li>通用评论表</li><li>通用收藏表</li></ul></li></ul><h2 id="2-支付宝功能"><a href="#2-支付宝功能" class="headerlink" title="2. 支付宝功能"></a>2. 支付宝功能</h2><ul><li>加密方式：rsa</li><li>公钥私钥：<ul><li>商户私钥<ul><li>支付宝公钥</li></ul></li></ul></li><li>支付成功后，断电宕机<ul><li>成功：return HttpResponse(‘success’)</li></ul></li></ul><h2 id="3-数据库页数越大速度越慢，如何解决"><a href="#3-数据库页数越大速度越慢，如何解决" class="headerlink" title="3. 数据库页数越大速度越慢，如何解决"></a>3. 数据库页数越大速度越慢，如何解决</h2><ul><li>限制页数</li><li>记录当前页最大ID、最小ID</li><li>错误答案：<ul><li>扫描索引表</li><li>再去数据库表中获取数据</li></ul></li></ul><h2 id="4-redis是什么？"><a href="#4-redis是什么？" class="headerlink" title="4. redis是什么？"></a>4. redis是什么？</h2><p>用于操作内存的软件。</p><ul><li>可以做持久化：<ul><li>AOF</li><li>RDB</li></ul></li><li><p>相当于是大字典</p></li><li><p>单进程单线程</p></li></ul><h1 id="三、-Django"><a href="#三、-Django" class="headerlink" title="三、 Django"></a>三、 Django</h1><h2 id="1-讲述一些ORM操作"><a href="#1-讲述一些ORM操作" class="headerlink" title="1. 讲述一些ORM操作"></a>1. 讲述一些ORM操作</h2><ul><li><p>select_related,连表操作，相当于主动做join</p></li><li><p>prefeth_related,多次单表操作，先查询想要的数据，然后构造条件,如：id=[1,2,3]，再次查询其他表根据id做条件。</p></li><li><p>only</p></li><li><p>defer</p></li><li><p>F </p></li><li><p>Q </p></li><li><p>通过ORM写偏原生SQL：</p></li></ul><ol><li>extra</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.extra(select=&#123;<span class="string">'new_id'</span>: <span class="string">"select col from sometable where othercol &gt; %s"</span>&#125;, select_params=(<span class="number">1</span>,))</span><br><span class="line">Entry.objects.extra(where=[<span class="string">'headline=%s'</span>], params=[<span class="string">'Lennon'</span>])</span><br><span class="line">Entry.objects.extra(where=[<span class="string">"foo='a' OR bar = 'a'"</span>, <span class="string">"baz = 'a'"</span>])</span><br><span class="line">Entry.objects.extra(select=&#123;<span class="string">'new_id'</span>: <span class="string">"select id from tb where id &gt; %s"</span>&#125;,select_params=(<span class="number">1</span>,), order_by=[<span class="string">'-nid'</span>])</span><br></pre></td></tr></table></figure><ol start="2"><li>raw</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行原生SQL</span></span><br><span class="line">models.UserInfo.objects.raw(<span class="string">'select * from userinfo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名</span></span><br><span class="line">models.UserInfo.objects.raw(<span class="string">'select id as nid from 其他表'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为原生SQL设置参数</span></span><br><span class="line">models.UserInfo.objects.raw(<span class="string">'select id as nid from userinfo where nid&gt;%s'</span>, params=[<span class="number">12</span>,])</span><br><span class="line"></span><br><span class="line">name_map = &#123;<span class="string">'first'</span>: <span class="string">'first_name'</span>, <span class="string">'last'</span>: <span class="string">'last_name'</span>, <span class="string">'bd'</span>: <span class="string">'birth_date'</span>, <span class="string">'pk'</span>: <span class="string">'id'</span>&#125;</span><br><span class="line">Person.objects.raw(<span class="string">'SELECT * FROM some_other_table'</span>, translations=name_map)</span><br></pre></td></tr></table></figure><ol start="3"><li>原生SQL</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection, connections</span><br><span class="line">cursor = connection.cursor()  <span class="comment"># cursor = connections['default'].cursor()</span></span><br><span class="line">cursor.execute(<span class="string">"""SELECT * from auth_user where id = %s"""</span>, [<span class="number">1</span>])</span><br><span class="line">row = cursor.fetchone() <span class="comment"># fetchall()/fetchmany(..)</span></span><br></pre></td></tr></table></figure><ol start="5"><li>选择数据库</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queryset = models.Course.objects.using(<span class="string">'default'</span>).all()</span><br></pre></td></tr></table></figure><h1 id="？、其他"><a href="#？、其他" class="headerlink" title="？、其他"></a>？、其他</h1><h2 id="1-git的作用是什么"><a href="#1-git的作用是什么" class="headerlink" title="1. git的作用是什么"></a>1. git的作用是什么</h2><p>进行版本控制，实现协同开发</p><h2 id="2-git命令与意义"><a href="#2-git命令与意义" class="headerlink" title="2. git命令与意义"></a>2. git命令与意义</h2><ul><li>git init </li><li>git add </li><li>git status </li><li>git commit </li><li>git log </li><li>git reflog </li><li>git reset –hard</li><li>git checkout </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python基础算法实现</title>
      <link href="/2018/10/29/python%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/10/29/python%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本篇主要实现九(八)大排序算法，分别是冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序,计数排序。希望大家回顾知识的时候也能从我的这篇文章得到帮助。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>十种常见排序算法可以分为两大类：</p><ol><li>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</li><li>线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</li></ol><p><strong>基础定义</strong></p><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ul><p><strong>图示</strong><br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014194820700-1435466222.png" alt=""></p><p><strong>为了防止误导读者，本文所有概念性内容均截取自对应Wiki。</strong></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>原理</strong></p><p>冒泡排序(Bubble Sort)是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014185452443-1800879816.gif" alt=""></p><p><strong>步骤</strong></p><p>冒泡排序算法的运作如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    length = len(list)</span><br><span class="line">    <span class="comment"># 第一级遍历</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="comment"># 第二级遍历</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length - index):</span><br><span class="line">            <span class="keyword">if</span> list[j - <span class="number">1</span>] &gt; list[j]:</span><br><span class="line">                <span class="comment"># 交换两者数据，这里没用temp是因为python 特性元组。</span></span><br><span class="line">                list[j - <span class="number">1</span>], list[j] = list[j], list[j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><p>这种排序其实还可以稍微优化一下，添加一个标记，在排序已完成时，停止排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort_flag</span><span class="params">(list)</span>:</span></span><br><span class="line">    length = len(list)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="comment"># 标志位</span></span><br><span class="line">        flag = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length - index):</span><br><span class="line">            <span class="keyword">if</span> list[j - <span class="number">1</span>] &gt; list[j]:</span><br><span class="line">                list[j - <span class="number">1</span>], list[j] = list[j], list[j - <span class="number">1</span>]</span><br><span class="line">                flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="comment"># 没有发生交换，直接返回list</span></span><br><span class="line">            <span class="keyword">return</span> list</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>原理</strong></p><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理大致是将后面的元素最小元素一个个取出然后按顺序放置。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014185807987-1057233489.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    n=len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>,n):</span><br><span class="line">        min = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> list[j]&lt;list[min]:</span><br><span class="line">                min=j</span><br><span class="line">                list[min],list[i]=list[i],list[min]</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>原理</strong></p><p>插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190107085-1652380825.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># 后一个元素和前一个元素比较</span></span><br><span class="line">        <span class="comment"># 如果比前一个小</span></span><br><span class="line">        <span class="keyword">if</span> list[i] &lt; list[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 将这个数取出</span></span><br><span class="line">            temp = list[i]</span><br><span class="line">            <span class="comment"># 保存下标</span></span><br><span class="line">            index = i</span><br><span class="line">            <span class="comment"># 从后往前依次比较每个元素</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="comment"># 和比取出元素大的元素交换</span></span><br><span class="line">                <span class="keyword">if</span> list[j] &gt; temp:</span><br><span class="line">                    list[j + <span class="number">1</span>] = list[j]</span><br><span class="line">                    index = j</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 插入元素</span></span><br><span class="line">            list[index] = temp</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>原理</strong></p><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率<br>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190225518-1370369504.gif" alt=""></p><p><strong>步骤</strong></p><p>每次以一定步长(就是跳过等距的数)进行排序，直至步长为1.</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="comment"># 每个步长进行插入排序</span></span><br><span class="line">            temp = list[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> list[j - gap] &gt; temp:</span><br><span class="line">                list[j] = list[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            list[j] = temp</span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><blockquote><p>步长使用的是Donald Shell的建议，另外步长还可以使用Sedgewick提出的(1, 5, 19, 41, 109,…)。<br>也可以使用<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%2596%2590%25E6%25B3%25A2%25E9%2582%25A3%25E5%25A5%2591%25E6%2595%25B0%25E5%2588%2597" target="_blank" rel="noopener">斐波那契数列</a>除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列。</p></blockquote><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>原理</strong></p><p>归并操作(归并算法)，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190406955-1250220054.gif" alt=""></p><p><strong>步骤</strong></p><p>1.迭代法</p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置<br> 3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><p><strong>递归法</strong></p><p>假设序列共有n个元素：</p><ol><li>将序列每相邻两个数字进行归并操作，形成 {\displaystyle floor(n/2)} floor(n/2)个序列，排序后每个序列包含两个元素</li><li>将上述序列再次归并，形成 {\displaystyle floor(n/4)} floor(n/4)个序列，每个序列包含四个元素</li><li>重复步骤2，直到所有元素排序完毕</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment"># 认为长度不大于1的数列是有序的</span></span><br><span class="line">    <span class="keyword">if</span> len(list) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    <span class="comment"># 二分列表</span></span><br><span class="line">    middle = len(list) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(list[:middle])</span><br><span class="line">    right = merge_sort(list[middle:])</span><br><span class="line">    <span class="comment"># 最后一次合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    l,r=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    result=[]</span><br><span class="line">    <span class="keyword">while</span> l&lt;len(left) <span class="keyword">and</span> r&lt;len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt;right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r +=<span class="number">1</span></span><br><span class="line">        reslut +=left[l:]</span><br><span class="line">        result+=right[r:]                </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>鄙人不才，不知归并排序的迭代法如何用Python实现，望指教。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>原理</strong></p><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190611263-753990372.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p><strong>代码</strong></p><p>普通版</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    less = []</span><br><span class="line">    pivotList = []</span><br><span class="line">    more = []</span><br><span class="line">    <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> len(list) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 将第一个值做为基准</span></span><br><span class="line">        pivot = list[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">            <span class="comment"># 将比急转小的值放到less数列</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; pivot:</span><br><span class="line">                less.append(i)</span><br><span class="line">            <span class="comment"># 将比基准打的值放到more数列</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt; pivot:</span><br><span class="line">                more.append(i)</span><br><span class="line">            <span class="comment"># 将和基准相同的值保存在基准数列</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pivotList.append(i)</span><br><span class="line">        <span class="comment"># 对less数列和more数列继续进行排序</span></span><br><span class="line">        less = quick_sort(less)</span><br><span class="line">        more = quick_sort(more)</span><br><span class="line">        <span class="keyword">return</span> less + pivotList + more</span><br></pre></td></tr></table></figure><p>分而治之的思想实现：</p><p>下面这段代码出自《算法图解》传说中的三行实现python快速排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = arr[<span class="number">0</span>]</span><br><span class="line">        less = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">        greater = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= pivot]</span><br><span class="line">        <span class="keyword">return</span> qsort(less) + [pivot] + qsort(greater)</span><br></pre></td></tr></table></figure><p>一行语法糖版本:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qs = <span class="keyword">lambda</span> xs : ( (len(xs) &lt;= <span class="number">1</span> <span class="keyword">and</span> [xs]) <span class="keyword">or</span> [ qs( [x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; xs[<span class="number">0</span>]] ) + [xs[<span class="number">0</span>]] + qs( [x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= xs[<span class="number">0</span>]] ) ] )[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>是不是感受到了Python的魅力？</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>原理</strong></p><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190700059-194955464.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>创建最大堆:将堆所有数据重新排序，使其成为最大堆</li><li>最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序</li><li>堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment"># 创建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range((len(list) - <span class="number">2</span>) // <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        sift_down(list, start, len(list) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 堆排序</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(len(list) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        list[<span class="number">0</span>], list[end] = list[end], list[<span class="number">0</span>]</span><br><span class="line">        sift_down(list, <span class="number">0</span>, end - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(lst, start, end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        child = <span class="number">2</span> * root + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> lst[child] &lt; lst[child + <span class="number">1</span>]:</span><br><span class="line">            child += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lst[root] &lt; lst[child]:</span><br><span class="line">            lst[root], lst[child] = lst[child], lst[root]</span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><strong>原理</strong></p><p>当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190748857-1567575212.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    min = <span class="number">2147483647</span></span><br><span class="line">    max = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 取得最大值和最小值</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> list:</span><br><span class="line">        <span class="keyword">if</span> x &lt; min:</span><br><span class="line">            min = x</span><br><span class="line">        <span class="keyword">if</span> x &gt; max:</span><br><span class="line">            max = x</span><br><span class="line">    <span class="comment"># 创建数组C</span></span><br><span class="line">    count = [<span class="number">0</span>] * (max - min +<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> list:</span><br><span class="line">        count[index - min] += <span class="number">1</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 填值</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(max - min+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(count[a]):</span><br><span class="line">            list[index] = a + min</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h2 id="第九种排序"><a href="#第九种排序" class="headerlink" title="第九种排序"></a>第九种排序</h2><p>None？<br>当然不会<br>自然就是系统自带的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list.sort()</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>维基百科: <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%2586%2592%25E6%25B3%25A1%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">冒泡排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E9%2580%2589%25E6%258B%25A9%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">选择排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%258F%2592%25E5%2585%25A5%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">插入排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25B8%258C%25E5%25B0%2594%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">希尔排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25BD%2592%25E5%25B9%25B6%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">归并排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25BF%25AB%25E9%2580%259F%25E6%258E%2592%25E5%25BA%258F%23.E5.8E.9F.E5.9C.B0.EF.BC.88in-place.EF.BC.89.E5.88.86.E5.89.B2.E7.9A.84.E7.89.88.E6.9C.AC" target="_blank" rel="noopener">快速排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25A0%2586%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">堆排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E8%25AE%25A1%25E6%2595%25B0%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">计数排序</a></li><li>[Python Cookbook</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅析跨域请求</title>
      <link href="/2018/10/26/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/10/26/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近做项目的时候遇到了一些跨域问题，虽然网上对于跨域的问题分享还挺多的。不过当我实际遇到的时候还是有点懵。趁项目刚上线完，写篇文章总结下。</p><a id="more"></a><h3 id="造成跨域的原因"><a href="#造成跨域的原因" class="headerlink" title="造成跨域的原因"></a>造成跨域的原因</h3><p>浏览器的同源策略会导致跨域，这里同源策略又分为以下两种</p><ul><li>DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</li><li>XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。</li></ul><blockquote><p>只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。</p></blockquote><h3 id="为什么要有跨域限制"><a href="#为什么要有跨域限制" class="headerlink" title="为什么要有跨域限制"></a>为什么要有跨域限制</h3><p>了解完跨域之后，想必大家都会有这么一个思考，为什么要有跨域的限制，浏览器这么做是出于何种原因呢。其实仔细想一想就会明白，跨域限制主要是为了安全考虑。</p><p>AJAX同源策略主要用来防止CSRF攻击。如果没有AJAX同源策略，相当危险，我们发起的每一次HTTP请求都会带上请求地址对应的cookie，那么可以做如下攻击：</p><ol><li>用户登录了自己的银行页面 <code>http://mybank.com</code>，<code>http://mybank.com</code>向用户的cookie中添加用户标识。</li><li>用户浏览了恶意页面 <code>http://evil.com</code>。执行了页面中的恶意AJAX请求代码。</li><li><code>http://evil.com</code>向<code>http://mybank.com</code>发起AJAX HTTP请求，请求会默认把<code>http://mybank.com</code>对应cookie也同时发送过去。</li><li>银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。</li><li>而且由于Ajax在后台执行，用户无法感知这一过程。</li></ol><p>DOM同源策略也一样，如果iframe之间可以跨域访问，可以这样攻击：</p><ol><li>做一个假网站，里面用iframe嵌套一个银行网站 <code>http://mybank.com</code>。</li><li>把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li><li>这时如果用户输入账号密码，我们的主网站可以跨域访问到<code>http://mybank.com</code>的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击。</li></ol><p>所以说有了跨域跨域限制之后，我们才能更安全的上网了。</p><h3 id="跨域的解决方式"><a href="#跨域的解决方式" class="headerlink" title="跨域的解决方式"></a>跨域的解决方式</h3><h4 id="跨域资源共享（CORS"><a href="#跨域资源共享（CORS" class="headerlink" title="跨域资源共享（CORS)"></a>跨域资源共享（CORS)</h4><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>对于这个方式，阮一峰老师总结的文章特别好，希望深入了解的可以看一下<code>http://www.ruanyifeng.com/blog/2016/04/cors.html</code>。</p><p>通过在HTTP Header中加入扩展字段，服务器在相应网页头部加入字段表示允许访问的domain和HTTP method，客户端检查自己的域是否在允许列表中，决定是否处理响应。</p><p>实现的基础是JavaScript不能够操作HTTP Header。某些浏览器插件实际上是具有这个能力的。</p><p>服务器端在HTTP的响应头中加入（页面层次的控制模式）：</p><p><strong><em>Access-Control-Allow-Origin: example.com</em></strong><br><strong><em>Access-Control-Request-Method: GET, POST</em></strong><br><strong><em>Access-Control-Allow-Headers: Content-Type, Authorization, Accept, Range, Origin</em></strong></p><p><strong><em>Access-Control-Expose-Headers: Content-Range</em></strong></p><p><strong><em>Access-Control-Max-Age: 3600</em></strong></p><p>多个域名之间用逗号分隔，表示对所示域名提供跨域访问权限。”*”表示允许所有域名的跨域访问。</p><p><strong>客户端可以有两种行为：</strong></p><ol><li><p>发送OPTIONS请求，请求Access-Control信息。如果自己的域名在允许的访问列表中，则发送真正的请求，否则放弃请求发送。</p></li><li><p>直接发送请求，然后检查response的Access-Control信息，如果自己的域名在允许的访问列表中，则读取response body，否则放弃。</p></li></ol><p>本质上服务端的response内容已经到达本地，JavaScript决定是否要去读取。</p><p>这里我就简单的说一说大体流程。</p><ol><li>对于客户端，我们还是正常使用xhr对象发送ajax请求。<br>唯一需要注意的是，我们需要设置我们的xhr属性<code>withCredentials</code>为true，不然的话，cookie是带不过去的哦，设置： <code>xhr.withCredentials = true</code>;</li><li>对于服务器端，需要在 response header中设置如下两个字段:<br><code>Access-Control-Allow-Origin: http://www.yourhost.com</code><br><code>Access-Control-Allow-Credentials:true</code><br>这样，我们就可以跨域请求接口了。</li></ol><p>在django的实际项目中,跨域用CORS技术构建一个中间件，来解决跨域问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORSMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        解决跨域问题</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :param response:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 添加响应头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 允许你的域名来获取我的数据</span></span><br><span class="line">        response[<span class="string">'Access-Control-Allow-Origin'</span>] = <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 允许你携带Content-Type请求头</span></span><br><span class="line">        <span class="comment"># response['Access-Control-Allow-Headers'] = "Content-Type"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 允许你发送DELETE,PUT</span></span><br><span class="line">        <span class="comment"># response['Access-Control-Allow-Methods'] = "DELETE,PUT"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h4 id="jsonp实现跨域"><a href="#jsonp实现跨域" class="headerlink" title="jsonp实现跨域"></a>jsonp实现跨域</h4><p>基本原理就是通过动态创建script标签,然后利用src属性进行跨域。<br>这么说比较模糊，我们来看个例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">//定义一个fun函数</span><br><span class="line">function fun(data) &#123; </span><br><span class="line">    console.log(data); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 创建一个脚本，并且告诉后端回调函数名叫fun </span><br><span class="line">var body= document.getElementsByTagName(&apos;body&apos;)[0]; </span><br><span class="line">var script= document.createElement(&apos;script&apos;); </span><br><span class="line">script.type= &apos;text/javascript&apos;; </span><br><span class="line">script.src= &apos;demo.js?callback=fun&apos;; </span><br><span class="line">body.appendChild(script); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>返回的js脚本，直接会执行。所以就执行了事先定义好的fun函数了，并且把数据传入了进来。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun(&#123;&quot;name&quot;:&quot;name&quot;&#125;)</span><br></pre></td></tr></table></figure><p>当然，这个只是一个原理演示，实际情况下，我们需要动态创建这个fun函数，并且在数据返回的时候销毁它。</p><p>因为在实际使用的时候，我们用的各种ajax库，基本都包含了jsonp的封装，不过我们还是要知道一下原理，不然就不知道为什么jsonp不能发post请求了~</p><h4 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h4><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。</p><blockquote><p>服务器代理是万能的。</p></blockquote><h4 id="document-domain来跨子域"><a href="#document-domain来跨子域" class="headerlink" title="document.domain来跨子域"></a>document.domain来跨子域</h4><p>对于主域名相同，而子域名不同的情况，可以使用document.domain来跨域<br>这种方式非常适用于iframe跨域的情况，直接看例子吧<br>比如a页面地址为 <code>a.yourhost.com</code> b页面为 <code>b.yourhost.com</code>。<br>这样就可以通过分别给两个页面设置 <code>document.domain = yourhost.com</code> 来实现跨域。<br>之后，就可以通过 parent 或者 window[‘iframename’]等方式去拿到iframe的window对象了。</p><h4 id="使用window-name进行跨域"><a href="#使用window-name进行跨域" class="headerlink" title="使用window.name进行跨域"></a>使用window.name进行跨域</h4><p>window.name跨域同样是受到同源策略限制，父框架和子框架的src必须指向统一域名。window.name的优势在于，name的值在不同的页面(或者不同的域名)，加载后仍然存在，除非你显示的更改。并且支持的长度达到2M.</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    iframe.style.display = &apos;none&apos;;</span><br><span class="line">    var state = 0;</span><br><span class="line"></span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">      if(state === 1) &#123;</span><br><span class="line">          var data = iframe.contentWindow.name;</span><br><span class="line">          console.log(data);</span><br><span class="line">          iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">          iframe.contentWindow.close();</span><br><span class="line">          document.body.removeChild(iframe);</span><br><span class="line">      &#125; else if(state === 0) &#123;</span><br><span class="line">          state = 1;</span><br><span class="line">          iframe.contentWindow.location = </span><br><span class="line">          &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//b页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.name = &quot;hello&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="window-location-hash跨域"><a href="#window-location-hash跨域" class="headerlink" title="window.location.hash跨域"></a>window.location.hash跨域</h4><p>location.hash方式跨域，是子框架具有修改父框架src的hash值，通过这个属性进行传递数据，且更改hash值，页面不会刷新。但是传递的数据的字节数是有限的。</p><blockquote><p>注意：父子框架受同源策略的限制</p></blockquote><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    iframe.style.display = &apos;none&apos;;</span><br><span class="line">    var state = 0;</span><br><span class="line"></span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">      if(state === 1) &#123;</span><br><span class="line">          var data = window.location.hash;</span><br><span class="line">          console.log(data);</span><br><span class="line">          iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">          iframe.contentWindow.close();</span><br><span class="line">          document.body.removeChild(iframe);</span><br><span class="line">      &#125; else if(state === 0) &#123;</span><br><span class="line">          state = 1;</span><br><span class="line">          iframe.contentWindow.location = </span><br><span class="line">          &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//b页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    parent.location.hash = &quot;world&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="window-top"><a href="#window-top" class="headerlink" title="window.top"></a>window.top</h4><p>window.top方法可以访问最顶层的window对象，可以取到最顶层window对象的属性和方法。这样子框架就可以操作父页面的交互了。window.parent可以得到父框架的window对象。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function funa()&#123;</span><br><span class="line">        console.log(&quot;a页面的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    iframe.style.display = &apos;none&apos;;</span><br><span class="line">    iframe.src = &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//b页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">console.log(window.top.funa());</span><br><span class="line">function funb()&#123;</span><br><span class="line">  console.log(&quot;b页面的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">iframe.style.display = &apos;none&apos;;</span><br><span class="line">iframe.src = &apos;http://m.zhuanzhuan.58.com:8887/c.html&apos;;</span><br><span class="line">document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//c页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  console.log(window.parent.funb());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="使用postMessage实现页面之间通信"><a href="#使用postMessage实现页面之间通信" class="headerlink" title="使用postMessage实现页面之间通信"></a>使用postMessage实现页面之间通信</h4><p>信息传递除了客户端与服务器之前的传递，还存在以下几个问题：</p><ul><li>页面和新开的窗口的数据交互。</li><li>多窗口之间的数据交互。</li><li>页面与所嵌套的iframe之间的信息传递。</li></ul><p>window.postMessage是一个HTML5的api，允许两个窗口之间进行跨域发送消息。这个应该就是以后解决dom跨域通用方法了，具体可以参照MDN。</p><blockquote><p>补充： 其实还有一些方法，比如window.name和location.hash。就很适用于iframe的跨域，不过iframe用的比较少了，所以这些方法也就有点过时了。</p></blockquote><p>这些就是我对跨域的了解了，实际情况下，一般用cors，jsonp等常见方法就可以了。不过遇到了一些非常规情况，我们还是需要知道有更多的方法可以选择的</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python虚拟环境--virtualenv</title>
      <link href="/2018/10/26/pythonenv/"/>
      <url>/2018/10/26/pythonenv/</url>
      
        <content type="html"><![CDATA[<h2 id="1-virtualenv"><a href="#1-virtualenv" class="headerlink" title="1. virtualenv"></a>1. virtualenv</h2><p>　　virtualenv 是一个创建隔绝的Python环境的工具。virtualenv创建一个包含所有必要的可执行文件的文件夹，用来使用Python工程所需的包。<br><a id="more"></a></p><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure><h3 id="1-2基本使用"><a href="#1-2基本使用" class="headerlink" title="1.2基本使用"></a>1.2基本使用</h3><ol><li>为一个工程创建一个虚拟环境：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd my_project_dir</span><br><span class="line">$ virtualenv venv　　#venv为虚拟环境目录名，目录名自定义</span><br></pre></td></tr></table></figure><p><code>virtualenv venv</code> 将会在当前的目录中创建一个文件夹，包含了Python可执行文件，以及 <code>pip</code> 库的一份拷贝，这样就能安装其他包了。虚拟环境的名字（此例中是 <code>venv</code> ）可以是任意的；若省略名字将会把文件均放在当前目录。</p><p>　　在任何你运行命令的目录中，这会创建Python的拷贝，并将之放在叫做 <code>venv</code> 的文件中。</p><p>　　你可以选择使用一个Python解释器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ virtualenv -p /usr/bin/python2.7 venv　　　　# -p参数指定Python解释器程序路径</span><br></pre></td></tr></table></figure><p>　　这将会使用 <code>/usr/bin/python2.7</code> 中的Python解释器。</p><ol><li>要开始使用虚拟环境，其需要被激活：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source venv/bin/activate</span><br></pre></td></tr></table></figure><p><code>从现在起，任何你使用pip安装的包将会放在 venv</code> 文件夹中，与全局安装的Python隔绝开。</p><p>像平常一样安装包，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install requests</span><br></pre></td></tr></table></figure><ol><li>如果你在虚拟环境中暂时完成了工作，则可以停用它：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ . venv/bin/deactivate</span><br></pre></td></tr></table></figure><p>这将会回到系统默认的Python解释器，包括已安装的库也会回到默认的。</p><p>要删除一个虚拟环境，只需删除它的文件夹。（执行 <code>rm -rf venv</code> ）。</p><p>这里virtualenv 有些不便，因为virtual的启动、停止脚本都在特定文件夹，可能一段时间后，你可能会有很多个虚拟环境散落在系统各处，你可能忘记它们的名字或者位置。</p><h2 id="2-virtualenvwrapper"><a href="#2-virtualenvwrapper" class="headerlink" title="2. virtualenvwrapper"></a>2. virtualenvwrapper</h2><p>　　鉴于virtualenv不便于对虚拟环境集中管理，所以推荐直接使用virtualenvwrapper。 virtualenvwrapper提供了一系列命令使得和虚拟环境工作变得便利。它把你所有的虚拟环境都放在一个地方。</p><h3 id="2-1-安装virtualenvwrapper"><a href="#2-1-安装virtualenvwrapper" class="headerlink" title="2.1 安装virtualenvwrapper"></a>2.1 安装virtualenvwrapper</h3><p>(确保virtualenv已安装)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenvwrapper</span><br><span class="line">pip install virtualenvwrapper-win　　#Windows使用该命令</span><br></pre></td></tr></table></figure><p>安装完成后，在~/.bashrc写入以下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export WORKON_HOME=~/Envs</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p>第一行：<strong>virtualenvwrapper</strong>存放虚拟环境目录</p><p>第二行：<strong>virtrualenvwrapper</strong>会安装到python的bin目录下，所以该路径是python安装目录下bin/virtualenvwrapper.sh</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc　　　　#读入配置文件，立即生效</span><br></pre></td></tr></table></figure><p>　</p><h3 id="2-2-virtualenvwrapper基本使用"><a href="#2-2-virtualenvwrapper基本使用" class="headerlink" title="2.2 virtualenvwrapper基本使用"></a>2.2 virtualenvwrapper基本使用</h3><ol><li>创建虚拟环境——<strong>mkvirtualenv</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkvirtualenv venv</span><br></pre></td></tr></table></figure><p>这样会在WORKON_HOME变量指定的目录下新建名为venv的虚拟环境。</p><p>若想指定python版本，可通过”–python”指定python解释器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkvirtualenv --python=/usr/local/python3.5.3/bin/python venv</span><br></pre></td></tr></table></figure><ol start="2"><li>基本命令 　</li></ol><p>　　查看当前的虚拟环境目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# workon</span><br><span class="line">py2</span><br><span class="line">py3</span><br></pre></td></tr></table></figure><p>　　切换到虚拟环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# workon py3</span><br><span class="line">(py3) [root@localhost ~]#</span><br></pre></td></tr></table></figure><p>　　退出虚拟环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(py3) [root@localhost ~]# deactivate</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>　　删除虚拟环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmvirtualenv venv</span><br></pre></td></tr></table></figure><blockquote><p>本文参考链接：<a href="http://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html" target="_blank" rel="noopener">http://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅析Python日志重复输出问题</title>
      <link href="/2018/10/17/logging/"/>
      <url>/2018/10/17/logging/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/868097/pexels-photo-868097.jpeg?cs=srgb&amp;dl=adventure-backpack-blue-mountains-868097.jpg&amp;fm=jpg" alt=""></p><a id="more"></a><h2 id="问题起源："><a href="#问题起源：" class="headerlink" title="问题起源："></a>问题起源：</h2><p>​    在学习了python的函数式编程后，又接触到了logging这样一个强大的日志模块。为了减少重复代码，应该不少同学和我一样便迫不及待的写了一个自己的日志函数，比如下面这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里为了便于理解，简单的展示了一个输出到屏幕的日志函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line"></span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setLevel(logging.ERROR)</span><br><span class="line">    fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">    ch.setFormatter(fmt)</span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log().error(<span class="string">'run one'</span>)</span><br><span class="line">my_log().error(<span class="string">'run two'</span>)</span><br><span class="line">my_log().error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><p>函数写好了，看起来似乎也没有问题，我们来运行一下！</p><p>结果如下：</p><blockquote><p>2018-06-21 13:06:37,569 - mysql.log - ERROR - run one<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run two<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run two<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run three<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run three<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run three</p></blockquote><p>日志居然重复输出了，且数量递增。</p><hr><h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><ul><li><p>实际上<code>logger = logging.getLogger(&#39;mysql.log&#39;)</code>在执行时，没有每次生成一个新的logger，而是先检查内存中是否存在一个叫做‘mysql.log’的logger对象，存在则取出，不存在则新建。</p></li><li><p>实例化的logger对象具有‘handlers’这样一个属性来存储 Handler，代码演示如下：</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">()</span>:</span></span><br><span class="line">logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line"><span class="comment"># 每次被调用后打印出logger的handlers列表</span></span><br><span class="line">print(logger.handlers)</span><br><span class="line"></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.ERROR)</span><br><span class="line">fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">ch.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log().error(<span class="string">'run one'</span>)</span><br><span class="line">my_log().error(<span class="string">'run two'</span>)</span><br><span class="line">my_log().error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>[]<br>2018-06-21 13:26:14,059 - mysql.log - ERROR - run one<br>[&lt;StreamHandler \<stderr> (ERROR)&gt;]<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run two<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run two<br>[&lt;StreamHandler \<stderr> (ERROR)&gt;, &lt;StreamHandler \<stderr> (ERROR)&gt;]<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run three<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run three<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run three</stderr></stderr></stderr></p></blockquote><ol><li><code>logger.handlers</code>最初是一个空列表，执行‘logger.addHandler(ch)’添加一个‘StreamHandler’，输出一条日志</li><li>在第二次被调用时，<code>logger.handlers</code>已经存在一个‘StreamHandler’，再次执行‘logger.addHandler(ch)’就会再次添加一个‘StreamHandler’，此时的logger有两个‘StreamHandler’，输出两条重复的日志</li><li>在第三次被调用时，<code>logger.handlers</code>已经存在两个‘StreamHandler’，再次执行‘logger.addHandler(ch)’就会再次添加一个，此时的logger有三个‘StreamHandler’，输出三条重复的日志</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="1-改名换姓"><a href="#1-改名换姓" class="headerlink" title="1.改名换姓"></a>1.改名换姓</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为日志函数添加一个name，每次调用时传入不同的日志名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">(name)</span>:</span></span><br><span class="line">    logger = logging.getLogger(name)</span><br><span class="line"></span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setLevel(logging.ERROR)</span><br><span class="line">    fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">    ch.setFormatter(fmt)</span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log(<span class="string">'log1'</span>).error(<span class="string">'run one'</span>)</span><br><span class="line">my_log(<span class="string">'log2'</span>).error(<span class="string">'run two'</span>)</span><br><span class="line">my_log(<span class="string">'log3'</span>).error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>2018-06-21 13:40:51,685 - log1 - ERROR - run one<br>2018-06-21 13:40:51,685 - log2 - ERROR - run two<br>2018-06-21 13:40:51,685 - log3 - ERROR - run three</p></blockquote><h3 id="2-及时清理（logger-handlers-clear）"><a href="#2-及时清理（logger-handlers-clear）" class="headerlink" title="2.及时清理（logger.handlers.clear）"></a>2.及时清理（logger.handlers.clear）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line">    <span class="comment"># 每次被调用后，清空已经存在handler</span></span><br><span class="line">    logger.handlers.clear()</span><br><span class="line"></span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setLevel(logging.ERROR)</span><br><span class="line">    fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">    ch.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log().error(<span class="string">'run one'</span>)</span><br><span class="line">my_log().error(<span class="string">'run two'</span>)</span><br><span class="line">my_log().error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><p><strong>ps：removeHandler方法（兼容性较差）</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这种写法下的可以使用removeHandler方法(logger.handlers.clear也可以使用在这种写法的函数内)</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">(msg)</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line"></span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setLevel(logging.ERROR)</span><br><span class="line">    fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">    ch.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line">    logger.error(msg)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在使用完ch后从移除Handler</span></span><br><span class="line">    logger.removeHandler(ch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log(<span class="string">'run one'</span>)</span><br><span class="line">my_log(<span class="string">'run two'</span>)</span><br><span class="line">my_log(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><h3 id="3-用前判断"><a href="#3-用前判断" class="headerlink" title="3.用前判断"></a>3.用前判断</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line">    <span class="comment"># 判断logger是否已经添加过handler，是则直接返回logger对象，否则执行handler设定以及addHandler(ch)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> logger.handlers:</span><br><span class="line">        ch = logging.StreamHandler()</span><br><span class="line">        ch.setLevel(logging.ERROR)</span><br><span class="line">        fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">        ch.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">        logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log().error(<span class="string">'run one'</span>)</span><br><span class="line">my_log().error(<span class="string">'run two'</span>)</span><br><span class="line">my_log().error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    第一次遇到日志重复输出问题，那时还没有学习到面向对象编程的内容，当时并没有真正理解logging模块。学习完面向对象编程后，回过头来再思考这些问题有了豁然开朗的感觉。</p><p>​        比如起初对<code>logging.getLogger</code>的实际原理不是很理解，在学习了面向对象编程中的hasattr、getattr、setattr这样一些方法后就恍然大悟了。所以诸君如果现在还是对logging模块不太理解，不妨先不纠结于这些细节，继续学下去。</p><p>​    知识面扩充后，曾经的一些难题自然就会迎刃而解：）</p><hr><blockquote><p>参考内容：<br>luffycity : <a href="https://www.luffycity.com/home" target="_blank" rel="noopener">https://www.luffycity.com/home</a><br><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">The Python Standard Library</a><br><a href="https://blog.csdn.net/huilan_same" target="_blank" rel="noopener">huilan_same</a> ：<a href="https://blog.csdn.net/huilan_same/article/details/51858817" target="_blank" rel="noopener">https://blog.csdn.net/huilan_same/article/details/51858817</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES基础学习</title>
      <link href="/2018/10/17/ES6/"/>
      <url>/2018/10/17/ES6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是ECMAScript"><a href="#1-什么是ECMAScript" class="headerlink" title="1. 什么是ECMAScript"></a>1. 什么是ECMAScript</h2><blockquote><p>ECMAScript是一种由<a href="https://baike.baidu.com/item/Ecma%E5%9B%BD%E9%99%85" target="_blank" rel="noopener">Ecma国际</a>（前身为<a href="https://baike.baidu.com/item/%E6%AC%A7%E6%B4%B2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B6%E9%80%A0%E5%95%86%E5%8D%8F%E4%BC%9A/2052072" target="_blank" rel="noopener">欧洲计算机制造商协会</a>,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">程序设计语言</a>。这种语言在<a href="https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="noopener">万维网</a>上应用广泛，它往往被称为<a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a>或<a href="https://baike.baidu.com/item/JScript" target="_blank" rel="noopener">JScript</a>，所以它可以理解为是javascript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。<br><a id="more"></a></p></blockquote><h3 id="ECMAScript-与-JavaScript"><a href="#ECMAScript-与-JavaScript" class="headerlink" title="ECMAScript 与 JavaScript"></a>ECMAScript 与 JavaScript</h3><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p><p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p><p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p><h2 id="2-什么是ES6"><a href="#2-什么是ES6" class="headerlink" title="2. 什么是ES6"></a>2. 什么是ES6</h2><p><strong>ES6</strong>是继ES5之后的一次主要改进，语言规范由ES5.1时代的245页扩充至600页。</p><p>ES6增添了许多必要的特性，例如：模块和类，以及一些实用特性，例如Maps、Sets、Promises、生成器（Generators）等。</p><p>尽管ES6做了大量的更新，但是它依旧完全向后兼容以前的版本，标准化委员会决定避免由不兼容版本语言导致的“web体验破碎”。结果是，所有老代码都可以正常运行，整个过渡也显得更为平滑，但随之而来的问题是，开发者们抱怨了多年的老问题依然存在。</p><h2 id="3-ES6语法"><a href="#3-ES6语法" class="headerlink" title="3. ES6语法"></a>3. ES6语法</h2><h3 id="3-1-let命令"><a href="#3-1-let命令" class="headerlink" title="3.1 let命令"></a>3.1 let命令</h3><h4 id="3-1-1-基础用法"><a href="#3-1-1-基础用法" class="headerlink" title="3.1.1 基础用法"></a>3.1.1 基础用法</h4><p>es6新增了 let 命令，用来声明变量。它的用法类似于 var ，但是所声明的变量，只在let命令所在的代码块内有效。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  var b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure><p>上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错， var 声明的变量返回了正确的值。这表明， let 声明的变量只在它所在的代码块有效</p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i);</span><br><span class="line">// ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用<code>var</code>，最后输出的是<code>10</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p><p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  let i = &apos;abc&apos;;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br></pre></td></tr></table></figure><p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h4 id="3-1-2-不存在变量提升"><a href="#3-1-2-不存在变量提升" class="headerlink" title="3.1.2 不存在变量提升"></a>3.1.2 不存在变量提升</h4><p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// var 的情况</span><br><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">var foo = 2;</span><br><span class="line"></span><br><span class="line">// let 的情况</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line">let bar = 2;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h4 id="3-1-3-为什么需要块级作用域？"><a href="#3-1-3-为什么需要块级作用域？" class="headerlink" title="3.1.3 为什么需要块级作用域？"></a>3.1.3 为什么需要块级作用域？</h4><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p> 第一种场景，内层变量可能会覆盖外层变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &apos;hello world&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h4 id="3-1-4-不允许重复声明"><a href="#3-1-4-不允许重复声明" class="headerlink" title="3.1.4 不允许重复声明"></a>3.1.4 不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不能在函数内部重新声明参数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func(arg) &#123;</span><br><span class="line">  let arg; // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    let arg; // 不报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-const命令"><a href="#3-2-const命令" class="headerlink" title="3.2 const命令"></a>3.2 const命令</h3><h4 id="3-2-1-基本用法"><a href="#3-2-1-基本用法" class="headerlink" title="3.2.1 基本用法"></a>3.2.1 基本用法</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line"></span><br><span class="line">PI = 3;</span><br><span class="line">// TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure><p>上面代码表明改变常量的值会报错。</p><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const foo;</span><br><span class="line">// SyntaxError: Missing initializer in const declaration</span><br></pre></td></tr></table></figure><p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX // Uncaught ReferenceError: MAX is not defined</span><br></pre></td></tr></table></figure><p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  console.log(MAX); // ReferenceError</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var message = &quot;Hello!&quot;;</span><br><span class="line">let age = 25;</span><br><span class="line"></span><br><span class="line">// 以下两行都会报错</span><br><span class="line">const message = &quot;Goodbye!&quot;;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure><h3 id="3-3-模板字符串"><a href="#3-3-模板字符串" class="headerlink" title="3.3 模板字符串"></a>3.3 模板字符串</h3><p>传统的JavaScript语言，输出模板通常是这样的写的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;#result&apos;).append(</span><br><span class="line">  &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; +</span><br><span class="line">  &apos;items in your basket, &apos; +</span><br><span class="line">  &apos;&lt;em&gt;&apos; + basket.onSale +</span><br><span class="line">  &apos;&lt;/em&gt; are on sale!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;#result&apos;).append(`</span><br><span class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</span><br><span class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript &apos;\n&apos; is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1</span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">let name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let greeting = `\`Yo\` World!`;</span><br></pre></td></tr></table></figure><p>输入结果：<code>Yo</code> World!</p><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;#list&apos;).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><p>阮一峰：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a></p><p>维基百科： <a href="https://zh.wikipedia.org/wiki/ECMAScript" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/ECMAScript</a></p><p>百度百科：<a href="https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/17/hello-world/"/>
      <url>/2018/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="感谢每一个浏览本页面的人"><a href="#感谢每一个浏览本页面的人" class="headerlink" title="感谢每一个浏览本页面的人"></a>感谢每一个浏览本页面的人</h2><p>目前还是一个学习者</p><p>为了实现那些少年时代的愿景</p><p>还在努力的路上</p><h3 id="期待自己变得更加强大"><a href="#期待自己变得更加强大" class="headerlink" title="期待自己变得更加强大"></a>期待自己变得更加强大</h3><p>或许我爱的人也有机会看到这段话</p><p>知道吗</p><p>你是我所有的动力</p><h3 id="感谢你"><a href="#感谢你" class="headerlink" title="感谢你"></a>感谢你</h3>]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index%20-%20%E5%89%AF%E6%9C%AC.html"/>
      <url>/tags/index%20-%20%E5%89%AF%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
