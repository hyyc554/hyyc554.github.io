<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Django思维导图</title>
      <link href="/2018/11/21/Django%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2018/11/21/Django%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>Django基础</p><a id="more"></a><p><img src="https://s1.ax1x.com/2018/11/21/FCcB6S.png" alt="FCcB6S.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搞懂RESTful</title>
      <link href="/2018/11/20/%E4%B8%80%E3%80%81REST%E7%AE%80%E8%BF%B0/"/>
      <url>/2018/11/20/%E4%B8%80%E3%80%81REST%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、REST简述"><a href="#一、REST简述" class="headerlink" title="一、REST简述"></a>一、REST简述</h2><p>来自维基百科的解释：</p><a id="more"></a><blockquote><p><strong>表现层状态转换</strong>（REST，英文：<strong>Representational State Transfer</strong>）是<a href="https://zh.wikipedia.org/w/index.php?title=Roy_Thomas_Fielding&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Roy Thomas Fielding</a>博士于2000年在他的博士论文<a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2#cite_note-Fielding-Ch5-1" target="_blank" rel="noopener">[1]</a> 中提出来的一种<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="noopener">万维网</a><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">软件架构</a>风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本传输协议(HTTP)</a>之上而确定的一组约束和属性，是一种设计提供万维网络服务的<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">软件构建风格</a>。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6" target="_blank" rel="noopener">统一资源标识符</a>访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质(interoperability)。相对于其它种类的网络服务，例如 SOAP服务则是以本身所定义的操作集，来访问网络上的资源。</p><p>Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">云计算</a>之类的环境。客户端可以缓存数据以改进性能。</p><p>在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、<a href="https://baike.baidu.com/item/POST" target="_blank" rel="noopener">POST</a> 和 <a href="https://baike.baidu.com/item/DELETE" target="_blank" rel="noopener">DELETE</a>。<a href="https://baike.baidu.com/item/Hypermedia" target="_blank" rel="noopener">Hypermedia</a> 是应用程序状态的<a href="https://baike.baidu.com/item/%E5%BC%95%E6%93%8E/2874935" target="_blank" rel="noopener">引擎</a>，资源表示通过<a href="https://baike.baidu.com/item/%E8%B6%85%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">超链接</a>互联。</p></blockquote><p><img src="https://s1.ax1x.com/2018/11/20/F9ZCrt.png" alt="F9ZCrt.png"></p><h2 id="二、REST的解析"><a href="#二、REST的解析" class="headerlink" title="二、REST的解析"></a>二、REST的解析</h2><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。</p><p>如果一个架构符合REST原则，就称它为RESTful架构。</p><p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p><ul><li>REST从资源的角度类审视整个网络，它将分布在网络中某个节点的资源通过URL进行标识，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态</li><li>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”</li><li>所有的数据，不过是通过网络获取的还是操作（增删改查）的数据，都是资源，将一切数据视为资源是REST区别与其他架构风格的最本质属性</li><li>对于REST这种面向资源的架构风格，有人提出一种全新的结构理念，即：面向资源架构（ROA：Resource Oriented Architecture）</li></ul><h2 id="三、资源（Resources）"><a href="#三、资源（Resources）" class="headerlink" title="三、资源（Resources）"></a>三、资源（Resources）</h2><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h2 id="四、表现层（Representation）"><a href="#四、表现层（Representation）" class="headerlink" title="四、表现层（Representation）"></a>四、表现层（Representation）</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h2 id="五、状态转化（State-Transfer）"><a href="#五、状态转化（State-Transfer）" class="headerlink" title="五、状态转化（State Transfer）"></a>五、状态转化（State Transfer）</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p><h2 id="六、综述"><a href="#六、综述" class="headerlink" title="六、综述"></a>六、综述</h2><p>综合上面的解释，我们总结一下什么是RESTful架构：</p><p>　　（1）每一个URI代表一种资源；</p><p>　　（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><h2 id="七、误区"><a href="#七、误区" class="headerlink" title="七、误区"></a>七、误区</h2><p>RESTful架构有一些典型的设计误区。</p><p>最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p><p>举例来说，某个URI是 /posts/show/1 ，其中 show 是动词，这个URI就设计错了，正确的写法应该是 /posts/1 ，然后用 GET 方法表示 show 。</p><p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /accounts/1/transfer/500/to/2</span><br></pre></td></tr></table></figure><p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /transaction HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">　　</span><br><span class="line">from=1&amp;to=2&amp;amount=500.00</span><br></pre></td></tr></table></figure><p>另一个设计误区，就是在URI中加入版本号：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.example.com/app/1.0/foo</span><br><span class="line"></span><br><span class="line">http://www.example.com/app/1.1/foo</span><br><span class="line"></span><br><span class="line">http://www.example.com/app/2.0/foo</span><br></pre></td></tr></table></figure><p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460" target="_blank" rel="noopener">Versioning REST Services</a>）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: vnd.example-com.foo+json; version=1.0</span><br><span class="line"></span><br><span class="line">Accept: vnd.example-com.foo+json; version=1.1</span><br><span class="line"></span><br><span class="line">Accept: vnd.example-com.foo+json; version=2.0</span><br></pre></td></tr></table></figure><h2 id="八、RESTful-API设计"><a href="#八、RESTful-API设计" class="headerlink" title="八、RESTful API设计"></a>八、RESTful API设计</h2><h3 id="8-1-协议"><a href="#8-1-协议" class="headerlink" title="8.1 协议"></a>8.1 协议</h3><p>API与用户的通信协议，总是使用<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">HTTPs协议</a>。</p><h3 id="8-2-域名"><a href="#8-2-域名" class="headerlink" title="8.2 域名"></a>8.2 域名</h3><p>应该尽量将API部署在专用域名之下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//api.example.com</span></span><br></pre></td></tr></table></figure><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//example.org/api/</span></span><br></pre></td></tr></table></figure><h3 id="8-3-版本（Versioning）"><a href="#8-3-版本（Versioning）" class="headerlink" title="8.3 版本（Versioning）"></a>8.3 版本（Versioning）</h3><p>应该将API的版本号放入URL。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//api.example.com/v1/</span></span><br></pre></td></tr></table></figure><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<a href="https://developer.github.com/v3/media/#request-specific-version" target="_blank" rel="noopener">Github</a>采用这种做法。</p><h3 id="8-4-路径（Endpoint）"><a href="#8-4-路径（Endpoint）" class="headerlink" title="8.4 路径（Endpoint）"></a>8.4 路径（Endpoint）</h3><p>路径又称”终点”（endpoint），表示API的具体网址。</p><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><blockquote><ul><li><a href="https://api.example.com/v1/zoos" target="_blank" rel="noopener">https://api.example.com/v1/zoos</a></li><li><a href="https://api.example.com/v1/animals" target="_blank" rel="noopener">https://api.example.com/v1/animals</a></li><li><a href="https://api.example.com/v1/employees" target="_blank" rel="noopener">https://api.example.com/v1/employees</a></li></ul></blockquote><h3 id="8-5-HTTP动词"><a href="#8-5-HTTP动词" class="headerlink" title="8.5 HTTP动词"></a>8.5 HTTP动词</h3><p>对于资源的具体操作类型，由HTTP动词表示。</p><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>还有两个不常用的HTTP动词。</p><ul><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li></ul><p>下面是一些例子。</p><ul><li>GET /zoos：列出所有动物园</li><li>POST /zoos：新建一个动物园</li><li>GET /zoos/ID：获取某个指定动物园的信息</li><li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li><li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li><li>DELETE /zoos/ID：删除某个动物园</li><li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li><li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li></ul><h3 id="8-6-过滤信息（Filtering）"><a href="#8-6-过滤信息（Filtering）" class="headerlink" title="8.6 过滤信息（Filtering）"></a>8.6 过滤信息（Filtering）</h3><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><p>下面是一些常见的参数。</p><ul><li>?limit=10：指定返回记录的数量</li><li>?offset=10：指定返回记录的开始位置。</li><li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li><li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li><li>?animal_type_id=1：指定筛选条件</li></ul><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><h3 id="8-7-状态码（Status-Codes）"><a href="#8-7-状态码（Status-Codes）" class="headerlink" title="8.7 状态码（Status Codes）"></a>8.7 状态码（Status Codes）</h3><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><ul><li><strong>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</strong></li><li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li><li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li><li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li><li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li><li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li><li><strong>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</strong></li><li><strong>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</strong></li><li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li><li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li><li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li><li><strong>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</strong></li></ul><p>状态码的完全列表参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a>。</p><h3 id="8-8-错误处理（Error-handling）"><a href="#8-8-错误处理（Error-handling）" class="headerlink" title="8.8 错误处理（Error handling）"></a>8.8 错误处理（Error handling）</h3><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-9-返回结果"><a href="#8-9-返回结果" class="headerlink" title="8.9 返回结果"></a>8.9 返回结果</h3><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><ul><li>GET /collection：返回资源对象的列表（数组）</li><li>GET /collection/resource：返回单个资源对象</li><li>POST /collection：返回新生成的资源对象</li><li>PUT /collection/resource：返回完整的资源对象</li><li>PATCH /collection/resource：返回完整的资源对象</li><li>DELETE /collection/resource：返回一个空文档</li></ul><h3 id="8-10-Hypermedia-API"><a href="#8-10-Hypermedia-API" class="headerlink" title="8.10 Hypermedia API"></a>8.10 Hypermedia API</h3><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p><p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"link"</span>: &#123;</span><br><span class="line">  <span class="string">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="string">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="string">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p><p>Hypermedia API的设计被称为<a href="http://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener">HATEOAS</a>。Github的API就是这种设计，访问<a href="https://api.github.com/" target="_blank" rel="noopener">api.github.com</a>会得到一个所有可用API的网址列表。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,</span><br><span class="line">  <span class="string">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href="https://api.github.com/user" target="_blank" rel="noopener">api.github.com/user</a>，然后就得到了下面结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"Requires authentication"</span>,</span><br><span class="line">  <span class="string">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><h3 id="8-11-其他"><a href="#8-11-其他" class="headerlink" title="8.11 其他"></a>8.11 其他</h3><p>（1）API的身份认证应该使用<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">OAuth 2.0</a>框架。</p><p>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><p>阮一峰：<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p><p>YUAN先生： <a href="https://www.cnblogs.com/yuanchenqi/articles/8742684.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanchenqi/articles/8742684.html</a></p><p>维基百科: <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Representational_state_transfer</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 软件风格 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux相关思维导图</title>
      <link href="/2018/11/19/Linux%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2018/11/19/Linux%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>这里主要收集一些我认为不错的思维导图，请联系我删除<br><a id="more"></a></p><h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><img src="https://s1.ax1x.com/2018/11/19/FSzKOJ.png" alt="FSzKOJ.png"></p><h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><p><img src="https://s1.ax1x.com/2018/11/19/FSzb1U.png" alt="FSzb1U.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维导图,Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>源码剖析Django REST framework的认证方式</title>
      <link href="/2018/11/19/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Django%20REST%20framework%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/11/19/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Django%20REST%20framework%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>由Django的CBV模式流程，可以知道在<code>url匹配完成后，会执行自定义的类中的as_view方法</code>。</p><p>如果自定义的类中没有定义<code>as_view方法</code>，根据面向对象中类的继承可以知道，则<code>会执行其父类View中的as_view方法</code></p><p><code>在Django的View的as_view方法中，又会调用dispatch方法</code>。</p><p>现在来看看Django rest framework的认证流程</p><a id="more"></a><blockquote><p>Django restframework是基于Django的框架，所以基于CBV的模式也会执行自定义的类中的as_view方法</p></blockquote><p>先新建一个项目，配置url</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&apos;^user/&apos;, views.UserView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>views.py文件内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render,HttpResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line"></span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        print(request.__dict__)</span><br><span class="line">        print(request.user)</span><br><span class="line">        return HttpResponse(&quot;UserView GET&quot;)</span><br><span class="line"></span><br><span class="line">    def post(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&quot;UserView POST&quot;)</span><br></pre></td></tr></table></figure><p>启动项目，用浏览器向<code>http://127.0.0.1:8000/user/</code>发送get请求</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180825183747075-1935268768.png" alt="img"></p><p>可以知道请求发送成功。现在来看看源码流程，由于UserView继承APIView，查看APIView中的as_view方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class APIView(View):</span><br><span class="line">    ...</span><br><span class="line">    @classmethod</span><br><span class="line">    def as_view(cls, **initkwargs):</span><br><span class="line">        if isinstance(getattr(cls, &apos;queryset&apos;, None), models.query.QuerySet):</span><br><span class="line">            def force_evaluation():</span><br><span class="line">                raise RuntimeError(</span><br><span class="line">                    &apos;Do not evaluate the `.queryset` attribute directly, &apos;</span><br><span class="line">                    &apos;as the result will be cached and reused between requests. &apos;</span><br><span class="line">                    &apos;Use `.all()` or call `.get_queryset()` instead.&apos;</span><br><span class="line">                )</span><br><span class="line">            cls.queryset._fetch_all = force_evaluation</span><br><span class="line"></span><br><span class="line">        view = super(APIView, cls).as_view(**initkwargs)</span><br><span class="line">        view.cls = cls</span><br><span class="line">        view.initkwargs = initkwargs</span><br><span class="line">        return csrf_exempt(view)</span><br></pre></td></tr></table></figure><p><code>通过super来执行APIView的父类Django的View中的as_view方法</code>。上一篇文章<a href="https://www.cnblogs.com/renpingsheng/p/9531649.html" target="_blank" rel="noopener">源码解析Django CBV的本质</a>中已经知道，View类的as_view方法会调用dispatch方法。</p><p>View类的as_view方法源码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class View(object):</span><br><span class="line">    ...</span><br><span class="line">    @classonlymethod</span><br><span class="line">    def as_view(cls, **initkwargs):</span><br><span class="line">        ...</span><br><span class="line">        def view(request, *args, **kwargs):</span><br><span class="line">            self = cls(**initkwargs)</span><br><span class="line">            if hasattr(self, &apos;get&apos;) and not hasattr(self, &apos;head&apos;):</span><br><span class="line">                self.head = self.get</span><br><span class="line">            self.request = request</span><br><span class="line">            self.args = args</span><br><span class="line">            self.kwargs = kwargs</span><br><span class="line">            return self.dispatch(request, *args, **kwargs)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>as_view方法中的self实际上指的是自定义的UserView这个类</code>，上面的代码会执行UserView类中dispatch方法。</p><p>由于UserView类中并没有定义dispatch方法，而UserView类继承自Django restframework的APIView类，所以会执行APIView类中的dispatch方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dispatch(self, request, *args, **kwargs):</span><br><span class="line">    self.args = args</span><br><span class="line">    self.kwargs = kwargs</span><br><span class="line">    request = self.initialize_request(request, *args, **kwargs)</span><br><span class="line">    self.request = request</span><br><span class="line">    self.headers = self.default_response_headers  # deprecate?</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        self.initial(request, *args, **kwargs)</span><br><span class="line">        if request.method.lower() in self.http_method_names:</span><br><span class="line">            handler = getattr(self, request.method.lower(),</span><br><span class="line">                              self.http_method_not_allowed)</span><br><span class="line">        else:</span><br><span class="line">            handler = self.http_method_not_allowed</span><br><span class="line"></span><br><span class="line">        response = handler(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    except Exception as exc:</span><br><span class="line">        response = self.handle_exception(exc)</span><br><span class="line"></span><br><span class="line">    self.response = self.finalize_response(request, response, *args, **kwargs)</span><br><span class="line">    return self.response</span><br></pre></td></tr></table></figure><p>可以看到，<code>先执行initialize_request方法处理浏览器发送的request请求</code>。</p><p>来看看initialize_request方法的源码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def initialize_request(self, request, *args, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Returns the initial request object.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    parser_context = self.get_parser_context(request)</span><br><span class="line"></span><br><span class="line">    return Request(</span><br><span class="line">        request,</span><br><span class="line">        parsers=self.get_parsers(),</span><br><span class="line">        authenticators=self.get_authenticators(),</span><br><span class="line">        negotiator=self.get_content_negotiator(),</span><br><span class="line">        parser_context=parser_context</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>在initialize_request方法里，把浏览器发送的request和restframework的处理器，认证，选择器等对象列表作为参数实例化Request类中得到新的request对象并返回，其中跟认证相关的对象就是authenticators。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_authenticators(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Instantiates and returns the list of authenticators that this view can use.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return [auth() for auth in self.authentication_classes]</span><br><span class="line">get_authenticators方法通过列表生成式得到一个列表，列表中包含认证类实例化后的对象</span><br></pre></td></tr></table></figure><p>在这里，<code>authentication_classes来自于api_settings的配置</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES</span><br></pre></td></tr></table></figure><p>通过查看api_settings的源码可以知道，可以在项目的settings.py文件中进行认证相关的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)</span><br><span class="line"></span><br><span class="line">def reload_api_settings(*args, **kwargs):</span><br><span class="line">    setting = kwargs[&apos;setting&apos;]</span><br><span class="line">    if setting == &apos;REST_FRAMEWORK&apos;:</span><br><span class="line">        api_settings.reload()</span><br></pre></td></tr></table></figure><p>Django restframework通过initialize_request方法对原始的request进行一些封装后实例化得到新的request对象</p><p>然后执行initial方法来处理新得到的request对象，再来看看initial方法中又执行了哪些操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def initial(self, request, *args, **kwargs):</span><br><span class="line">    self.format_kwarg = self.get_format_suffix(**kwargs)</span><br><span class="line">    neg = self.perform_content_negotiation(request)</span><br><span class="line">    request.accepted_renderer, request.accepted_media_type = neg</span><br><span class="line"></span><br><span class="line">    version, scheme = self.determine_version(request, *args, **kwargs)</span><br><span class="line">    request.version, request.versioning_scheme = version, scheme</span><br><span class="line"></span><br><span class="line">    self.perform_authentication(request)</span><br><span class="line">    self.check_permissions(request)</span><br><span class="line">    self.check_throttles(request)</span><br></pre></td></tr></table></figure><p>由上面的源码可以知道，在initial方法中，<code>执行perform_authentication来对request对象进行认证操作</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def perform_authentication(self, request):</span><br><span class="line">    request.user</span><br><span class="line">perform_authentication方法中调用执行request中的user方法`，`这里的request是封装了原始request,认证对象列表，处理器列表等之后的request对象</span><br><span class="line">class Request(object):</span><br><span class="line">    ...</span><br><span class="line">    @property</span><br><span class="line">    def user(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the user associated with the current request, as authenticated</span><br><span class="line">        by the authentication classes provided to the request.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not hasattr(self, &apos;_user&apos;):</span><br><span class="line">            with wrap_attributeerrors():</span><br><span class="line">                self._authenticate()</span><br><span class="line">        return self._user</span><br></pre></td></tr></table></figure><p>从request中获取<code>_user</code>的值，如果获取到则执行<code>_authenticate方法</code>，否则返回<code>_user</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _authenticate(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Attempt to authenticate the request using each authentication instance</span><br><span class="line">    in turn.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    for authenticator in self.authenticators:</span><br><span class="line">        try:</span><br><span class="line">            user_auth_tuple = authenticator.authenticate(self)</span><br><span class="line">        except exceptions.APIException:</span><br><span class="line">            self._not_authenticated()</span><br><span class="line">            raise</span><br><span class="line"></span><br><span class="line">        if user_auth_tuple is not None:</span><br><span class="line">            self._authenticator = authenticator</span><br><span class="line">            self.user, self.auth = user_auth_tuple</span><br><span class="line">            return</span><br></pre></td></tr></table></figure><p>在这里<code>self.authenticators</code>实际上是<code>get_authenticators</code>方法执行完成后返回的对象列表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Request(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, request, parsers=None, authenticators=None,</span><br><span class="line">                 negotiator=None, parser_context=None):</span><br><span class="line">        assert isinstance(request, HttpRequest), (</span><br><span class="line">            &apos;The `request` argument must be an instance of &apos;</span><br><span class="line">            &apos;`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.&apos;</span><br><span class="line">            .format(request.__class__.__module__, request.__class__.__name__)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self._request = request</span><br><span class="line">        self.parsers = parsers or ()</span><br><span class="line">        self.authenticators = authenticators or ()</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>循环认证的对象列表,<code>执行每一个认证方法的类中的authenticate方法</code>，得到通过认证的用户及用户的口令的元组，并返回元组完成认证的流程</p><p>在<code>_authenticate</code>方法中使用了try/except方法来捕获authenticate方法可能出现的异常</p><p>如果出现异常,就调用<code>_not_authenticated</code>方法来设置返回元组中的用户及口令并终止程序继续运行</p><p>总结，Django restframework的认证流程如下图</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180825184058007-932847314.jpg" alt="img"></p><h2 id="Django-restframework内置的认证类"><a href="#Django-restframework内置的认证类" class="headerlink" title="Django restframework内置的认证类"></a>Django restframework内置的认证类</h2><p>在上面的项目例子中，在UsersView的get方法中，打印<code>authentication_classes</code>和<code>request._user</code>的值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserView(APIView):</span><br><span class="line">    # authentication_classes = [MyAuthentication,]</span><br><span class="line"></span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        print(&apos;authentication_classes:&apos;, self.authentication_classes)</span><br><span class="line">        print(request._user)</span><br><span class="line">        return HttpResponse(&quot;UserView GET&quot;)</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authentication_classes: [&lt;class &apos;rest_framework.authentication.SessionAuthentication&apos;&gt;, &lt;class &apos;rest_framework.authentication.BasicAuthentication&apos;&gt;]</span><br><span class="line">AnonymousUser</span><br></pre></td></tr></table></figure><p>由此可以知道,<code>authentication_classes</code>默认是Django restframework内置的认证类，而request._user为AnonymousUser,因为发送GET请求，用户没有进行登录认证，所以为匿名用户</p><p>在视图函数中导入这两个类,再查看这两个类的源码,可以知道</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BasicAuthentication(BaseAuthentication):</span><br><span class="line"></span><br><span class="line">    www_authenticate_realm = &apos;api&apos; </span><br><span class="line"></span><br><span class="line">    def authenticate(self, request):</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_credentials(self, userid, password):</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">class SessionAuthentication(BaseAuthentication):</span><br><span class="line"></span><br><span class="line">    def authenticate(self, request):</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def enforce_csrf(self, request):</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">class TokenAuthentication(BaseAuthentication):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>从上面的源码可以发现,这个文件中不仅定义了<code>SessionAuthentication</code>和<code>BasicAuthentication</code>这两个类,</p><p>相关的类还有<code>TokenAuthentication</code>,而且这三个认证相关的类都是继承自<code>BaseAuthentication</code>类</p><p>从上面的源码可以大概知道,这三个继承自<code>BaseAuthentication</code>的类是Django restframework内置的认证方式.</p><h2 id="自定义认证功能"><a href="#自定义认证功能" class="headerlink" title="自定义认证功能"></a>自定义认证功能</h2><p>在上面我们知道,Request会调用认证相关的类及方法,<code>APIView</code>会设置认证相关的类及方法</p><p>所以如果想自定义认证功能,只需要重写<code>authenticate</code>方法及<code>authentication_classes</code>的对象列表即可</p><p>修改上面的例子的views.py文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework import exceptions</span><br><span class="line"></span><br><span class="line">TOKEN_LIST = [  # 定义token_list</span><br><span class="line">    &apos;aabbcc&apos;,</span><br><span class="line">    &apos;ddeeff&apos;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">class UserAuthView(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        tk = request._request.GET.get(&quot;tk&quot;)  # request._request为原生的request</span><br><span class="line"></span><br><span class="line">        if tk in TOKEN_LIST:</span><br><span class="line">            return (tk, None)  # 返回一个元组</span><br><span class="line">        raise exceptions.AuthenticationFailed(&quot;用户认证失败&quot;)</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        # 如果不定义authenticate_header方法会抛出异常</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    authentication_classes = [UserAuthView, ]</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        print(request.user)</span><br><span class="line"></span><br><span class="line">        return HttpResponse(&quot;UserView GET&quot;)</span><br></pre></td></tr></table></figure><p>启动项目,在浏览器中输入<code>http://127.0.0.1:8000/users/?tk=aabbcc</code>,然后回车,在服务端后台会打印</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aabbcc</span><br></pre></td></tr></table></figure><p>把浏览器中的url换为<code>http://127.0.0.1:8000/users/?tk=ddeeff</code>,后台打印信息则变为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ddeeff</span><br></pre></td></tr></table></figure><p>这样就实现REST framework的自定义认证功能</p><h2 id="Django-restframework认证的扩展"><a href="#Django-restframework认证的扩展" class="headerlink" title="Django restframework认证的扩展"></a>Django restframework认证的扩展</h2><h3 id="基于Token进行用户认证"><a href="#基于Token进行用户认证" class="headerlink" title="基于Token进行用户认证"></a>基于Token进行用户认证</h3><p>修改上面的项目，在urls.py文件中添加一条路由记录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&apos;^admin/&apos;, admin.site.urls),</span><br><span class="line">    url(r&apos;^users/&apos;,views.UsersView.as_view()),</span><br><span class="line">    url(r&apos;^auth/&apos;,views.AuthView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>修改视图函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render,HttpResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line"></span><br><span class="line">def gen_token(username):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    利用时间和用户名生成用户token</span><br><span class="line">    :param username: </span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import time</span><br><span class="line">    import hashlib</span><br><span class="line">    ctime=str(time.time())</span><br><span class="line">    hash=hashlib.md5(username.encode(&quot;utf-8&quot;))</span><br><span class="line">    hash.update(ctime.encode(&quot;utf-8&quot;))</span><br><span class="line">    return hash.hexdigest()</span><br><span class="line"></span><br><span class="line">class AuthView(APIView):</span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        获取用户提交的用户名和密码，如果用户名和密码正确，则生成token，并返回给用户</span><br><span class="line">        :param request:</span><br><span class="line">        :param args:</span><br><span class="line">        :param kwargs:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = &#123;&apos;code&apos;: 1000, &apos;msg&apos;: None&#125;</span><br><span class="line">        user = request.data.get(&quot;user&quot;)</span><br><span class="line">        pwd = request.data.get(&quot;pwd&quot;)</span><br><span class="line"></span><br><span class="line">        from app01 import models</span><br><span class="line">        user_obj = models.UserInfo.objects.filter(user=user, pwd=pwd).first()</span><br><span class="line"></span><br><span class="line">        if user_obj:</span><br><span class="line">            token = gen_token(user) # 生成用户口令</span><br><span class="line"></span><br><span class="line">            # 如果数据库中存在口令则更新,如果数据库中不存在口令则创建用户口令</span><br><span class="line">            models.Token.objects.update_or_create(user=user_obj, defaults=&#123;&apos;token&apos;: token&#125;)</span><br><span class="line">            print(&quot;user_token:&quot;, token)</span><br><span class="line">            res[&apos;code&apos;] = 1001</span><br><span class="line">            res[&apos;token&apos;] = token</span><br><span class="line">        else:</span><br><span class="line">            res[&apos;msg&apos;] = &quot;用户名或密码错误&quot;</span><br><span class="line"></span><br><span class="line">        return JsonResponse(res)</span><br><span class="line">    </span><br><span class="line">class UserAuthView(BaseAuthentication):</span><br><span class="line">    def authenticate(self,request):</span><br><span class="line">        tk=request.query_params.GET.get(&quot;tk&quot;)   # 获取请求头中的用户token</span><br><span class="line"></span><br><span class="line">        from app01 import models</span><br><span class="line"></span><br><span class="line">        token_obj=models.Token.objects.filter(token=tk).first()</span><br><span class="line"></span><br><span class="line">        if token_obj:   # 用户数据库中已经存在用户口令返回认证元组</span><br><span class="line">            return (token_obj.user,token_obj)</span><br><span class="line"></span><br><span class="line">        raise exceptions.AuthenticationFailed(&quot;认证失败&quot;)</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self,request):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class UsersView(APIView):</span><br><span class="line">    authentication_classes = [UserAuthView,]</span><br><span class="line"></span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line"></span><br><span class="line">        return HttpResponse(&quot;.....&quot;)</span><br></pre></td></tr></table></figure><p>创建用户数据库的类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class UserInfo(models.Model):</span><br><span class="line">    user=models.CharField(max_length=32)</span><br><span class="line">    pwd=models.CharField(max_length=64)</span><br><span class="line">    email=models.CharField(max_length=64)</span><br><span class="line"></span><br><span class="line">class Token(models.Model):</span><br><span class="line">    user=models.OneToOneField(UserInfo)</span><br><span class="line">    token=models.CharField(max_length=64)</span><br></pre></td></tr></table></figure><p>创建数据库,并添加两条用户记录</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201711/1133627-20171126000140781-1551141195.png" alt="img"></p><p>再创建一个test_client.py文件,来发送post请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">response=requests.post(</span><br><span class="line">    url=&quot;http://127.0.0.1:8000/auth/&quot;,</span><br><span class="line">    data=&#123;&apos;user&apos;:&apos;user1&apos;,&apos;pwd&apos;:&apos;user123&apos;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(&quot;response_text:&quot;,response.text)</span><br></pre></td></tr></table></figure><p>启动Django项目,运行test_client.py文件,则项目的响应信息为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response_text: &#123;&quot;code&quot;: 1001, &quot;msg&quot;: null, &quot;token&quot;: &quot;eccd2d256f44cb25b58ba602fe7eb42d&quot;&#125;</span><br></pre></td></tr></table></figure><p>由此,就完成了自定义的基于token的用户认证</p><p>如果想在项目中使用自定义的认证方式时,可以在<code>authentication_classes</code>继承刚才的认证的类即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authentication_classes = [UserAuthView,]</span><br></pre></td></tr></table></figure><h2 id="全局自定义认证"><a href="#全局自定义认证" class="headerlink" title="全局自定义认证"></a>全局自定义认证</h2><p>在正常的项目中，一个用户登录成功之后，进入自己的主页，可以看到很多内容，比如用户的订单，用户的收藏，用户的主页等</p><p>此时，难倒要在每个视图类中都定义authentication_classes，然后在authentication_classes中追加自定义的认证类吗？</p><p>通过对Django restframework认证的源码分析知道，可以直接在项目的settings.py配置文件中引入自定义的认证类，即可以对所有的url进行用户认证流程</p><p>在应用app01目录下创建utils包，在utils包下创建auth.py文件，内容为自定义的认证类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework import exceptions</span><br><span class="line">from api import models</span><br><span class="line"></span><br><span class="line">class Authtication(object):</span><br><span class="line">    def authenticate(self,request):</span><br><span class="line">        token = request._request.GET.get(&quot;token&quot;)       # 获取浏览器传递的token</span><br><span class="line">        token_obj = models.UserToken.objects.filter(token=token).first()    # 到数据库中进行token查询，判断用户是否通过认证</span><br><span class="line">        if not token_obj:</span><br><span class="line">            raise exceptions.AuthenticationFailed(&quot;用户认证失败&quot;)</span><br><span class="line"></span><br><span class="line">        # restframework会将元组赋值给request,以供后面使用</span><br><span class="line">        return (token_obj.user,token_obj)</span><br><span class="line">    </span><br><span class="line">    # 必须创建authenticate_header方法，否则会抛出异常</span><br><span class="line">    def authenticate_header(self,request):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>在settings.py文件中添加内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    &apos;DEFAULT_AUTHENTICATION_CLASSES&apos;:[&apos;app01.utils.auth.Authtication&apos;,]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改views.py文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line"></span><br><span class="line">def gen_token(username):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    利用时间和用户名生成用户token</span><br><span class="line">    :param username:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import time</span><br><span class="line">    import hashlib</span><br><span class="line">    ctime = str(time.time())</span><br><span class="line">    hash = hashlib.md5(username.encode(&quot;utf-8&quot;))</span><br><span class="line">    hash.update(ctime.encode(&quot;utf-8&quot;))</span><br><span class="line">    return hash.hexdigest()</span><br><span class="line"></span><br><span class="line">class AuthView(APIView):</span><br><span class="line">    authentication_classes = []     # 在这里定义authentication_classes后，用户访问auth页面不需要进行认证</span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        获取用户提交的用户名和密码，如果用户名和密码正确，则生成token，并返回给用户</span><br><span class="line">        :param request:</span><br><span class="line">        :param args:</span><br><span class="line">        :param kwargs:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = &#123;&apos;code&apos;: 1000, &apos;msg&apos;: None&#125;</span><br><span class="line">        user = request.data.get(&quot;user&quot;)</span><br><span class="line">        pwd = request.data.get(&quot;pwd&quot;)</span><br><span class="line"></span><br><span class="line">        from app01 import models</span><br><span class="line">        user_obj = models.UserInfo.objects.filter(user=user, pwd=pwd).first()</span><br><span class="line"></span><br><span class="line">        if user_obj:</span><br><span class="line">            token = gen_token(user)  # 生成用户口令</span><br><span class="line"></span><br><span class="line">            # 如果数据库中存在口令则更新,如果数据库中不存在口令则创建用户口令</span><br><span class="line">            models.Token.objects.update_or_create(user=user_obj, defaults=&#123;&apos;token&apos;: token&#125;)</span><br><span class="line">            print(&quot;user_token:&quot;, token)</span><br><span class="line">            res[&apos;code&apos;] = 1001</span><br><span class="line">            res[&apos;token&apos;] = token</span><br><span class="line">        else:</span><br><span class="line">            res[&apos;msg&apos;] = &quot;用户名或密码错误&quot;</span><br><span class="line"></span><br><span class="line">        return JsonResponse(res)</span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        return HttpResponse(&quot;UserView GET&quot;)</span><br><span class="line"></span><br><span class="line">class OrderView(APIView):</span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&quot;OrderView GET&quot;)</span><br></pre></td></tr></table></figure><p>启动项目，使用POSTMAN向<code>http://127.0.0.1:8000/order/?token=eccd2d256f44cb25b58ba602fe7eb42d</code>和<code>http://127.0.0.1:8000/user/?token=eccd2d256f44cb25b58ba602fe7eb42d</code>发送GET请求，响应结果如下</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225750139-1198840701.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225755562-137171019.png" alt="img"></p><p>在url中不带token,使用POSTMAN向<code>http://127.0.0.1:8000/order/</code>和<code>http://127.0.0.1:8000/user/</code>发送GET请求，则会出现<code>&quot;认证失败&quot;</code>的提示</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225715170-517425689.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225720650-323643037.png" alt="img"></p><p>由此可以知道，在settings.py配置文件中配置自定义的认证类也可以实现用户认证功能</p><h2 id="配置匿名用户"><a href="#配置匿名用户" class="headerlink" title="配置匿名用户"></a>配置匿名用户</h2><p>修改settings.py文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    &apos;DEFAULT_AUTHENTICATION_CLASSES&apos;: [&apos;app01.utils.auth.Authtication&apos;, ],</span><br><span class="line">    &apos;UNAUTHENTICATED_USER&apos;: lambda :&quot;匿名用户&quot;,     # 用户未登录时显示的名称</span><br><span class="line">    &apos;UNAUTHENTICATED_TOKEN&apos;: lambda :&quot;无效token&quot;, # 用户未登录时打印的token名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改views.py文件中的OrderView类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OrderView(APIView):</span><br><span class="line">    authentication_classes = []         # authentication_classes为空列表表示视图类不进行认证</span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return HttpResponse(&quot;OrderView GET&quot;)</span><br></pre></td></tr></table></figure><p>使用浏览器向<code>http://127.0.0.1:8000/order/</code>发送GET请求，后台打印</p><p><img src="https://images2018.cnblogs.com/blog/1133627/201808/1133627-20180826225705126-1550086890.png" alt="img"></p><p>这说明在settings.py文件中配置的匿名用户和匿名用户的token起到作用</p><blockquote><p>建议把匿名用户及匿名用户的token都设置为:None</p></blockquote><h2 id="Django-restframework内置的认证类-1"><a href="#Django-restframework内置的认证类-1" class="headerlink" title="Django restframework内置的认证类"></a>Django restframework内置的认证类</h2><p>从rest_framework中导入authentication</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework import authentication</span><br></pre></td></tr></table></figure><p>可以看到Django restframework内置的认证类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BaseAuthentication(object):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BasicAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_credentials(self, userid, password, request=None):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SessionAuthentication(BaseAuthentication):</span><br><span class="line"></span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def enforce_csrf(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TokenAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_credentials(self, key):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RemoteUserAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>可以看到，Django restframework内置的认证包含下面的四种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BasicAuthentication</span><br><span class="line">SessionAuthentication</span><br><span class="line">TokenAuthentication</span><br><span class="line">RemoteUserAuthentication</span><br></pre></td></tr></table></figure><p>而这四种认证类都继承自<code>BaseAuthentication</code>，<code>在BaseAuthentication中定义了两个方法：authenticate和authenticate_header</code></p><p>总结：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了让认证更规范，自定义的认证类要继承 BaseAuthentication类</span><br><span class="line">自定义认证类必须要实现authenticate和authenticate_header方法</span><br><span class="line">authenticate_header方法的作用：在认证失败的时候，给浏览器返回的响应头，可以直接pass，不实现authenticate_header程序会抛出异常</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL分页limit速度太慢的优化方法</title>
      <link href="/2018/11/19/MySQL%E5%88%86%E9%A1%B5limit%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/19/MySQL%E5%88%86%E9%A1%B5limit%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="limit用法"><a href="#limit用法" class="headerlink" title="limit用法"></a>limit用法</h2><p>在我们使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？不用担心，mysql已经为我们提供了这样一个功能。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的<code>偏移量</code>，第二个参数指定返回记录行的最大数目。<code>初始记录行的偏移量是 0(而不是 1)</code>： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</span><br></pre></td></tr></table></figure><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</span><br></pre></td></tr></table></figure><p>如果只给定一个参数，它表示返回最大的记录行数目： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行</span><br></pre></td></tr></table></figure><p>换句话说，<code>LIMIT n</code> 等价于<code>LIMIT 0,n</code>。</p><h2 id="Mysql的分页查询语句的性能分析"><a href="#Mysql的分页查询语句的性能分析" class="headerlink" title="Mysql的分页查询语句的性能分析"></a><strong>Mysql的分页查询语句的性能分析</strong></h2><p>MySql分页sql语句，如果和MSSQL的TOP语法相比，那么MySQL的LIMIT语法要显得优雅了许多。使用它来分页是再自然不过的事情了。</p><h3 id="最基本的分页方式："><a href="#最基本的分页方式：" class="headerlink" title="最基本的分页方式："></a><strong>最基本的分页方式：</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ...</span><br></pre></td></tr></table></figure><p>在中小数据量的情况下，这样的SQL足够用了，唯一需要注意的问题就是确保使用了索引：举例来说，如果实际SQL类似下面语句，那么在category_id, id两列上建立复合索引比较好：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10</span><br></pre></td></tr></table></figure><h3 id="子查询的分页方式："><a href="#子查询的分页方式：" class="headerlink" title="子查询的分页方式："></a><strong>子查询的分页方式：</strong></h3><p>随着数据量的增加，页数会越来越多，查看后几页的SQL就可能类似：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 10</span><br></pre></td></tr></table></figure><p>一言以蔽之，就是越往后分页，<code>LIMIT语句的偏移量就会越大，速度也会明显变慢</code>。</p><p>此时，我们可以通过子查询的方式来提高分页效率，大致如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM articles WHERE id &gt;= </span><br><span class="line">(SELECT id FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 1) LIMIT 10</span><br></pre></td></tr></table></figure><h3 id="JOIN分页方式"><a href="#JOIN分页方式" class="headerlink" title="JOIN分页方式"></a>JOIN分页方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `content` AS t1 </span><br><span class="line">JOIN (SELECT id FROM `content` ORDER BY id desc LIMIT &quot;.($page-1)*$pagesize.&quot;, 1) AS t2 </span><br><span class="line">WHERE t1.id &lt;= t2.id ORDER BY t1.id desc LIMIT $pagesize;</span><br></pre></td></tr></table></figure><p>经过我的测试，join分页和子查询分页的效率基本在一个等级上，消耗的时间也基本一致。 explain SQL语句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id select_type table type possible_keys key key_len ref rows Extra</span><br><span class="line">1 PRIMARY &lt;derived2&gt; system NULL NULL NULL NULL 1 </span><br><span class="line">1 PRIMARY t1 range PRIMARY PRIMARY 4 NULL 6264 Using where</span><br><span class="line">2 DERIVED content index NULL PRIMARY 4 NULL 27085 Using index</span><br></pre></td></tr></table></figure><p>为什么会这样呢？因为子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。</p><p>实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python——回顾常用的库</title>
      <link href="/2018/11/16/Python%E2%80%94%E2%80%94%E5%9B%9E%E9%A1%BE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%93/"/>
      <url>/2018/11/16/Python%E2%80%94%E2%80%94%E5%9B%9E%E9%A1%BE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>这些最基础的面试想不起来会很尴尬</p><a id="more"></a><h2 id="Python-map-函数"><a href="#Python-map-函数" class="headerlink" title="Python map() 函数"></a>Python map() 函数</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p><p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><p>语法</p><h3 id="map-函数语法："><a href="#map-函数语法：" class="headerlink" title="map() 函数语法："></a>map() 函数语法：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>function – 函数</li><li>iterable – 一个或多个序列</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Python 2.x 返回列表。</p><p>Python 3.x 返回迭代器。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例展示了 map() 的使用方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span> :</span>            <span class="comment"># 计算平方数</span></span><br><span class="line"><span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;map(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 计算列表各个元素的平方</span></span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">&gt;&gt;&gt;map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])  <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><h3 id="提供了两个列表，对相同位置的列表数据进行相加"><a href="#提供了两个列表，对相同位置的列表数据进行相加" class="headerlink" title="提供了两个列表，对相同位置的列表数据进行相加"></a>提供了两个列表，对相同位置的列表数据进行相加</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line">&gt;&gt;&gt;[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><h2 id="Python-filter-函数"><a href="#Python-filter-函数" class="headerlink" title="Python filter() 函数"></a>Python filter() 函数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><blockquote><p><strong>注意:</strong> Pyhton2.7 返回列表，Python3.x 返回迭代器对象，具体内容可以查看：<a href="http://www.runoob.com/python3/python3-func-filter.html" target="_blank" rel="noopener">Python3 filter() 函数</a></p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>以下是 filter() 方法的语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter(function, iterable)</span><br></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li>function – 判断函数。</li><li>iterable – 可迭代对象。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>返回列表。</p><hr><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>以下展示了使用 filter 函数的实例：</p><h3 id="过滤出列表中的所有奇数："><a href="#过滤出列表中的所有奇数：" class="headerlink" title="过滤出列表中的所有奇数："></a>过滤出列表中的所有奇数：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">newlist = filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]) </span><br><span class="line">print(newlist)</span><br></pre></td></tr></table></figure><p>输出结果 ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="过滤出1-100中平方根是整数的数："><a href="#过滤出1-100中平方根是整数的数：" class="headerlink" title="过滤出1~100中平方根是整数的数："></a>过滤出1~100中平方根是整数的数：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-   </span></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_sqr</span><span class="params">(x)</span>:</span>     </span><br><span class="line"><span class="keyword">return</span> math.sqrt(x) % <span class="number">1</span> == <span class="number">0</span></span><br><span class="line">newlist = filter(is_sqr, range(<span class="number">1</span>, <span class="number">101</span>)) </span><br><span class="line">print(newlist)</span><br></pre></td></tr></table></figure><p>输出结果 ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><h2 id="Python-reduce-函数"><a href="#Python-reduce-函数" class="headerlink" title="Python reduce() 函数"></a>Python reduce() 函数</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><strong>reduce()</strong> 函数会对参数序列中元素进行累积。</p><p>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>reduce() 函数语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul><li>function – 函数，有两个参数</li><li>iterable – 可迭代对象</li><li>initializer – 可选，初始参数</li></ul><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>返回函数计算结果。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>以下实例展示了 reduce() 的使用方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span> :</span>            <span class="comment"># 两数相加 ...     </span></span><br><span class="line"><span class="keyword">return</span> x + y ...  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 计算列表和：1+2+3+4+5 15 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  <span class="comment"># 使用 lambda 匿名函数 15</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7环境 Mongodb 的安装及远程连接</title>
      <link href="/2018/11/13/Centos7%E7%8E%AF%E5%A2%83-Mongodb-%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
      <url>/2018/11/13/Centos7%E7%8E%AF%E5%A2%83-Mongodb-%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>此流程仅本人测试，没有报错。折腾了一会，出了解决不了的BUG还是卸载重装比较方便。</p><a id="more"></a><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>① 把Mongo的安装配置添加的yum中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/yum.repos.d/mongodb-org-4.0.repo</span><br></pre></td></tr></table></figure><p>把下面配置复制到文件中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure><p>② 运行安装命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure><p>③ 设置数据储存路径<br>默认下mongo的储存路径是 /data/db ，如果此时系统中没有这个文件，是不会启动成功的。所以要手动穿件这个文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/db</span><br></pre></td></tr></table></figure><p>④ 启动Mongo</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mongod start</span><br></pre></td></tr></table></figure><p>⑤ 连接本地的Mongo</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><p>此时Mongo的安装已经完成，上面日志中有警告啥的可以通过配置解决，但不影响使用。</p><p>参考资料：<a href="https://docs.mongodb.com/master/mongo/" target="_blank" rel="noopener">https://docs.mongodb.com/master/mongo/</a></p><h2 id="二、Mongo的远程连接"><a href="#二、Mongo的远程连接" class="headerlink" title="二、Mongo的远程连接"></a>二、Mongo的远程连接</h2><p>注意：Mongo的远程连接需要打开权限控制<br>本教程是不过多涉及权限问题，权限详情可参考：<br><a href="http://www.cnblogs.com/hanyinglong/archive/2016/07/25/5704320.html" target="_blank" rel="noopener">http://www.cnblogs.com/hanyinglong/archive/2016/07/25/5704320.html</a></p><p>① 添加新的用户<br>首先添加个管理员账号（root权限）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">   user:<span class="string">"root"</span>,</span><br><span class="line">   pwd:<span class="string">"password"</span>,</span><br><span class="line">   roles:[&#123;<span class="attr">role</span>:<span class="string">"root"</span>,<span class="attr">db</span>:<span class="string">"admin"</span>&#125;]</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>添加个普通账号（读写权限）： (需要先用root登陆)<br>（命令中的db 代表用户所分配的数据库）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">                　　user:<span class="string">"hyc"</span>,                                   </span><br><span class="line">                　　pwd:<span class="string">"123456"</span>,</span><br><span class="line">                　　roles:[&#123;<span class="attr">role</span>:<span class="string">"readWrite"</span>,<span class="attr">db</span>:<span class="string">"test"</span>&#125;]</span><br><span class="line">           　　&#125;);</span><br></pre></td></tr></table></figure><p>② 修改配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/mongod.conf</span><br></pre></td></tr></table></figure><p>注释掉：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bindIp: 127.0.0.1  # Listen to local interface only, comment to listen on all interfaces.</span></span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">    authorization: enabled</span><br></pre></td></tr></table></figure><p>③ 重启Mongo 远程连接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mongod restart</span><br></pre></td></tr></table></figure><p>④ 开启端口访问</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --permanent --add-port=27017/tcp; firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>打开ROBO（mongo 可视化工具）：</p><p><a href="https://imgchr.com/i/iXEZcD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/13/iXEZcD.png" alt="iXEZcD.png"></a></p><p><img src="https://s1.ax1x.com/2018/11/13/iXArOH.png" alt="iXArOH.png"></p><h2 id="最后点击Save就可以愉快的使用啦"><a href="#最后点击Save就可以愉快的使用啦" class="headerlink" title="最后点击Save就可以愉快的使用啦"></a>最后点击Save就可以愉快的使用啦</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>无题1</title>
      <link href="/2018/11/09/%E6%97%A0%E9%A2%981/"/>
      <url>/2018/11/09/%E6%97%A0%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2018/11/09/ibtcXq.jpg" alt="ibtcXq.jpg"></p><p>今天投了十几家简历，还没有回音</p><a id="more"></a><p>晚上把做的几个项目的流程再熟悉一下</p><p>感觉简历还是有问题，明天找老师还有同学请教</p><p>感觉压力越来越大了</p><p>本来还有很多东西要学，但是状态有点差</p><p>负面情绪有点多了，需要及时调节过来，毕竟也没人可以依靠了</p><p>加油吧！YC</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django——微信消息推送</title>
      <link href="/2018/11/08/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
      <url>/2018/11/08/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微信公众号的分类</p><a id="more"></a><ul><li><p>微信消息推送</p><ul><li><p>公众号</p><ul><li><p>已认证公众号</p></li><li><p>服务号</p></li><li><p>已认证服务号</p></li><li><p>企业号</p></li></ul></li></ul></li></ul><p>基于：微信认证服务号 主动推送微信消息。<br>前提：关注服务号<br>环境：沙箱环境</p><p>沙箱环境地址： <a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a></p><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><ol><li><p>注册开发者账号</p><p>获得：appID、appsecret</p><p>网页授权获取用户基本信息：47.98.134.86 或 域名 </p></li><li><p>关注公众号（已认证的服务号）</p><p><img src="https://s1.ax1x.com/2018/11/08/iHwTKA.png" alt="iHwTKA.png"></p></li><li><p>生成二维码，用户扫描；<br> 将用户信息发送给微信，微信再将数据发送给设置redirect_uri地址(md5值)</p><p><a href="https://imgchr.com/i/iH09rn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/iH09rn.png" alt="iH09rn.png"></a></p></li><li><p>回调地址：47.98.134.86/callback/</p><p><img src="https://s1.ax1x.com/2018/11/08/iHfnQP.png" alt="iHfnQP.png"></p><ul><li>授权 </li><li>用户md5</li><li>获取wx_id<br>在数据库中更新设置：wx_id </li></ul></li><li><p>发送消息（模板消息）</p><ul><li><p>wx_id </p></li><li><p>access_token（2小时有效期）</p><p><img src="https://s1.ax1x.com/2018/11/08/iHfZRI.png" alt="iHfZRI.png"></p></li></ul></li></ol><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>models.py </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    username = models.CharField(<span class="string">"用户名"</span>, max_length=<span class="number">64</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    password = models.CharField(<span class="string">"密码"</span>, max_length=<span class="number">64</span>)</span><br><span class="line">    uid = models.CharField(verbose_name=<span class="string">'个人唯一ID'</span>,max_length=<span class="number">64</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    wx_id = models.CharField(verbose_name=<span class="string">"微信ID"</span>, max_length=<span class="number">128</span>, blank=<span class="keyword">True</span>, null=<span class="keyword">True</span>, db_index=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 创建用户时，为用户自动生成个人唯一ID</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.pk:</span><br><span class="line">            m = hashlib.md5()</span><br><span class="line">            m.update(self.username.encode(encoding=<span class="string">"utf-8"</span>))</span><br><span class="line">            self.uid = m.hexdigest()</span><br><span class="line">        super(UserInfo, self).save(*args, **kwargs)</span><br></pre></td></tr></table></figure><p>settings.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WECHAT_CONFIG = &#123;</span><br><span class="line">    <span class="string">'app_id'</span>: <span class="string">'wx3d0d44e8d59b5b8c'</span>,</span><br><span class="line">    <span class="string">'appsecret'</span>: <span class="string">'a4ede68946e9a2e7e36480d23865a64d'</span>,</span><br><span class="line">    <span class="string">'redirect_uri'</span>: <span class="string">'http://47.106.237.76/callback/'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>views.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, redirect, HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="comment"># 沙箱环境地质：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    obj = models.UserInfo.objects.get(id=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,&#123;<span class="string">'obj'</span>:obj&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">        user_info = request.session.get(<span class="string">'user_info'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> user_info:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">'/login/'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户登录</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># models.UserInfo.objects.create(username='luffy',password=123)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        user = request.POST.get(<span class="string">'user'</span>)</span><br><span class="line">        pwd = request.POST.get(<span class="string">'pwd'</span>)</span><br><span class="line">        obj = models.UserInfo.objects.filter(username=user, password=pwd).first()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> obj:</span><br><span class="line">            request.session[<span class="string">'user_info'</span>] = &#123;<span class="string">'id'</span>: obj.id, <span class="string">'name'</span>: obj.username, <span class="string">'uid'</span>: obj.uid&#125;</span><br><span class="line">            <span class="keyword">return</span> redirect(to=<span class="string">'/bind/'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'login.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户登录后，关注公众号，并绑定个人微信（用于以后消息推送）</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'bind.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind_qcode</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成二维码</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ret = &#123;<span class="string">'code'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        access_url = <span class="string">"https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#123;appid&#125;&amp;redirect_uri=&#123;redirect_uri&#125;&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=&#123;state&#125;#wechat_redirect"</span></span><br><span class="line">        access_url = access_url.format(</span><br><span class="line">            appid=settings.WECHAT_CONFIG[<span class="string">"app_id"</span>], <span class="comment"># 'wx89085e915d351cae',</span></span><br><span class="line">            redirect_uri=settings.WECHAT_CONFIG[<span class="string">"redirect_uri"</span>], <span class="comment"># 'http://47.93.4.198/test/',</span></span><br><span class="line">            state=request.session[<span class="string">'user_info'</span>][<span class="string">'uid'</span>] <span class="comment"># 为当前用户生成MD5值</span></span><br><span class="line">        )</span><br><span class="line">        ret[<span class="string">'data'</span>] = access_url</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        ret[<span class="string">'code'</span>] = <span class="number">1001</span></span><br><span class="line">        ret[<span class="string">'msg'</span>] = str(e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户在手机微信上扫码后，微信自动调用该方法。</span></span><br><span class="line"><span class="string">    用于获取扫码用户的唯一ID，以后用于给他推送消息。</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    code = request.GET.get(<span class="string">"code"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用户md5值</span></span><br><span class="line">    state = request.GET.get(<span class="string">"state"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取该用户openId(用户唯一，用于给用户发送消息)</span></span><br><span class="line">    res = requests.get(</span><br><span class="line">        url=<span class="string">"https://api.weixin.qq.com/sns/oauth2/access_token"</span>,</span><br><span class="line">        params=&#123;</span><br><span class="line">            <span class="string">"appid"</span>: settings.WECHAT_CONFIG[<span class="string">'app_id'</span>],</span><br><span class="line">            <span class="string">"secret"</span>: settings.WECHAT_CONFIG[<span class="string">'appsecret'</span>],</span><br><span class="line">            <span class="string">"code"</span>: code,</span><br><span class="line">            <span class="string">"grant_type"</span>: <span class="string">'authorization_code'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ).json()</span><br><span class="line">    <span class="comment"># 获取的到openid表示用户授权成功</span></span><br><span class="line">    openid = res.get(<span class="string">"openid"</span>)</span><br><span class="line">    print(openid)</span><br><span class="line">    <span class="keyword">if</span> openid:</span><br><span class="line">        models.UserInfo.objects.filter(uid=state).update(wx_id=openid)</span><br><span class="line">        response = <span class="string">"&lt;h1&gt;授权成功 %s &lt;/h1&gt;"</span> % openid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        response = <span class="string">"&lt;h1&gt;用户扫码之后，手机上的提示&lt;/h1&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendmsg</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_access_token</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取微信全局接口的凭证(默认有效期俩个小时)</span></span><br><span class="line"><span class="string">        如果不每天请求次数过多, 通过设置缓存即可</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = requests.get(</span><br><span class="line">            url=<span class="string">"https://api.weixin.qq.com/cgi-bin/token"</span>,</span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="string">"grant_type"</span>: <span class="string">"client_credential"</span>,</span><br><span class="line">                <span class="string">"appid"</span>: settings.WECHAT_CONFIG[<span class="string">'app_id'</span>],</span><br><span class="line">                <span class="string">"secret"</span>: settings.WECHAT_CONFIG[<span class="string">'appsecret'</span>],</span><br><span class="line">            &#125;</span><br><span class="line">        ).json()</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">"access_token"</span>):</span><br><span class="line">            access_token = result.get(<span class="string">'access_token'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            access_token = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> access_token</span><br><span class="line"></span><br><span class="line">    access_token = get_access_token()</span><br><span class="line"></span><br><span class="line">    openid = models.UserInfo.objects.get(id=<span class="number">1</span>).wx_id</span><br><span class="line">    print(openid)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_custom_msg</span><span class="params">()</span>:</span></span><br><span class="line">        body = &#123;</span><br><span class="line">            <span class="string">"touser"</span>: openid,</span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="string">"text"</span>: &#123;</span><br><span class="line">                <span class="string">"content"</span>: <span class="string">'云姐好美呀'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.post(</span><br><span class="line">            url=<span class="string">"https://api.weixin.qq.com/cgi-bin/message/custom/send"</span>,</span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="string">'access_token'</span>: access_token</span><br><span class="line">            &#125;,</span><br><span class="line">            data=bytes(json.dumps(body, ensure_ascii=<span class="keyword">False</span>), encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 这里可根据回执code进行判定是否发送成功(也可以根据code根据错误信息)</span></span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_template_msg</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        发送模版消息</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = requests.post(</span><br><span class="line">            url=<span class="string">"https://api.weixin.qq.com/cgi-bin/message/template/send"</span>,</span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="string">'access_token'</span>: access_token</span><br><span class="line">            &#125;,</span><br><span class="line">            json=&#123;</span><br><span class="line">                <span class="string">"touser"</span>: openid,</span><br><span class="line">                <span class="string">"template_id"</span>: <span class="string">'NcN_W_aEIwu-FHyJx8djU99Z70AvwwGcEufXiTzj-NM'</span>,</span><br><span class="line">                <span class="string">"data"</span>: &#123;</span><br><span class="line">                    <span class="string">"first"</span>: &#123;</span><br><span class="line">                        <span class="string">"value"</span>: <span class="string">"冰姐"</span>,</span><br><span class="line">                        <span class="string">"color"</span>: <span class="string">"#173177"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"keyword1"</span>: &#123;</span><br><span class="line">                        <span class="string">"value"</span>: <span class="string">"美女"</span>,</span><br><span class="line">                        <span class="string">"color"</span>: <span class="string">"#173177"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        result = res.json()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment"># 在这里编辑要发送的函数中的内容</span></span><br><span class="line">    result = send_template_msg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.get(<span class="string">'errcode'</span>) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'发送成功'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'发送失败'</span>)</span><br></pre></td></tr></table></figure><h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><p>1登陆：</p><p><a href="https://imgchr.com/i/iHwYBq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/iHwYBq.png" alt="iHwYBq.png"></a></p><p>2客户扫码关注我们的公众号</p><p><a href="https://imgchr.com/i/iHwTKA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/iHwTKA.png" alt="iHwTKA.png"></a></p><p>为了获得用户的微信ID，我们需要客户再次扫码，向微信授权把ID给我们</p><p><a href="https://imgchr.com/i/iH09rn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/iH09rn.png" alt="iH09rn.png"></a></p><h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><p><a href="https://github.com/hyyc554/wxbox" target="_blank" rel="noopener">https://github.com/hyyc554/wxbox</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django——支付宝支付功能</title>
      <link href="/2018/11/08/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"/>
      <url>/2018/11/08/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>首先我们需要获得支付宝提供的权限与接口，在蚂蚁开放平台进行相关申请：<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a></p><p>申请支付宝账户权限<br><a id="more"></a></p><p><img src="https://s1.ax1x.com/2018/11/08/iHMqr4.png" alt="iHMqr4.png"></p><p>创建应用</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMIP0.png" alt="iHMIP0.png"></p><p>沙箱测试环境</p><p><img src="https://s1.ax1x.com/2018/11/08/iHM45q.png" alt="iHM45q.png"></p><p>appID：我的身份</p><p>支付宝网关：测试环境</p><p>获得相关的测试账号</p><p><img src="https://s1.ax1x.com/2018/11/08/iHQise.png" alt="iHQise.png"></p><p>商户账号、客户账号后面可以通过这两个账号来进行测试</p><p>沙箱钱包（也可以不下载，直接在网页上登陆测试账号进行支付测试）</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMoGV.png" alt="iHMoGV.png"></p><p>在安卓手机上进行安装</p><h2 id="获得SDK（pay-py）"><a href="#获得SDK（pay-py）" class="headerlink" title="获得SDK（pay.py）"></a>获得SDK（pay.py）</h2><p>就是加密算法</p><p>SDK（加密算法，阿里没有提供python版本，从github山获得）</p><p>官方</p><p>GIHUB（请注意浏览源码）——pay.py(依赖:pip install pycryptodome)</p><p>公钥私钥</p><p><img src="https://s1.ax1x.com/2018/11/08/iHM7xU.png" alt="iHM7xU.png"></p><p>在这里下载<br><img src="https://s1.ax1x.com/2018/11/08/iHMXZ9.png" alt="iHMXZ9.png"></p><p>运行<br><img src="https://s1.ax1x.com/2018/11/08/iHMbMF.png" alt="iHMbMF.png"></p><p><img src="https://s1.ax1x.com/2018/11/08/iHMLqJ.png" alt="iHMLqJ.png"></p><p>生成公钥私钥<br><img src="https://s1.ax1x.com/2018/11/08/iHMjaR.png" alt="iHMjaR.png"></p><p>完成上传</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMzPx.png" alt="iHMzPx.png"></p><p>应用公钥上传后自动生成支付宝公钥</p><p>在django文件中进行替换成自己的key</p><p><img src="C:\Users\Administrator.000\AppData\Roaming\Typora\typora-user-images\1541664121222.png" alt="1541664121222"></p><p>django程序</p><p>演示</p><p>1.运行</p><p>2.访问去支付</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMhan.png" alt="iHMhan.png"></p><p>3.支付页面</p><p><img src="https://s1.ax1x.com/2018/11/08/iHMT2T.png" alt="iHMT2T.png"></p><p>4.登陆测试用户，完成支付</p><p><img src="https://s1.ax1x.com/2018/11/08/iHQpRK.png" alt="iHQpRK.png"></p><p><img src="https://s1.ax1x.com/2018/11/08/iHMvI1.png" alt="iHMvI1.png"></p><p>最终跳转到</p><p><img src="https://s1.ax1x.com/2018/11/08/iHQSG6.png" alt="iHQSG6.png"></p><p>说明功能正常</p><h2 id="Django实现"><a href="#Django实现" class="headerlink" title="Django实现"></a>Django实现</h2><p>代码结构</p><p><img src="https://s1.ax1x.com/2018/11/08/iHQ9xO.png" alt="iHQ9xO.png"></p><p>views.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,redirect,HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> utils.pay <span class="keyword">import</span> AliPay</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aliPay</span><span class="params">()</span>:</span></span><br><span class="line">    obj = AliPay(</span><br><span class="line">        appid=settings.APPID,</span><br><span class="line">        app_notify_url=settings.NOTIFY_URL,  <span class="comment"># 如果支付成功，支付宝会向这个地址发送POST请求（校验是否支付已经完成）</span></span><br><span class="line">        return_url=settings.RETURN_URL,  <span class="comment"># 如果支付成功，重定向回到你的网站的地址。</span></span><br><span class="line">        alipay_public_key_path=settings.PUB_KEY_PATH,  <span class="comment"># 支付宝公钥</span></span><br><span class="line">        app_private_key_path=settings.PRI_KEY_PATH,  <span class="comment"># 应用私钥</span></span><br><span class="line">        debug=<span class="keyword">True</span>,  <span class="comment"># 默认False,</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    alipay = aliPay()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对购买的数据进行加密</span></span><br><span class="line">    money = float(request.POST.get(<span class="string">'price'</span>))</span><br><span class="line">    out_trade_no = <span class="string">"x2"</span> + str(time.time())</span><br><span class="line">    <span class="comment"># 1. 在数据库创建一条数据：状态（待支付）</span></span><br><span class="line"></span><br><span class="line">    query_params = alipay.direct_pay(</span><br><span class="line">        subject=<span class="string">"充气式韩红"</span>,  <span class="comment"># 商品简单描述</span></span><br><span class="line">        out_trade_no= out_trade_no,  <span class="comment"># 商户订单号</span></span><br><span class="line">        total_amount=money,  <span class="comment"># 交易金额(单位: 元 保留俩位小数)</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    pay_url = <span class="string">"https://openapi.alipaydev.com/gateway.do?&#123;&#125;"</span>.format(query_params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirect(pay_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pay_result</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    支付完成后，跳转回的地址</span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    params = request.GET.dict()</span><br><span class="line">    sign = params.pop(<span class="string">'sign'</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    alipay = aliPay()</span><br><span class="line"></span><br><span class="line">    status = alipay.verify(params, sign)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> status:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'支付成功'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'支付失败'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_order</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    支付成功后，支付宝向该地址发送的POST请求（用于修改订单状态）</span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line">        body_str = request.body.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        post_data = parse_qs(body_str)</span><br><span class="line"></span><br><span class="line">        post_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> post_data.items():</span><br><span class="line">            post_dict[k] = v[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        alipay = aliPay()</span><br><span class="line"></span><br><span class="line">        sign = post_dict.pop(<span class="string">'sign'</span>, <span class="keyword">None</span>)</span><br><span class="line">        status = alipay.verify(post_dict, sign)</span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="comment"># 修改订单状态</span></span><br><span class="line">            out_trade_no = post_dict.get(<span class="string">'out_trade_no'</span>)</span><br><span class="line">            print(out_trade_no)</span><br><span class="line">            <span class="comment"># 2. 根据订单号将数据库中的数据进行更新</span></span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">'支付成功'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">'支付失败'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>settings.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支付相关配置</span></span><br><span class="line">APPID = <span class="string">"2016082500309412"</span></span><br><span class="line">NOTIFY_URL = <span class="string">"http://47.106.237.76:80/update_order/"</span></span><br><span class="line">RETURN_URL = <span class="string">"http://47.106.237.76:80/pay_result/"</span></span><br><span class="line">PRI_KEY_PATH = <span class="string">"keys/app_private_2048.txt"</span></span><br><span class="line">PUB_KEY_PATH = <span class="string">"keys/alipay_public_2048.txt"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在线教育平台——购物车功能实现</title>
      <link href="/2018/11/07/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/07/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>依赖软件：Django\redis</p><p>测试工具：postman<br><a id="more"></a></p><h2 id="redis中购物车数据存储结构"><a href="#redis中购物车数据存储结构" class="headerlink" title="redis中购物车数据存储结构"></a>redis中购物车数据存储结构</h2><ul><li>redis最外层的key的实际意义是”luffy_shopping_car_userid_courseid”，也就是最后的两个数字分别代表的用户ID与需要加入购物车的课程ID</li><li>每个单独的课程中，包含课程名称，课程图片，课程价格策略，当前选中策略。</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">redis: &#123;</span><br><span class="line">    "luffy_shopping_car_1_1":</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"title"</span>: <span class="string">"Linux基础"</span>,</span><br><span class="line">        <span class="attr">"img"</span>: <span class="string">"2.png"</span>,</span><br><span class="line">        <span class="attr">"policy"</span>: &#123;</span><br><span class="line">            <span class="attr">"2"</span>: &#123;</span><br><span class="line">                <span class="attr">"period"</span>: <span class="number">60</span>,</span><br><span class="line">                <span class="attr">"period_display"</span>: <span class="string">"2个月"</span>,</span><br><span class="line">                <span class="attr">"price"</span>: <span class="number">1500</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"default_policy"</span>: <span class="string">"2"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    "luffy_shopping_car_1_3": &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p><img src="E:\chromedown\条件结构流程图.png" alt="条件结构流程图"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在setting中设置redis配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,</span><br><span class="line">        &quot;LOCATION&quot;: &quot;redis://yourip:6379&quot;,</span><br><span class="line">        &quot;OPTIONS&quot;: &#123;</span><br><span class="line">            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,</span><br><span class="line">            &quot;CONNECTION_POOL_KWARGS&quot;: &#123;&quot;max_connections&quot;: 100&#125;,</span><br><span class="line">            &quot;PASSWORD&quot;: &quot;yourpassword&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由设置urls.py:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r'^shopping_cart/$'</span>, shopping_cart.ShoppingCart.as_view()),</span><br></pre></td></tr></table></figure><p>基于restframework的视图：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@Author    : Young</span></span><br><span class="line"><span class="string">@Email     : hyc554@outlook.com</span></span><br><span class="line"><span class="string">@site      : http://www.cnblogs.com/huang-yc/</span></span><br><span class="line"><span class="string">@File      : shopping_cart.py</span></span><br><span class="line"><span class="string">@version   : 1.0</span></span><br><span class="line"><span class="string">@Time      : 2018/11/4 20:51</span></span><br><span class="line"><span class="string">Description about this file: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> GenericViewSet, ViewSetMixin</span><br><span class="line"><span class="keyword">from</span> django_redis <span class="keyword">import</span> get_redis_connection</span><br><span class="line"><span class="keyword">from</span> utils.response_dict <span class="keyword">import</span> BaseResponse</span><br><span class="line"><span class="keyword">from</span> api.views.auth <span class="keyword">import</span> YcAuth</span><br><span class="line"><span class="keyword">from</span> api <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> utils.error <span class="keyword">import</span> PricePolicyInvalid</span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ObjectDoesNotExist</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    authentication_classes = [YcAuth]</span><br><span class="line">    conn = get_redis_connection(<span class="string">'default'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        向购物车中添加商品</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :param args:</span></span><br><span class="line"><span class="string">        :param kwargs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = BaseResponse()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 在这里获得用户的课程ID与价格策略ID</span></span><br><span class="line">            course_id = int(request.data.get(<span class="string">'course_id'</span>))</span><br><span class="line">            policy_id = int(request.data.get(<span class="string">'policy_id'</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2. 获取专题课信息</span></span><br><span class="line">            course = models.Course.objects.get(id=course_id)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 3.获取课程相关的所有价格策略</span></span><br><span class="line">            price_policy_list = course.price_policy.all()</span><br><span class="line">            price_policy_dict = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> price_policy_list:</span><br><span class="line">                price_policy_dict[item.id] = &#123;</span><br><span class="line">                    <span class="string">"period"</span>: item.valid_period,</span><br><span class="line">                    <span class="string">"period_display"</span>: item.get_valid_period_display(),</span><br><span class="line">                    <span class="string">"price"</span>: item.price</span><br><span class="line">                &#125;</span><br><span class="line">            print(price_policy_dict)</span><br><span class="line">            <span class="keyword">if</span> policy_id <span class="keyword">not</span> <span class="keyword">in</span> price_policy_dict:</span><br><span class="line">                <span class="keyword">raise</span> PricePolicyInvalid(<span class="string">'价格策略不合法'</span>)</span><br><span class="line">            <span class="comment"># 5. 将购物信息添加到redis中</span></span><br><span class="line">            <span class="comment"># self.conn</span></span><br><span class="line">            <span class="comment"># car_key = "luffy_shopping_car_%s_%s"</span></span><br><span class="line">            car_key = settings.SHOPPING_CART_KEY % (request.auth.user_id, course_id,)</span><br><span class="line">            car_dict = &#123;</span><br><span class="line">                <span class="string">'title'</span>: course.name,</span><br><span class="line">                <span class="string">'img'</span>: course.course_img,</span><br><span class="line">                <span class="string">'default_policy'</span>: policy_id,</span><br><span class="line">                <span class="string">'policy'</span>: json.dumps(price_policy_dict)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment"># conn = get_redis_connection("default")</span></span><br><span class="line">            self.conn.hmset(car_key, car_dict)</span><br><span class="line">            ret.data = <span class="string">'添加成功'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> PricePolicyInvalid <span class="keyword">as</span> e:</span><br><span class="line">            ret.data = <span class="number">2001</span></span><br><span class="line">            ret.error = e.msg</span><br><span class="line">        <span class="keyword">except</span> ObjectDoesNotExist <span class="keyword">as</span> e:</span><br><span class="line">            ret.data = <span class="number">2002</span></span><br><span class="line">            ret.error = <span class="string">'课程不存在'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ret.code = <span class="number">1001</span></span><br><span class="line">            ret.data = <span class="string">'获取购物车数据失败'</span></span><br><span class="line">        <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        ret = BaseResponse()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            course_id_list = request.data.get(<span class="string">'courseids'</span>)</span><br><span class="line">            key_list = [settings.SHOPPING_CART_KEY % (request.auth.user_id, course_id,) <span class="keyword">for</span> course_id <span class="keyword">in</span> course_id_list]</span><br><span class="line">            self.conn.delete(*key_list)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ret.code = <span class="number">1002</span></span><br><span class="line">            ret.error = <span class="string">"删除失败"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">patch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        ret = BaseResponse()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            course_id = int(request.data.get(<span class="string">'course_id'</span>))</span><br><span class="line">            policy_id = str(request.data.get(<span class="string">'policy_id'</span>))</span><br><span class="line"></span><br><span class="line">            key = settings.SHOPPING_CART_KEY % (request.auth.user_id, course_id)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.conn.exists(key):</span><br><span class="line">                ret.code = <span class="number">1002</span></span><br><span class="line">                ret.error = <span class="string">"购物车中不存在此课程"</span></span><br><span class="line">                <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line">            <span class="comment"># 3. redis中获取所有的价格策略</span></span><br><span class="line">            <span class="comment"># 请注意这里对redis里的数据进行读取的操作</span></span><br><span class="line">            policy_dict = json.loads(str(self.conn.hget(key, <span class="string">'policy'</span>), encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="keyword">if</span> policy_id <span class="keyword">not</span> <span class="keyword">in</span> policy_dict:</span><br><span class="line">                ret.code = <span class="number">1003</span></span><br><span class="line">                ret.error = <span class="string">"价格策略不合法"</span></span><br><span class="line">                <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line"></span><br><span class="line">            self.conn.hset(key, <span class="string">'default_policy'</span>, policy_id)</span><br><span class="line">            ret.data = <span class="string">"修改成功"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ret.code = <span class="number">2003</span></span><br><span class="line">            ret.error = <span class="string">'修改数据失败'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(ret.dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查看购物车中所有的商品</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :param args:</span></span><br><span class="line"><span class="string">        :param kwargs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = BaseResponse()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            key_match = settings.SHOPPING_CART_KEY % (request.auth.user_id, <span class="string">"*"</span>)</span><br><span class="line"></span><br><span class="line">            course_list = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> self.conn.scan_iter(key_match, count=<span class="number">10</span>):</span><br><span class="line">                info = &#123;</span><br><span class="line">                    <span class="string">"title"</span>: self.conn.hget(key, <span class="string">'title'</span>).decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                    <span class="string">"img"</span>: self.conn.hget(key, <span class="string">'img'</span>).decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                    <span class="string">"policy"</span>: json.loads(self.conn.hget(key, <span class="string">'policy'</span>).decode(<span class="string">'utf-8'</span>)),</span><br><span class="line">                    <span class="string">"default_policy"</span>: self.conn.hget(key, <span class="string">'default_policy'</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                course_list.append(info)</span><br><span class="line">            ret.data = course_list</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ret.code = <span class="number">1002</span></span><br><span class="line">            ret.error = <span class="string">"获取失败"</span></span><br><span class="line">        <span class="keyword">return</span> Response(ret.dict)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在线教育——结算中心的实现</title>
      <link href="/2018/11/07/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E2%80%94%E2%80%94%E7%BB%93%E7%AE%97%E4%B8%AD%E5%BF%83%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/07/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E2%80%94%E2%80%94%E7%BB%93%E7%AE%97%E4%B8%AD%E5%BF%83%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>依赖软件：Django、redis</p><a id="more"></a><p>redis数据库中的数据结构：</p><ul><li>以字典形式进行存储</li><li>“shopping_car_用户ID_课程ID”作为标识key</li><li>“payment_global_coupon_用户ID”用来保存用户所持有的全场券</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">redis = &#123;</span><br><span class="line">payment_1_2:&#123;</span><br><span class="line">course_id:2,</span><br><span class="line">'title': 'CRM客户关系管理系统实战开发-专题', </span><br><span class="line">'img': 'CRM.jpg', 'policy_id': '4', </span><br><span class="line">'coupon': &#123;&#125;, </span><br><span class="line">'default_coupon': 0, </span><br><span class="line">'period': 210, 'period_display': '12个月', 'price': 122.0&#125;, </span><br><span class="line">&#125;,</span><br><span class="line">payment_1_1:&#123;</span><br><span class="line">course_id:1,</span><br><span class="line">'title': '爬虫开发-专题', </span><br><span class="line">'img': '爬虫开发-专题.jpg', </span><br><span class="line">'policy_id': '2', </span><br><span class="line">'coupon': &#123;</span><br><span class="line">4: &#123;'coupon_type': 0, 'coupon_display': '立减券', 'money_equivalent_value': 40&#125;, </span><br><span class="line">6: &#123;'coupon_type': 1, 'coupon_display': '满减券', 'money_equivalent_value': 60, 'minimum_consume': 100&#125;</span><br><span class="line">&#125;, </span><br><span class="line">'default_coupon': 0, </span><br><span class="line">'period': 60, </span><br><span class="line">'period_display': '2个月', </span><br><span class="line">'price': 599.0&#125;</span><br><span class="line">&#125;,</span><br><span class="line">payment_global_coupon_1:&#123;</span><br><span class="line">'coupon': &#123;</span><br><span class="line">2: &#123;'coupon_type': 1, 'coupon_display': '满减券', 'money_equivalent_value': 200, 'minimum_consume': 500&#125;</span><br><span class="line">&#125;, </span><br><span class="line">'default_coupon': 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的面试笔记</title>
      <link href="/2018/11/02/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/02/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>每天写一点，直到找到工作</p><a id="more"></a><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><ol><li>为什么学习Python？</li></ol><h1 id="一、WEB框架"><a href="#一、WEB框架" class="headerlink" title="一、WEB框架"></a>一、WEB框架</h1><h2 id="1-请简述django请求生命周期"><a href="#1-请简述django请求生命周期" class="headerlink" title="1. 请简述django请求生命周期"></a>1. 请简述django请求生命周期</h2><ul><li>当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端</li><li>服务端的wsgiref模块接收用户请求并将请求进行初次封装</li><li>将请求交给Django的中间件</li><li>通过中间件之后将请求交给url,根据浏览器发送的不同url去匹配不同的视图函数</li><li>视图函数根据业务逻辑调用数据库获取相应的数据，然或根据模板渲染页面</li><li>视图函数将响应的页面依次通过中间件</li><li>到达wsgi，封装数据后反馈给客户端<br><img src="https://i.loli.net/2018/11/03/5bdc849e1d6d5.png" alt="wsgi.png"></li></ul><h2 id="2-什么wsgi"><a href="#2-什么wsgi" class="headerlink" title="2. 什么wsgi"></a>2. 什么wsgi</h2><p><strong>Web服务器网关接口</strong>（<strong>Python Web Server Gateway Interface</strong>，缩写为WSGI）是为<a href="https://zh.wikipedia.org/wiki/Python" target="_blank" rel="noopener">Python</a>语言定义的<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">Web服务器</a>和<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">Web应用程序</a>或<a href="https://zh.wikipedia.org/wiki/Web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">框架</a>之间的一种简单而通用的<a href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E9%9D%A2_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" target="_blank" rel="noopener">接口</a>)。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。</p><p>WSGI区分为两个部分：一为“<a href="https://zh.wikipedia.org/wiki/%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">服务器</a>”或“网关”，另一为“应用程序”或“应用框架”。在处理一个WSGI请求时，服务器会为应用程序提供环境信息及一个回调函数（Callback Function）。当应用程序完成处理请求后，透过前述的回调函数，将结果回传给服务器。</p><p>所谓的 <em>WSGI 中间件</em>同时实现了API的两方，因此可以在WSGI服务器和WSGI应用之间起调解作用：从Web服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。“中间件”组件可以执行以下功能：</p><ul><li>重写<a href="https://zh.wikipedia.org/wiki/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">环境变量</a>后，根据目标<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="noopener">URL</a>，将请求消息路由到不同的应用对象。</li><li>允许在一个<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="noopener">进程</a>中同时运行多个应用程序或应用框架。</li><li><a href="https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" target="_blank" rel="noopener">负载均衡</a>和远程处理，通过在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">网络</a>上转发请求和响应消息。</li><li>进行内容后处理，例如应用<a href="https://zh.wikipedia.org/wiki/XSLT" target="_blank" rel="noopener">XSLT</a>样式表。</li></ul><p><strong>实现该协议的模块：</strong></p><ul><li>wsgiref</li><li>werkzurg</li><li>uwsig</li></ul><h2 id="3-视图的玩法"><a href="#3-视图的玩法" class="headerlink" title="3.视图的玩法"></a>3.视图的玩法</h2><p>FBV——url —— 函数</p><p>CBV——url —— view</p><h2 id="4-RESTful规范"><a href="#4-RESTful规范" class="headerlink" title="4.RESTful规范"></a>4.RESTful规范</h2><blockquote><p>什么是RESTful架构：</p><p>　　（1）每一个URI代表一种资源；</p><p>　　（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p></blockquote><h2 id="5-django-rest-framework框架"><a href="#5-django-rest-framework框架" class="headerlink" title="5.django rest framework框架"></a>5.django rest framework框架</h2><p><strong>1. 路由</strong></p><ul><li>可以通过as_view传参数，根据请求方式不同执行相应的方法</li><li>可以在url中设置一个结尾，类似于： .json </li></ul><p><strong>2. 视图</strong></p><ul><li>帮助开发者提供了一些类，并在类中提供了多个方法以供我们使用</li></ul><p><strong>3. 版本</strong></p><ul><li>在url中设置version参数，用户请求时候传入参数。在request.version中获取版本，根据版本不同做不同处理</li></ul><p><strong>4. 认证</strong><br>写一个类并注册到认证类，在类的的authticate方法中编写认证逻辑。</p><ul><li>认证成功（user,auth）</li><li>raise AuthticateFaild(….)</li><li>None </li></ul><p><strong>5. 权限</strong><br>写一个类并注册到权限类，在类的的has_permission方法中编写认证逻辑。</p><ul><li>True </li><li>False </li></ul><p><strong>6. 频率限制</strong><br>写一个类并注册到频率类，在类的的 allow_request/wait 方法中编写认证逻辑。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allow_request</span><br><span class="line"> <span class="keyword">True</span> </span><br><span class="line"> <span class="keyword">False</span>  如果返回<span class="keyword">False</span>，那么就要执行wait</span><br></pre></td></tr></table></figure></p><p><strong>7. 解析器</strong></p><ul><li><p>根据ContentType请求头，选择不同解析器对 请求体中的数据进行解析。</p></li><li><p>POST /index/ http1.1.\r\nhost:11.11.11.11\r\nContent-Type:url-formendo…. \r\n\r\nuser=alex&amp;age=123</p></li><li>POST /index/ http1.1.\r\nhost:11.11.11.11\r\nContent-Type:application/json\r\n\r\n{….}</li></ul><p><strong>8. 分页</strong> </p><ul><li>对从数据库中获取到的数据进行分页处理: SQL -&gt; limit offset <ul><li>根据页码：<a href="http://www.luffycity.com/api/v1/student/?page=1&amp;size=10" target="_blank" rel="noopener">http://www.luffycity.com/api/v1/student/?page=1&amp;size=10</a></li><li>根据索引：<a href="http://www.luffycity.com/api/v1/student/?offset=60&amp;limit=10" target="_blank" rel="noopener">http://www.luffycity.com/api/v1/student/?offset=60&amp;limit=10</a></li><li>根据加密：<a href="http://www.luffycity.com/api/v1/student/?page=erd8" target="_blank" rel="noopener">http://www.luffycity.com/api/v1/student/?page=erd8</a></li></ul></li></ul><hr><h2 id="6-页码越大速度越慢，为什么以及如何解决？"><a href="#6-页码越大速度越慢，为什么以及如何解决？" class="headerlink" title="6. 页码越大速度越慢，为什么以及如何解决？"></a>6. 页码越大速度越慢，为什么以及如何解决？</h2><p>原因：页码越大向后需要扫描的行数越多，因为每次都是从0开始扫描。<br>解决：</p><pre><code>- 限制显示的页数- 记录当前页数据ID最大值和最小值，再次分页时，根据ID现行筛选，然后再分页。</code></pre><h2 id="7-三次握手与四次挥手"><a href="#7-三次握手与四次挥手" class="headerlink" title="7. 三次握手与四次挥手"></a>7. 三次握手与四次挥手</h2><p>答案详解：<a href="https://www.cnblogs.com/huang-yc/p/9859216.html" target="_blank" rel="noopener">TCP握手与挥手</a></p><h2 id="8-简述什么是FBV和CBV"><a href="#8-简述什么是FBV和CBV" class="headerlink" title="8.简述什么是FBV和CBV"></a>8.简述什么是FBV和CBV</h2><p>FBV（function base views） ——在视图里使用函数处理请求。<br>CBV（class base views） ——在视图里使用类处理请求。</p><p>其实没有本质的区别</p><p>Python是一个面向对象的编程语言，如果只用函数来开发，有很多面向对象的优点就错失了（继承、封装、多态）。所以Django在后来加入了Class-Based-View。可以让我们用类写View。这样做的优点主要下面两种：</p><p>提高了代码的复用性，可以使用面向对象的技术，比如Mixin（多继承）<br>可以用不同的函数针对不同的HTTP方法处理，而不是通过很多if判断，提高代码可读性</p><h2 id="9-谈一谈你对ORM的理解"><a href="#9-谈一谈你对ORM的理解" class="headerlink" title="9.谈一谈你对ORM的理解"></a>9.谈一谈你对ORM的理解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ORM是“对象-关系-映射”的简称。</span><br><span class="line">MVC或者MVC框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库，这极大的减轻了开发人员的工作量，不需要面对因数据库变更而导致的无效劳动</span><br></pre></td></tr></table></figure><h1 id="二、-项目相关："><a href="#二、-项目相关：" class="headerlink" title="二、 项目相关："></a>二、 项目相关：</h1><h2 id="1-请讲一下你做的在线商城的表结构"><a href="#1-请讲一下你做的在线商城的表结构" class="headerlink" title="1. 请讲一下你做的在线商城的表结构"></a>1. 请讲一下你做的在线商城的表结构</h2><ul><li>课程（13表）<ul><li>课程大类</li><li>课程子类</li><li>学位课<ul><li>讲师</li><li>奖学金</li></ul></li><li>专题课（学位课模块表）</li><li>价格策略(contenttype)</li><li>课程详细(o2o -&gt; 水平分表)</li><li>常见问题</li><li>课程大纲</li><li>章节</li><li>课时</li><li>作业 </li></ul></li><li>深科技（4+2）<ul><li>用户表</li><li>用户token</li><li>文章来源</li><li>文章表</li><li>通用评论表</li><li>通用收藏表</li></ul></li></ul><h2 id="2-支付宝功能"><a href="#2-支付宝功能" class="headerlink" title="2. 支付宝功能"></a>2. 支付宝功能</h2><ul><li>加密方式：rsa</li><li>公钥私钥：<ul><li>商户私钥<ul><li>支付宝公钥</li></ul></li></ul></li><li>支付成功后，断电宕机<ul><li>成功：return HttpResponse(‘success’)</li></ul></li></ul><h2 id="3-数据库页数越大速度越慢，如何解决"><a href="#3-数据库页数越大速度越慢，如何解决" class="headerlink" title="3. 数据库页数越大速度越慢，如何解决"></a>3. 数据库页数越大速度越慢，如何解决</h2><ul><li>限制页数</li><li>记录当前页最大ID、最小ID</li><li>错误答案：<ul><li>扫描索引表</li><li>再去数据库表中获取数据</li></ul></li></ul><h2 id="4-redis是什么？"><a href="#4-redis是什么？" class="headerlink" title="4. redis是什么？"></a>4. redis是什么？</h2><p>用于操作内存的软件。</p><ul><li>可以做持久化：<ul><li>AOF</li><li>RDB</li></ul></li><li><p>相当于是大字典</p></li><li><p>单进程单线程</p></li></ul><h1 id="三、-Django"><a href="#三、-Django" class="headerlink" title="三、 Django"></a>三、 Django</h1><h2 id="1-讲述一些ORM操作"><a href="#1-讲述一些ORM操作" class="headerlink" title="1. 讲述一些ORM操作"></a>1. 讲述一些ORM操作</h2><ul><li><p>select_related,连表操作，相当于主动做join</p></li><li><p>prefeth_related,多次单表操作，先查询想要的数据，然后构造条件,如：id=[1,2,3]，再次查询其他表根据id做条件。</p></li><li><p>only</p></li><li><p>defer</p></li><li><p>F </p></li><li><p>Q </p></li><li><p>通过ORM写偏原生SQL：</p></li></ul><ol><li>extra</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.extra(select=&#123;<span class="string">'new_id'</span>: <span class="string">"select col from sometable where othercol &gt; %s"</span>&#125;, select_params=(<span class="number">1</span>,))</span><br><span class="line">Entry.objects.extra(where=[<span class="string">'headline=%s'</span>], params=[<span class="string">'Lennon'</span>])</span><br><span class="line">Entry.objects.extra(where=[<span class="string">"foo='a' OR bar = 'a'"</span>, <span class="string">"baz = 'a'"</span>])</span><br><span class="line">Entry.objects.extra(select=&#123;<span class="string">'new_id'</span>: <span class="string">"select id from tb where id &gt; %s"</span>&#125;,select_params=(<span class="number">1</span>,), order_by=[<span class="string">'-nid'</span>])</span><br></pre></td></tr></table></figure><ol start="2"><li>raw</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行原生SQL</span></span><br><span class="line">models.UserInfo.objects.raw(<span class="string">'select * from userinfo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名</span></span><br><span class="line">models.UserInfo.objects.raw(<span class="string">'select id as nid from 其他表'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为原生SQL设置参数</span></span><br><span class="line">models.UserInfo.objects.raw(<span class="string">'select id as nid from userinfo where nid&gt;%s'</span>, params=[<span class="number">12</span>,])</span><br><span class="line"></span><br><span class="line">name_map = &#123;<span class="string">'first'</span>: <span class="string">'first_name'</span>, <span class="string">'last'</span>: <span class="string">'last_name'</span>, <span class="string">'bd'</span>: <span class="string">'birth_date'</span>, <span class="string">'pk'</span>: <span class="string">'id'</span>&#125;</span><br><span class="line">Person.objects.raw(<span class="string">'SELECT * FROM some_other_table'</span>, translations=name_map)</span><br></pre></td></tr></table></figure><ol start="3"><li>原生SQL</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection, connections</span><br><span class="line">cursor = connection.cursor()  <span class="comment"># cursor = connections['default'].cursor()</span></span><br><span class="line">cursor.execute(<span class="string">"""SELECT * from auth_user where id = %s"""</span>, [<span class="number">1</span>])</span><br><span class="line">row = cursor.fetchone() <span class="comment"># fetchall()/fetchmany(..)</span></span><br></pre></td></tr></table></figure><ol start="5"><li>选择数据库</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queryset = models.Course.objects.using(<span class="string">'default'</span>).all()</span><br></pre></td></tr></table></figure><h1 id="？、其他"><a href="#？、其他" class="headerlink" title="？、其他"></a>？、其他</h1><h2 id="1-git的作用是什么"><a href="#1-git的作用是什么" class="headerlink" title="1. git的作用是什么"></a>1. git的作用是什么</h2><p>进行版本控制，实现协同开发</p><h2 id="2-git命令与意义"><a href="#2-git命令与意义" class="headerlink" title="2. git命令与意义"></a>2. git命令与意义</h2><ul><li>git init </li><li>git add </li><li>git status </li><li>git commit </li><li>git log </li><li>git reflog </li><li>git reset –hard</li><li>git checkout </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python基础算法实现</title>
      <link href="/2018/10/29/python%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/10/29/python%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本篇主要实现九(八)大排序算法，分别是冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序,计数排序。希望大家回顾知识的时候也能从我的这篇文章得到帮助。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>十种常见排序算法可以分为两大类：</p><ol><li>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</li><li>线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</li></ol><p><strong>基础定义</strong></p><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ul><p><strong>图示</strong><br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014194820700-1435466222.png" alt=""></p><p><strong>为了防止误导读者，本文所有概念性内容均截取自对应Wiki。</strong></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>原理</strong></p><p>冒泡排序(Bubble Sort)是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014185452443-1800879816.gif" alt=""></p><p><strong>步骤</strong></p><p>冒泡排序算法的运作如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    length = len(list)</span><br><span class="line">    <span class="comment"># 第一级遍历</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="comment"># 第二级遍历</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length - index):</span><br><span class="line">            <span class="keyword">if</span> list[j - <span class="number">1</span>] &gt; list[j]:</span><br><span class="line">                <span class="comment"># 交换两者数据，这里没用temp是因为python 特性元组。</span></span><br><span class="line">                list[j - <span class="number">1</span>], list[j] = list[j], list[j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><p>这种排序其实还可以稍微优化一下，添加一个标记，在排序已完成时，停止排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort_flag</span><span class="params">(list)</span>:</span></span><br><span class="line">    length = len(list)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="comment"># 标志位</span></span><br><span class="line">        flag = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length - index):</span><br><span class="line">            <span class="keyword">if</span> list[j - <span class="number">1</span>] &gt; list[j]:</span><br><span class="line">                list[j - <span class="number">1</span>], list[j] = list[j], list[j - <span class="number">1</span>]</span><br><span class="line">                flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="comment"># 没有发生交换，直接返回list</span></span><br><span class="line">            <span class="keyword">return</span> list</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>原理</strong></p><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理大致是将后面的元素最小元素一个个取出然后按顺序放置。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014185807987-1057233489.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    n=len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>,n):</span><br><span class="line">        min = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> list[j]&lt;list[min]:</span><br><span class="line">                min=j</span><br><span class="line">                list[min],list[i]=list[i],list[min]</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>原理</strong></p><p>插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190107085-1652380825.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># 后一个元素和前一个元素比较</span></span><br><span class="line">        <span class="comment"># 如果比前一个小</span></span><br><span class="line">        <span class="keyword">if</span> list[i] &lt; list[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 将这个数取出</span></span><br><span class="line">            temp = list[i]</span><br><span class="line">            <span class="comment"># 保存下标</span></span><br><span class="line">            index = i</span><br><span class="line">            <span class="comment"># 从后往前依次比较每个元素</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="comment"># 和比取出元素大的元素交换</span></span><br><span class="line">                <span class="keyword">if</span> list[j] &gt; temp:</span><br><span class="line">                    list[j + <span class="number">1</span>] = list[j]</span><br><span class="line">                    index = j</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 插入元素</span></span><br><span class="line">            list[index] = temp</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>原理</strong></p><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率<br>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190225518-1370369504.gif" alt=""></p><p><strong>步骤</strong></p><p>每次以一定步长(就是跳过等距的数)进行排序，直至步长为1.</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="comment"># 每个步长进行插入排序</span></span><br><span class="line">            temp = list[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> list[j - gap] &gt; temp:</span><br><span class="line">                list[j] = list[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            list[j] = temp</span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><blockquote><p>步长使用的是Donald Shell的建议，另外步长还可以使用Sedgewick提出的(1, 5, 19, 41, 109,…)。<br>也可以使用<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%2596%2590%25E6%25B3%25A2%25E9%2582%25A3%25E5%25A5%2591%25E6%2595%25B0%25E5%2588%2597" target="_blank" rel="noopener">斐波那契数列</a>除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列。</p></blockquote><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>原理</strong></p><p>归并操作(归并算法)，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190406955-1250220054.gif" alt=""></p><p><strong>步骤</strong></p><p>1.迭代法</p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置<br> 3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><p><strong>递归法</strong></p><p>假设序列共有n个元素：</p><ol><li>将序列每相邻两个数字进行归并操作，形成 {\displaystyle floor(n/2)} floor(n/2)个序列，排序后每个序列包含两个元素</li><li>将上述序列再次归并，形成 {\displaystyle floor(n/4)} floor(n/4)个序列，每个序列包含四个元素</li><li>重复步骤2，直到所有元素排序完毕</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment"># 认为长度不大于1的数列是有序的</span></span><br><span class="line">    <span class="keyword">if</span> len(list) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    <span class="comment"># 二分列表</span></span><br><span class="line">    middle = len(list) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(list[:middle])</span><br><span class="line">    right = merge_sort(list[middle:])</span><br><span class="line">    <span class="comment"># 最后一次合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    l,r=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    result=[]</span><br><span class="line">    <span class="keyword">while</span> l&lt;len(left) <span class="keyword">and</span> r&lt;len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt;right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r +=<span class="number">1</span></span><br><span class="line">        reslut +=left[l:]</span><br><span class="line">        result+=right[r:]                </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>鄙人不才，不知归并排序的迭代法如何用Python实现，望指教。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>原理</strong></p><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190611263-753990372.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p><strong>代码</strong></p><p>普通版</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    less = []</span><br><span class="line">    pivotList = []</span><br><span class="line">    more = []</span><br><span class="line">    <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> len(list) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 将第一个值做为基准</span></span><br><span class="line">        pivot = list[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">            <span class="comment"># 将比急转小的值放到less数列</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; pivot:</span><br><span class="line">                less.append(i)</span><br><span class="line">            <span class="comment"># 将比基准打的值放到more数列</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt; pivot:</span><br><span class="line">                more.append(i)</span><br><span class="line">            <span class="comment"># 将和基准相同的值保存在基准数列</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pivotList.append(i)</span><br><span class="line">        <span class="comment"># 对less数列和more数列继续进行排序</span></span><br><span class="line">        less = quick_sort(less)</span><br><span class="line">        more = quick_sort(more)</span><br><span class="line">        <span class="keyword">return</span> less + pivotList + more</span><br></pre></td></tr></table></figure><p>分而治之的思想实现：</p><p>下面这段代码出自《算法图解》传说中的三行实现python快速排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = arr[<span class="number">0</span>]</span><br><span class="line">        less = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">        greater = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= pivot]</span><br><span class="line">        <span class="keyword">return</span> qsort(less) + [pivot] + qsort(greater)</span><br></pre></td></tr></table></figure><p>一行语法糖版本:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qs = <span class="keyword">lambda</span> xs : ( (len(xs) &lt;= <span class="number">1</span> <span class="keyword">and</span> [xs]) <span class="keyword">or</span> [ qs( [x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; xs[<span class="number">0</span>]] ) + [xs[<span class="number">0</span>]] + qs( [x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= xs[<span class="number">0</span>]] ) ] )[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>是不是感受到了Python的魅力？</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>原理</strong></p><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190700059-194955464.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>创建最大堆:将堆所有数据重新排序，使其成为最大堆</li><li>最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序</li><li>堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment"># 创建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range((len(list) - <span class="number">2</span>) // <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        sift_down(list, start, len(list) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 堆排序</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(len(list) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        list[<span class="number">0</span>], list[end] = list[end], list[<span class="number">0</span>]</span><br><span class="line">        sift_down(list, <span class="number">0</span>, end - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(lst, start, end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        child = <span class="number">2</span> * root + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> lst[child] &lt; lst[child + <span class="number">1</span>]:</span><br><span class="line">            child += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lst[root] &lt; lst[child]:</span><br><span class="line">            lst[root], lst[child] = lst[child], lst[root]</span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><strong>原理</strong></p><p>当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。<br><img src="https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190748857-1567575212.gif" alt=""></p><p><strong>步骤</strong></p><ol><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    min = <span class="number">2147483647</span></span><br><span class="line">    max = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 取得最大值和最小值</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> list:</span><br><span class="line">        <span class="keyword">if</span> x &lt; min:</span><br><span class="line">            min = x</span><br><span class="line">        <span class="keyword">if</span> x &gt; max:</span><br><span class="line">            max = x</span><br><span class="line">    <span class="comment"># 创建数组C</span></span><br><span class="line">    count = [<span class="number">0</span>] * (max - min +<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> list:</span><br><span class="line">        count[index - min] += <span class="number">1</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 填值</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(max - min+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(count[a]):</span><br><span class="line">            list[index] = a + min</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h2 id="第九种排序"><a href="#第九种排序" class="headerlink" title="第九种排序"></a>第九种排序</h2><p>None？<br>当然不会<br>自然就是系统自带的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list.sort()</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>维基百科: <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%2586%2592%25E6%25B3%25A1%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">冒泡排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E9%2580%2589%25E6%258B%25A9%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">选择排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%258F%2592%25E5%2585%25A5%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">插入排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25B8%258C%25E5%25B0%2594%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">希尔排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25BD%2592%25E5%25B9%25B6%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">归并排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25BF%25AB%25E9%2580%259F%25E6%258E%2592%25E5%25BA%258F%23.E5.8E.9F.E5.9C.B0.EF.BC.88in-place.EF.BC.89.E5.88.86.E5.89.B2.E7.9A.84.E7.89.88.E6.9C.AC" target="_blank" rel="noopener">快速排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25A0%2586%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">堆排序</a>、<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E8%25AE%25A1%25E6%2595%25B0%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">计数排序</a></li><li>[Python Cookbook</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅析跨域请求</title>
      <link href="/2018/10/26/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/10/26/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近做项目的时候遇到了一些跨域问题，虽然网上对于跨域的问题分享还挺多的。不过当我实际遇到的时候还是有点懵。趁项目刚上线完，写篇文章总结下。</p><a id="more"></a><h3 id="造成跨域的原因"><a href="#造成跨域的原因" class="headerlink" title="造成跨域的原因"></a>造成跨域的原因</h3><p>浏览器的同源策略会导致跨域，这里同源策略又分为以下两种</p><ul><li>DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</li><li>XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。</li></ul><blockquote><p>只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。</p></blockquote><h3 id="为什么要有跨域限制"><a href="#为什么要有跨域限制" class="headerlink" title="为什么要有跨域限制"></a>为什么要有跨域限制</h3><p>了解完跨域之后，想必大家都会有这么一个思考，为什么要有跨域的限制，浏览器这么做是出于何种原因呢。其实仔细想一想就会明白，跨域限制主要是为了安全考虑。</p><p>AJAX同源策略主要用来防止CSRF攻击。如果没有AJAX同源策略，相当危险，我们发起的每一次HTTP请求都会带上请求地址对应的cookie，那么可以做如下攻击：</p><ol><li>用户登录了自己的银行页面 <code>http://mybank.com</code>，<code>http://mybank.com</code>向用户的cookie中添加用户标识。</li><li>用户浏览了恶意页面 <code>http://evil.com</code>。执行了页面中的恶意AJAX请求代码。</li><li><code>http://evil.com</code>向<code>http://mybank.com</code>发起AJAX HTTP请求，请求会默认把<code>http://mybank.com</code>对应cookie也同时发送过去。</li><li>银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。</li><li>而且由于Ajax在后台执行，用户无法感知这一过程。</li></ol><p>DOM同源策略也一样，如果iframe之间可以跨域访问，可以这样攻击：</p><ol><li>做一个假网站，里面用iframe嵌套一个银行网站 <code>http://mybank.com</code>。</li><li>把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li><li>这时如果用户输入账号密码，我们的主网站可以跨域访问到<code>http://mybank.com</code>的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击。</li></ol><p>所以说有了跨域跨域限制之后，我们才能更安全的上网了。</p><h3 id="跨域的解决方式"><a href="#跨域的解决方式" class="headerlink" title="跨域的解决方式"></a>跨域的解决方式</h3><h4 id="跨域资源共享（CORS"><a href="#跨域资源共享（CORS" class="headerlink" title="跨域资源共享（CORS)"></a>跨域资源共享（CORS)</h4><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>对于这个方式，阮一峰老师总结的文章特别好，希望深入了解的可以看一下<code>http://www.ruanyifeng.com/blog/2016/04/cors.html</code>。</p><p>通过在HTTP Header中加入扩展字段，服务器在相应网页头部加入字段表示允许访问的domain和HTTP method，客户端检查自己的域是否在允许列表中，决定是否处理响应。</p><p>实现的基础是JavaScript不能够操作HTTP Header。某些浏览器插件实际上是具有这个能力的。</p><p>服务器端在HTTP的响应头中加入（页面层次的控制模式）：</p><p><strong><em>Access-Control-Allow-Origin: example.com</em></strong><br><strong><em>Access-Control-Request-Method: GET, POST</em></strong><br><strong><em>Access-Control-Allow-Headers: Content-Type, Authorization, Accept, Range, Origin</em></strong></p><p><strong><em>Access-Control-Expose-Headers: Content-Range</em></strong></p><p><strong><em>Access-Control-Max-Age: 3600</em></strong></p><p>多个域名之间用逗号分隔，表示对所示域名提供跨域访问权限。”*”表示允许所有域名的跨域访问。</p><p><strong>客户端可以有两种行为：</strong></p><ol><li><p>发送OPTIONS请求，请求Access-Control信息。如果自己的域名在允许的访问列表中，则发送真正的请求，否则放弃请求发送。</p></li><li><p>直接发送请求，然后检查response的Access-Control信息，如果自己的域名在允许的访问列表中，则读取response body，否则放弃。</p></li></ol><p>本质上服务端的response内容已经到达本地，JavaScript决定是否要去读取。</p><p>这里我就简单的说一说大体流程。</p><ol><li>对于客户端，我们还是正常使用xhr对象发送ajax请求。<br>唯一需要注意的是，我们需要设置我们的xhr属性<code>withCredentials</code>为true，不然的话，cookie是带不过去的哦，设置： <code>xhr.withCredentials = true</code>;</li><li>对于服务器端，需要在 response header中设置如下两个字段:<br><code>Access-Control-Allow-Origin: http://www.yourhost.com</code><br><code>Access-Control-Allow-Credentials:true</code><br>这样，我们就可以跨域请求接口了。</li></ol><p>在django的实际项目中,跨域用CORS技术构建一个中间件，来解决跨域问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORSMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        解决跨域问题</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :param response:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 添加响应头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 允许你的域名来获取我的数据</span></span><br><span class="line">        response[<span class="string">'Access-Control-Allow-Origin'</span>] = <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 允许你携带Content-Type请求头</span></span><br><span class="line">        <span class="comment"># response['Access-Control-Allow-Headers'] = "Content-Type"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 允许你发送DELETE,PUT</span></span><br><span class="line">        <span class="comment"># response['Access-Control-Allow-Methods'] = "DELETE,PUT"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h4 id="jsonp实现跨域"><a href="#jsonp实现跨域" class="headerlink" title="jsonp实现跨域"></a>jsonp实现跨域</h4><p>基本原理就是通过动态创建script标签,然后利用src属性进行跨域。<br>这么说比较模糊，我们来看个例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">//定义一个fun函数</span><br><span class="line">function fun(data) &#123; </span><br><span class="line">    console.log(data); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 创建一个脚本，并且告诉后端回调函数名叫fun </span><br><span class="line">var body= document.getElementsByTagName(&apos;body&apos;)[0]; </span><br><span class="line">var script= document.createElement(&apos;script&apos;); </span><br><span class="line">script.type= &apos;text/javascript&apos;; </span><br><span class="line">script.src= &apos;demo.js?callback=fun&apos;; </span><br><span class="line">body.appendChild(script); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>返回的js脚本，直接会执行。所以就执行了事先定义好的fun函数了，并且把数据传入了进来。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun(&#123;&quot;name&quot;:&quot;name&quot;&#125;)</span><br></pre></td></tr></table></figure><p>当然，这个只是一个原理演示，实际情况下，我们需要动态创建这个fun函数，并且在数据返回的时候销毁它。</p><p>因为在实际使用的时候，我们用的各种ajax库，基本都包含了jsonp的封装，不过我们还是要知道一下原理，不然就不知道为什么jsonp不能发post请求了~</p><h4 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h4><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。</p><blockquote><p>服务器代理是万能的。</p></blockquote><h4 id="document-domain来跨子域"><a href="#document-domain来跨子域" class="headerlink" title="document.domain来跨子域"></a>document.domain来跨子域</h4><p>对于主域名相同，而子域名不同的情况，可以使用document.domain来跨域<br>这种方式非常适用于iframe跨域的情况，直接看例子吧<br>比如a页面地址为 <code>a.yourhost.com</code> b页面为 <code>b.yourhost.com</code>。<br>这样就可以通过分别给两个页面设置 <code>document.domain = yourhost.com</code> 来实现跨域。<br>之后，就可以通过 parent 或者 window[‘iframename’]等方式去拿到iframe的window对象了。</p><h4 id="使用window-name进行跨域"><a href="#使用window-name进行跨域" class="headerlink" title="使用window.name进行跨域"></a>使用window.name进行跨域</h4><p>window.name跨域同样是受到同源策略限制，父框架和子框架的src必须指向统一域名。window.name的优势在于，name的值在不同的页面(或者不同的域名)，加载后仍然存在，除非你显示的更改。并且支持的长度达到2M.</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    iframe.style.display = &apos;none&apos;;</span><br><span class="line">    var state = 0;</span><br><span class="line"></span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">      if(state === 1) &#123;</span><br><span class="line">          var data = iframe.contentWindow.name;</span><br><span class="line">          console.log(data);</span><br><span class="line">          iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">          iframe.contentWindow.close();</span><br><span class="line">          document.body.removeChild(iframe);</span><br><span class="line">      &#125; else if(state === 0) &#123;</span><br><span class="line">          state = 1;</span><br><span class="line">          iframe.contentWindow.location = </span><br><span class="line">          &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//b页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.name = &quot;hello&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="window-location-hash跨域"><a href="#window-location-hash跨域" class="headerlink" title="window.location.hash跨域"></a>window.location.hash跨域</h4><p>location.hash方式跨域，是子框架具有修改父框架src的hash值，通过这个属性进行传递数据，且更改hash值，页面不会刷新。但是传递的数据的字节数是有限的。</p><blockquote><p>注意：父子框架受同源策略的限制</p></blockquote><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    iframe.style.display = &apos;none&apos;;</span><br><span class="line">    var state = 0;</span><br><span class="line"></span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">      if(state === 1) &#123;</span><br><span class="line">          var data = window.location.hash;</span><br><span class="line">          console.log(data);</span><br><span class="line">          iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">          iframe.contentWindow.close();</span><br><span class="line">          document.body.removeChild(iframe);</span><br><span class="line">      &#125; else if(state === 0) &#123;</span><br><span class="line">          state = 1;</span><br><span class="line">          iframe.contentWindow.location = </span><br><span class="line">          &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//b页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    parent.location.hash = &quot;world&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="window-top"><a href="#window-top" class="headerlink" title="window.top"></a>window.top</h4><p>window.top方法可以访问最顶层的window对象，可以取到最顶层window对象的属性和方法。这样子框架就可以操作父页面的交互了。window.parent可以得到父框架的window对象。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function funa()&#123;</span><br><span class="line">        console.log(&quot;a页面的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    iframe.style.display = &apos;none&apos;;</span><br><span class="line">    iframe.src = &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//b页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">console.log(window.top.funa());</span><br><span class="line">function funb()&#123;</span><br><span class="line">  console.log(&quot;b页面的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">iframe.style.display = &apos;none&apos;;</span><br><span class="line">iframe.src = &apos;http://m.zhuanzhuan.58.com:8887/c.html&apos;;</span><br><span class="line">document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//c页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  console.log(window.parent.funb());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="使用postMessage实现页面之间通信"><a href="#使用postMessage实现页面之间通信" class="headerlink" title="使用postMessage实现页面之间通信"></a>使用postMessage实现页面之间通信</h4><p>信息传递除了客户端与服务器之前的传递，还存在以下几个问题：</p><ul><li>页面和新开的窗口的数据交互。</li><li>多窗口之间的数据交互。</li><li>页面与所嵌套的iframe之间的信息传递。</li></ul><p>window.postMessage是一个HTML5的api，允许两个窗口之间进行跨域发送消息。这个应该就是以后解决dom跨域通用方法了，具体可以参照MDN。</p><blockquote><p>补充： 其实还有一些方法，比如window.name和location.hash。就很适用于iframe的跨域，不过iframe用的比较少了，所以这些方法也就有点过时了。</p></blockquote><p>这些就是我对跨域的了解了，实际情况下，一般用cors，jsonp等常见方法就可以了。不过遇到了一些非常规情况，我们还是需要知道有更多的方法可以选择的</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python虚拟环境--virtualenv</title>
      <link href="/2018/10/26/pythonenv/"/>
      <url>/2018/10/26/pythonenv/</url>
      
        <content type="html"><![CDATA[<h2 id="1-virtualenv"><a href="#1-virtualenv" class="headerlink" title="1. virtualenv"></a>1. virtualenv</h2><p>　　virtualenv 是一个创建隔绝的Python环境的工具。virtualenv创建一个包含所有必要的可执行文件的文件夹，用来使用Python工程所需的包。<br><a id="more"></a></p><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure><h3 id="1-2基本使用"><a href="#1-2基本使用" class="headerlink" title="1.2基本使用"></a>1.2基本使用</h3><ol><li>为一个工程创建一个虚拟环境：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd my_project_dir</span><br><span class="line">$ virtualenv venv　　#venv为虚拟环境目录名，目录名自定义</span><br></pre></td></tr></table></figure><p><code>virtualenv venv</code> 将会在当前的目录中创建一个文件夹，包含了Python可执行文件，以及 <code>pip</code> 库的一份拷贝，这样就能安装其他包了。虚拟环境的名字（此例中是 <code>venv</code> ）可以是任意的；若省略名字将会把文件均放在当前目录。</p><p>　　在任何你运行命令的目录中，这会创建Python的拷贝，并将之放在叫做 <code>venv</code> 的文件中。</p><p>　　你可以选择使用一个Python解释器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ virtualenv -p /usr/bin/python2.7 venv　　　　# -p参数指定Python解释器程序路径</span><br></pre></td></tr></table></figure><p>　　这将会使用 <code>/usr/bin/python2.7</code> 中的Python解释器。</p><ol><li>要开始使用虚拟环境，其需要被激活：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source venv/bin/activate</span><br></pre></td></tr></table></figure><p><code>从现在起，任何你使用pip安装的包将会放在 venv</code> 文件夹中，与全局安装的Python隔绝开。</p><p>像平常一样安装包，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install requests</span><br></pre></td></tr></table></figure><ol><li>如果你在虚拟环境中暂时完成了工作，则可以停用它：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ . venv/bin/deactivate</span><br></pre></td></tr></table></figure><p>这将会回到系统默认的Python解释器，包括已安装的库也会回到默认的。</p><p>要删除一个虚拟环境，只需删除它的文件夹。（执行 <code>rm -rf venv</code> ）。</p><p>这里virtualenv 有些不便，因为virtual的启动、停止脚本都在特定文件夹，可能一段时间后，你可能会有很多个虚拟环境散落在系统各处，你可能忘记它们的名字或者位置。</p><h2 id="2-virtualenvwrapper"><a href="#2-virtualenvwrapper" class="headerlink" title="2. virtualenvwrapper"></a>2. virtualenvwrapper</h2><p>　　鉴于virtualenv不便于对虚拟环境集中管理，所以推荐直接使用virtualenvwrapper。 virtualenvwrapper提供了一系列命令使得和虚拟环境工作变得便利。它把你所有的虚拟环境都放在一个地方。</p><h3 id="2-1-安装virtualenvwrapper"><a href="#2-1-安装virtualenvwrapper" class="headerlink" title="2.1 安装virtualenvwrapper"></a>2.1 安装virtualenvwrapper</h3><p>(确保virtualenv已安装)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenvwrapper</span><br><span class="line">pip install virtualenvwrapper-win　　#Windows使用该命令</span><br></pre></td></tr></table></figure><p>安装完成后，在~/.bashrc写入以下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export WORKON_HOME=~/Envs</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p>第一行：<strong>virtualenvwrapper</strong>存放虚拟环境目录</p><p>第二行：<strong>virtrualenvwrapper</strong>会安装到python的bin目录下，所以该路径是python安装目录下bin/virtualenvwrapper.sh</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc　　　　#读入配置文件，立即生效</span><br></pre></td></tr></table></figure><p>　</p><h3 id="2-2-virtualenvwrapper基本使用"><a href="#2-2-virtualenvwrapper基本使用" class="headerlink" title="2.2 virtualenvwrapper基本使用"></a>2.2 virtualenvwrapper基本使用</h3><ol><li>创建虚拟环境——<strong>mkvirtualenv</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkvirtualenv venv</span><br></pre></td></tr></table></figure><p>这样会在WORKON_HOME变量指定的目录下新建名为venv的虚拟环境。</p><p>若想指定python版本，可通过”–python”指定python解释器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkvirtualenv --python=/usr/local/python3.5.3/bin/python venv</span><br></pre></td></tr></table></figure><ol start="2"><li>基本命令 　</li></ol><p>　　查看当前的虚拟环境目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# workon</span><br><span class="line">py2</span><br><span class="line">py3</span><br></pre></td></tr></table></figure><p>　　切换到虚拟环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# workon py3</span><br><span class="line">(py3) [root@localhost ~]#</span><br></pre></td></tr></table></figure><p>　　退出虚拟环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(py3) [root@localhost ~]# deactivate</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>　　删除虚拟环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmvirtualenv venv</span><br></pre></td></tr></table></figure><blockquote><p>本文参考链接：<a href="http://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html" target="_blank" rel="noopener">http://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅析Python日志重复输出问题</title>
      <link href="/2018/10/17/logging/"/>
      <url>/2018/10/17/logging/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/868097/pexels-photo-868097.jpeg?cs=srgb&amp;dl=adventure-backpack-blue-mountains-868097.jpg&amp;fm=jpg" alt=""></p><a id="more"></a><h2 id="问题起源："><a href="#问题起源：" class="headerlink" title="问题起源："></a>问题起源：</h2><p>​    在学习了python的函数式编程后，又接触到了logging这样一个强大的日志模块。为了减少重复代码，应该不少同学和我一样便迫不及待的写了一个自己的日志函数，比如下面这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里为了便于理解，简单的展示了一个输出到屏幕的日志函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line"></span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setLevel(logging.ERROR)</span><br><span class="line">    fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">    ch.setFormatter(fmt)</span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log().error(<span class="string">'run one'</span>)</span><br><span class="line">my_log().error(<span class="string">'run two'</span>)</span><br><span class="line">my_log().error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><p>函数写好了，看起来似乎也没有问题，我们来运行一下！</p><p>结果如下：</p><blockquote><p>2018-06-21 13:06:37,569 - mysql.log - ERROR - run one<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run two<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run two<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run three<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run three<br>2018-06-21 13:06:37,569 - mysql.log - ERROR - run three</p></blockquote><p>日志居然重复输出了，且数量递增。</p><hr><h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><ul><li><p>实际上<code>logger = logging.getLogger(&#39;mysql.log&#39;)</code>在执行时，没有每次生成一个新的logger，而是先检查内存中是否存在一个叫做‘mysql.log’的logger对象，存在则取出，不存在则新建。</p></li><li><p>实例化的logger对象具有‘handlers’这样一个属性来存储 Handler，代码演示如下：</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">()</span>:</span></span><br><span class="line">logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line"><span class="comment"># 每次被调用后打印出logger的handlers列表</span></span><br><span class="line">print(logger.handlers)</span><br><span class="line"></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.ERROR)</span><br><span class="line">fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">ch.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log().error(<span class="string">'run one'</span>)</span><br><span class="line">my_log().error(<span class="string">'run two'</span>)</span><br><span class="line">my_log().error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>[]<br>2018-06-21 13:26:14,059 - mysql.log - ERROR - run one<br>[&lt;StreamHandler \<stderr> (ERROR)&gt;]<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run two<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run two<br>[&lt;StreamHandler \<stderr> (ERROR)&gt;, &lt;StreamHandler \<stderr> (ERROR)&gt;]<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run three<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run three<br>2018-06-21 13:26:14,060 - mysql.log - ERROR - run three</stderr></stderr></stderr></p></blockquote><ol><li><code>logger.handlers</code>最初是一个空列表，执行‘logger.addHandler(ch)’添加一个‘StreamHandler’，输出一条日志</li><li>在第二次被调用时，<code>logger.handlers</code>已经存在一个‘StreamHandler’，再次执行‘logger.addHandler(ch)’就会再次添加一个‘StreamHandler’，此时的logger有两个‘StreamHandler’，输出两条重复的日志</li><li>在第三次被调用时，<code>logger.handlers</code>已经存在两个‘StreamHandler’，再次执行‘logger.addHandler(ch)’就会再次添加一个，此时的logger有三个‘StreamHandler’，输出三条重复的日志</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="1-改名换姓"><a href="#1-改名换姓" class="headerlink" title="1.改名换姓"></a>1.改名换姓</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为日志函数添加一个name，每次调用时传入不同的日志名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">(name)</span>:</span></span><br><span class="line">    logger = logging.getLogger(name)</span><br><span class="line"></span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setLevel(logging.ERROR)</span><br><span class="line">    fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">    ch.setFormatter(fmt)</span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log(<span class="string">'log1'</span>).error(<span class="string">'run one'</span>)</span><br><span class="line">my_log(<span class="string">'log2'</span>).error(<span class="string">'run two'</span>)</span><br><span class="line">my_log(<span class="string">'log3'</span>).error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>2018-06-21 13:40:51,685 - log1 - ERROR - run one<br>2018-06-21 13:40:51,685 - log2 - ERROR - run two<br>2018-06-21 13:40:51,685 - log3 - ERROR - run three</p></blockquote><h3 id="2-及时清理（logger-handlers-clear）"><a href="#2-及时清理（logger-handlers-clear）" class="headerlink" title="2.及时清理（logger.handlers.clear）"></a>2.及时清理（logger.handlers.clear）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line">    <span class="comment"># 每次被调用后，清空已经存在handler</span></span><br><span class="line">    logger.handlers.clear()</span><br><span class="line"></span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setLevel(logging.ERROR)</span><br><span class="line">    fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">    ch.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log().error(<span class="string">'run one'</span>)</span><br><span class="line">my_log().error(<span class="string">'run two'</span>)</span><br><span class="line">my_log().error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><p><strong>ps：removeHandler方法（兼容性较差）</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这种写法下的可以使用removeHandler方法(logger.handlers.clear也可以使用在这种写法的函数内)</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">(msg)</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line"></span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setLevel(logging.ERROR)</span><br><span class="line">    fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">    ch.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line">    logger.error(msg)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在使用完ch后从移除Handler</span></span><br><span class="line">    logger.removeHandler(ch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log(<span class="string">'run one'</span>)</span><br><span class="line">my_log(<span class="string">'run two'</span>)</span><br><span class="line">my_log(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><h3 id="3-用前判断"><a href="#3-用前判断" class="headerlink" title="3.用前判断"></a>3.用前判断</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_log</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">'mysql.log'</span>)</span><br><span class="line">    <span class="comment"># 判断logger是否已经添加过handler，是则直接返回logger对象，否则执行handler设定以及addHandler(ch)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> logger.handlers:</span><br><span class="line">        ch = logging.StreamHandler()</span><br><span class="line">        ch.setLevel(logging.ERROR)</span><br><span class="line">        fmt = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">        ch.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">        logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_log().error(<span class="string">'run one'</span>)</span><br><span class="line">my_log().error(<span class="string">'run two'</span>)</span><br><span class="line">my_log().error(<span class="string">'run three'</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    第一次遇到日志重复输出问题，那时还没有学习到面向对象编程的内容，当时并没有真正理解logging模块。学习完面向对象编程后，回过头来再思考这些问题有了豁然开朗的感觉。</p><p>​        比如起初对<code>logging.getLogger</code>的实际原理不是很理解，在学习了面向对象编程中的hasattr、getattr、setattr这样一些方法后就恍然大悟了。所以诸君如果现在还是对logging模块不太理解，不妨先不纠结于这些细节，继续学下去。</p><p>​    知识面扩充后，曾经的一些难题自然就会迎刃而解：）</p><hr><blockquote><p>参考内容：<br>luffycity : <a href="https://www.luffycity.com/home" target="_blank" rel="noopener">https://www.luffycity.com/home</a><br><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">The Python Standard Library</a><br><a href="https://blog.csdn.net/huilan_same" target="_blank" rel="noopener">huilan_same</a> ：<a href="https://blog.csdn.net/huilan_same/article/details/51858817" target="_blank" rel="noopener">https://blog.csdn.net/huilan_same/article/details/51858817</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES基础学习</title>
      <link href="/2018/10/17/ES6/"/>
      <url>/2018/10/17/ES6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是ECMAScript"><a href="#1-什么是ECMAScript" class="headerlink" title="1. 什么是ECMAScript"></a>1. 什么是ECMAScript</h2><blockquote><p>ECMAScript是一种由<a href="https://baike.baidu.com/item/Ecma%E5%9B%BD%E9%99%85" target="_blank" rel="noopener">Ecma国际</a>（前身为<a href="https://baike.baidu.com/item/%E6%AC%A7%E6%B4%B2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B6%E9%80%A0%E5%95%86%E5%8D%8F%E4%BC%9A/2052072" target="_blank" rel="noopener">欧洲计算机制造商协会</a>,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">程序设计语言</a>。这种语言在<a href="https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="noopener">万维网</a>上应用广泛，它往往被称为<a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a>或<a href="https://baike.baidu.com/item/JScript" target="_blank" rel="noopener">JScript</a>，所以它可以理解为是javascript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。<br><a id="more"></a></p></blockquote><h3 id="ECMAScript-与-JavaScript"><a href="#ECMAScript-与-JavaScript" class="headerlink" title="ECMAScript 与 JavaScript"></a>ECMAScript 与 JavaScript</h3><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p><p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p><p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p><h2 id="2-什么是ES6"><a href="#2-什么是ES6" class="headerlink" title="2. 什么是ES6"></a>2. 什么是ES6</h2><p><strong>ES6</strong>是继ES5之后的一次主要改进，语言规范由ES5.1时代的245页扩充至600页。</p><p>ES6增添了许多必要的特性，例如：模块和类，以及一些实用特性，例如Maps、Sets、Promises、生成器（Generators）等。</p><p>尽管ES6做了大量的更新，但是它依旧完全向后兼容以前的版本，标准化委员会决定避免由不兼容版本语言导致的“web体验破碎”。结果是，所有老代码都可以正常运行，整个过渡也显得更为平滑，但随之而来的问题是，开发者们抱怨了多年的老问题依然存在。</p><h2 id="3-ES6语法"><a href="#3-ES6语法" class="headerlink" title="3. ES6语法"></a>3. ES6语法</h2><h3 id="3-1-let命令"><a href="#3-1-let命令" class="headerlink" title="3.1 let命令"></a>3.1 let命令</h3><h4 id="3-1-1-基础用法"><a href="#3-1-1-基础用法" class="headerlink" title="3.1.1 基础用法"></a>3.1.1 基础用法</h4><p>es6新增了 let 命令，用来声明变量。它的用法类似于 var ，但是所声明的变量，只在let命令所在的代码块内有效。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  var b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure><p>上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错， var 声明的变量返回了正确的值。这表明， let 声明的变量只在它所在的代码块有效</p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i);</span><br><span class="line">// ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用<code>var</code>，最后输出的是<code>10</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p><p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  let i = &apos;abc&apos;;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br></pre></td></tr></table></figure><p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h4 id="3-1-2-不存在变量提升"><a href="#3-1-2-不存在变量提升" class="headerlink" title="3.1.2 不存在变量提升"></a>3.1.2 不存在变量提升</h4><p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// var 的情况</span><br><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">var foo = 2;</span><br><span class="line"></span><br><span class="line">// let 的情况</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line">let bar = 2;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h4 id="3-1-3-为什么需要块级作用域？"><a href="#3-1-3-为什么需要块级作用域？" class="headerlink" title="3.1.3 为什么需要块级作用域？"></a>3.1.3 为什么需要块级作用域？</h4><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p> 第一种场景，内层变量可能会覆盖外层变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &apos;hello world&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h4 id="3-1-4-不允许重复声明"><a href="#3-1-4-不允许重复声明" class="headerlink" title="3.1.4 不允许重复声明"></a>3.1.4 不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不能在函数内部重新声明参数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func(arg) &#123;</span><br><span class="line">  let arg; // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    let arg; // 不报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-const命令"><a href="#3-2-const命令" class="headerlink" title="3.2 const命令"></a>3.2 const命令</h3><h4 id="3-2-1-基本用法"><a href="#3-2-1-基本用法" class="headerlink" title="3.2.1 基本用法"></a>3.2.1 基本用法</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line"></span><br><span class="line">PI = 3;</span><br><span class="line">// TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure><p>上面代码表明改变常量的值会报错。</p><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const foo;</span><br><span class="line">// SyntaxError: Missing initializer in const declaration</span><br></pre></td></tr></table></figure><p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX // Uncaught ReferenceError: MAX is not defined</span><br></pre></td></tr></table></figure><p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  console.log(MAX); // ReferenceError</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var message = &quot;Hello!&quot;;</span><br><span class="line">let age = 25;</span><br><span class="line"></span><br><span class="line">// 以下两行都会报错</span><br><span class="line">const message = &quot;Goodbye!&quot;;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure><h3 id="3-3-模板字符串"><a href="#3-3-模板字符串" class="headerlink" title="3.3 模板字符串"></a>3.3 模板字符串</h3><p>传统的JavaScript语言，输出模板通常是这样的写的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;#result&apos;).append(</span><br><span class="line">  &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; +</span><br><span class="line">  &apos;items in your basket, &apos; +</span><br><span class="line">  &apos;&lt;em&gt;&apos; + basket.onSale +</span><br><span class="line">  &apos;&lt;/em&gt; are on sale!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;#result&apos;).append(`</span><br><span class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</span><br><span class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript &apos;\n&apos; is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1</span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">let name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let greeting = `\`Yo\` World!`;</span><br></pre></td></tr></table></figure><p>输入结果：<code>Yo</code> World!</p><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;#list&apos;).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><p>阮一峰：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a></p><p>维基百科： <a href="https://zh.wikipedia.org/wiki/ECMAScript" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/ECMAScript</a></p><p>百度百科：<a href="https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/17/hello-world/"/>
      <url>/2018/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="感谢每一个浏览本页面的人"><a href="#感谢每一个浏览本页面的人" class="headerlink" title="感谢每一个浏览本页面的人"></a>感谢每一个浏览本页面的人</h2><p>目前还是一个学习者</p><p>为了实现那些少年时代的愿景</p><p>还在努力的路上</p><h3 id="期待自己变得更加强大"><a href="#期待自己变得更加强大" class="headerlink" title="期待自己变得更加强大"></a>期待自己变得更加强大</h3><p>或许我爱的人也有机会看到这段话</p><p>知道吗</p><p>你是我所有的动力</p><h3 id="感谢你"><a href="#感谢你" class="headerlink" title="感谢你"></a>感谢你</h3>]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index%20-%20%E5%89%AF%E6%9C%AC.html"/>
      <url>/tags/index%20-%20%E5%89%AF%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
